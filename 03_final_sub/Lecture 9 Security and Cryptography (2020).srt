1
00:00:01,250 --> 00:00:04,200
好的,那么,让我们开始今天的讲座吧.
Okay, so again, let's get started with today's lecture. 

2
00:00:04,200 --> 00:00:07,825
今天,我们将讨论安全和密码学,
So today, we're going to be talking about security and cryptography.

3
00:00:07,825 --> 00:00:13,300
今年的这节课与去年的略有不同.
And today's lecture is going to be a little bit different than \N our treatment of this topic in last year's class. 

4
00:00:13,300 --> 00:00:20,000
去年,我们更注重从计算机用户的角度讨论安全和隐私问题,
So last year, we focused a little bit more on security and privacy from the perspective of a user of a computer, 

5
00:00:20,000 --> 00:00:24,025
但今天我们将更多地关注安全和密码学的概念,
but today we're going to focus a little bit more on security and cryptography concepts 

6
00:00:24,025 --> 00:00:29,025
这些概念有利于理解我们在这门课上早些时候讨论的一些工具.
that are relevant in understanding some of the tools that we talked about earlier in this class. 

7
00:00:29,025 --> 00:00:35,025
例如,我们在Git讲座中讨论了哈希函数或加密哈希函数(如sha-1),
For example, we talked about hash functions or cryptographic hash functions like sha-1 in the Git lecture, 

8
00:00:35,025 --> 00:00:42,150
在命令行环境讲座中讲ssh时提到了公钥.
or we talked about public keys \N when we talked about SSH in the command line environment lecture. 

9
00:00:42,150 --> 00:00:46,525
因此,今天我们将更详细地讨论这些密码学概念,
And so today, we'll talk about these different cryptographic primitives in more detail 

10
00:00:46,525 --> 00:00:51,475
了解它们的工作原理以及它们在这些工具中的应用.
and get an understanding of how they work and how they're used in these different tools that we're teaching in this class.

11
00:00:51,475 --> 00:00:56,625
这个讲座没法替代正规的安全课程,
This lecture is not a substitute for a more rigorous class in security. 

12
00:00:56,625 --> 00:01:00,264
麻省理工有很多非常好的课程,例如MIT6.858,
So there are a bunch of really good classes at MIT like 6.858,

13
00:01:00,264 --> 00:01:02,225
这门课就是关于计算机系统安全的,
 which is on computer system security,

14
00:01:02,225 --> 00:01:07,800
或者MIT6.857和MIT6.875,这两门课更着重于密码学.
or 6.857 and 6.875, which are more focused on cryptography. 

15
00:01:07,800 --> 00:01:13,625
因此,如果没有接受过正规的安全课程的培训,不要从事安全工作.
So don't do security work without formal training in security from these classes or elsewhere. 

16
00:01:13,625 --> 00:01:17,200
除非你是专家,否则不要自己开发加密算法,
And unless you're an expert, don't roll your own crypto. 

17
00:01:17,200 --> 00:01:20,050
不要构建自己的加密实现或协议.
Don't build your own crypto implementations or protocols. 

18
00:01:20,050 --> 00:01:22,975
这个原则也同样适用于计算机系统安全.
And the same principle applies to computer system security. 

19
00:01:22,975 --> 00:01:25,116
这个讲座不是教你如何构建自己的东西,
This lecture is not about building your own stuff.

20
00:01:25,116 --> 00:01:28,125
而是带你了解已经存在的东西.
it's about understanding what's already out there. 

21
00:01:28,125 --> 00:01:30,322
这节课将对密码学的基本概念
And so this lecture will have a very informal 

22
00:01:30,322 --> 00:01:33,675
进行非正式但实用的处理.
but we think practical treatment of these basic cryptography concepts, 

23
00:01:33,675 --> 00:01:38,600
希望这节课能帮你理解之前课上讲的一些工具.
and yeah, hopefully, it'll help you understand some of the tools we talked about earlier in this class.

24
00:01:38,600 --> 00:01:41,650
有关今天规划有什么问题吗?
Any questions about the plan for today's lecture? 

25
00:01:41,650 --> 00:01:43,375
太好了.
Great. 

26
00:01:43,375 --> 00:01:46,850
那么今天的第一个话题是熵.
So the first topic for today is something called entropy. 

27
00:01:46,850 --> 00:01:48,750
熵是对随机性的一种度量,
Entropy is a measure of randomness, 

28
00:01:48,750 --> 00:01:52,975
这在确定密码强度时非常有用.
and this is useful, for example, when trying to determine the strength of a password. 

29
00:01:52,975 --> 00:01:55,975
让我们看看xkcd的这个漫画,
So let's take a look at this comic from xkcd. 

30
00:01:55,975 --> 00:01:57,975
我们很喜欢xkcd漫画.
We're a big fan of xkcd comics. 

31
00:01:57,975 --> 00:02:01,475
如果你以前看过这个漫画,请举手.
So this comic raises your hand if you've seen this before. 

32
00:02:01,475 --> 00:02:02,775
好的,有很多人都看过这个漫画.
Okay, a good number of you. 

33
00:02:02,775 --> 00:02:08,650
这幅漫画讲的是常要求用户设置密码的方式,
So this comic is complaining about this common pattern that's been taught to users of computers, 

34
00:02:08,650 --> 00:02:12,575
即当你设计密码时,
that when you design passwords, they should be things like 

35
00:02:12,575 --> 00:02:20,400
它们应该是像"t#0rU&b40rM$"或"p3@ch3$"这样的字符串,
"t#0rU&b40rM$" or "p3@ch3$" -- a string in the top left -- like we should design passwords 

36
00:02:20,400 --> 00:02:22,395
就像我们应该使用各种字符混合其他内容的密码,
that are full of funny characters and things like that 

37
00:02:22,395 --> 00:02:24,275
以使攻击者很难猜测.
to make it hard for attackers to guess. 

38
00:02:24,275 --> 00:02:28,375
然而,事实证明,像这样的密码实际上相当脆弱,
And yet, it turns out that passwords like that are actually pretty weak and guessable 

39
00:02:28,375 --> 00:02:31,925
容易被擅长暴力攻击的计算机破解.
by computers that can guess passwords really fast and brute-force attacks. 

40
00:02:31,950 --> 00:02:37,175
另一方面,像左下角的密码("correcthorsebatterystaple")
And on the other hand, passwords which maybe intuitively don't look as secure, 

41
00:02:37,175 --> 00:02:40,400
这样直觉上看起来不太安全的密码,
like the one on the bottom left, "correcthorsebatterystaple," 

42
00:02:40,400 --> 00:02:43,375
却被证明更安全.
that one turns out to be way more secure.

43
00:02:43,375 --> 00:02:48,400
那么我该如何量化这些不同密码的安全性呢?
So how do I actually quantify the security of these different passwords? 

44
00:02:48,400 --> 00:02:51,625
可以测算密码的随机性,
It's by measuring the amount of randomness in the password, 

45
00:02:51,625 --> 00:02:53,700
即算出其中有多少比特的随机性.
how many bits of randomness are in there. 

46
00:02:53,700 --> 00:02:57,325
因此,熵是以bit为单位进行度量的.
And so entropy is measured in bits.

47
00:02:57,325 --> 00:02:59,925
这里的bit和信息论中的bit是相同的.
This is like the same bits from information theory.

48
00:02:59,925 --> 00:03:08,225
我们只会讨论一种简单情况,
And we're only going to talk about the simple case 

49
00:03:08,225 --> 00:03:10,675
即只考虑从一组集合中随机选择,
where you're trying to measure the amount of randomness

50
00:03:10,675 --> 00:03:14,125
会有多少bit的随机性.
when you're choosing from a set of things uniformly at random.

51
00:03:14,125 --> 00:03:19,450
例如,当你想构建一个由四个随机单词组成的密码,
So for example, when you're constructing a password that's in the format of four random words, 

52
00:03:19,450 --> 00:03:25,300
你会考虑从某个字典中随机选择四个单词.
you're kind of considering all possible sequences of \N four random words made from some dictionary you have. 

53
00:03:25,300 --> 00:03:27,453
比如说你可能有一本十万个单词的字典,
You might have a dictionary with, say, a hundred thousand words

54
00:03:27,453 --> 00:03:30,425
你随机选择每个单词.
and you're selecting each word uniformly at random. 

55
00:03:30,425 --> 00:03:32,400
有多少种可能性?
How many possibilities are there? 

56
00:03:32,400 --> 00:03:34,700
你可以通过这个例子算出来 
Well, you can go and figure that out in that example, 

57
00:03:34,700 --> 00:03:36,985
一旦你知道有多少种可能性,
 once you know how many possibilities there are, 

58
00:03:36,985 --> 00:03:46,350
熵就是以2为底,对该可能性数量取对数.
the measure of entropy is log base 2 of the number of possibilities.  

59
00:03:46,350 --> 00:03:50,525
正如漫画所展示的那样,
And as that comic suggests, this is related to 

60
00:03:50,525 --> 00:03:54,425
这与攻击者暴力破解能力有关.
how long it'll take an attacker to try to brute-force through your different passwords. 

61
00:03:54,475 --> 00:03:56,500
如果有一千个可能性,
Like if you have a thousand possibilities, 

62
00:03:56,500 --> 00:03:58,850
那么攻击者可以每秒尝试一千个密码,
you're guessing passwords at a thousand passwords a second, 

63
00:03:58,850 --> 00:04:01,100
那这就不是一个很好的密码.
that's not a very good password. 

64
00:04:02,225 --> 00:04:05,475
这是几个简单的例子.
So this is a couple of quick examples. 

65
00:04:05,475 --> 00:04:08,600
抛硬币有两种可能性,
A coin flip has two possibilities, 

66
00:04:08,600 --> 00:04:10,150
假设我们有一个公平的硬币.
and let's assume we have a fair coin. 

67
00:04:10,150 --> 00:04:19,575
因此,抛硬币的熵是以2为底2的对数,就熵为1bit.
So a coin flip has log base 2 of 2, which is one bit of entropy. 

68
00:04:19,575 --> 00:04:23,125
还比如说掷骰子.
Another thing we might look at is something like a dice roll. 

69
00:04:24,175 --> 00:04:25,925
有六种可能性,
So there are six possibilities, 

70
00:04:25,925 --> 00:04:33,875
以2为底6的对数,大约是2.6bit的熵.
and log 2 of 6 is something like 2.6 bits of entropy. 

71
00:04:33,875 --> 00:04:37,825
这就是我们量化随机性的方法.
So that's how we quantify the amount of randomness in something.

72
00:04:39,175 --> 00:04:42,025
现在,回到xkcd漫画中的那个例子,
Now, going back to that example in the xkcd comic, 

73
00:04:42,025 --> 00:04:44,300
当我们要想算出密码的熵是多少,
when we want to figure out how much entropy is in a password, 

74
00:04:44,325 --> 00:04:47,925
我们必须知道密码是如何生成的.
we have to consider the model for how the password was generated. 

75
00:04:47,925 --> 00:04:50,404
例如,在左上角,你可以考虑,
For example, in the top left, you could consider,

76
00:04:50,404 --> 00:04:52,825
我们取一个单词字典,
 okay, we take one dictionary word, 

77
00:04:52,850 --> 00:04:58,226
把单词的某些字符中用看起来像的数字进行替换,
make some substitutions of some of the characters with numbers that look similar to that character,

78
00:04:58,226 --> 00:05:00,200
再在末尾添加一个标点符号,
add one punctuation mark at the end, 

79
00:05:00,200 --> 00:05:01,702
然后再添加一个数字.
and add one numeral after that. 

80
00:05:01,702 --> 00:05:06,575
我们可以计算这样的密码有多少种可能性,
We can take that model and then use common rhetoric to figure out how many possibilities there are, 

81
00:05:06,575 --> 00:05:10,075
然后再计算熵.
and from that, we can derive \N how many bits of entropy are in that password. 

82
00:05:10,075 --> 00:05:11,780
在那个特定的例子中,
So in that particular example, 

83
00:05:11,780 --> 00:05:13,975
我不知道他们到底用什么模型作为密码,
I don't know exactly what model they were using for the password, 

84
00:05:13,975 --> 00:05:16,575
但他们计算出了28bits熵.
but they calculated their 28 bits of entropy. 

85
00:05:16,950 --> 00:05:20,925
而在左下角的示例中,"correcthorsebatterystaple"
Whereas in the bottom-left example, "correcthorsebatterystaple", 

86
00:05:20,975 --> 00:05:26,125
他们假设你生成密码使用的大约是2,000个单词的字典.
they assume that you're working from a dictionary of about 2,000 words. 

87
00:05:26,125 --> 00:05:28,548
所以把字典中的四个单词组合在一起的密码,
And so when you combine four of those words together, 

88
00:05:28,548 --> 00:05:30,625
大约有44位的熵.
you get about 44 bits of entropy from that. 

89
00:05:30,625 --> 00:05:33,125
因此,它比前面的那几个例子安全得多.
So it's much more secure than the example before it.

90
00:05:33,300 --> 00:05:38,525
关于我刚刚讲的这部分有什么问题吗?
So any questions about this definition of entropy or why it's useful?

91
00:05:42,475 --> 00:05:45,375
当你生成自己的密码时,请记住这一点.
And when you're generating your own passwords, keep this in mind. 

92
00:05:45,375 --> 00:05:47,050
你应该要一个高熵密码,
You want a high-entropy password, 

93
00:05:47,050 --> 00:05:50,525
具体熵要多高取决于你要保护的内容.
and the exact number you need depends on exactly what you're trying to protect against. 

94
00:05:50,525 --> 00:05:52,399
一般来说,在安全方面,
Like in general, a concept in securities, 

95
00:05:52,399 --> 00:05:54,469
你需要考虑你的威胁模型.
you have to keep in mind what your threat model is. 

96
00:05:54,469 --> 00:05:56,683
例如,你应该考虑你的攻击者是谁,
Like what attackers you're concerned about,

97
00:05:56,683 --> 00:05:58,600
他们可能使用什么样的攻击技术.
 what kinds of technique the attackers might be using. 

98
00:05:58,600 --> 00:06:03,975
例如,这个漫画提到了一个攻击者可以每秒猜测一千个密码.
For example, this comic refers to an attacker that can guess a thousand passwords a second. 

99
00:06:03,975 --> 00:06:06,774
这可能是一些网络服务上的情况,
This might be something that's possible for say, 

100
00:06:06,774 --> 00:06:13,075
比如攻击者会用随机密码来尝试登录你的电子邮箱.
a web service that allows people to try to log in with your email \N and then random passwords that the attacker is trying. 

101
00:06:13,075 --> 00:06:16,469
但这种每秒尝试一千次密码的模型
But this thousand passwords a second model 

102
00:06:16,469 --> 00:06:18,425
可能并不适用于其他场景.
might not be accurate for other scenarios. 

103
00:06:18,425 --> 00:06:21,149
例如,离线密码破解场景
For example, an offline password cracking scenario 

104
00:06:21,149 --> 00:06:23,732
或者攻击者已经破解了一个网站
or maybe the attacker has broken into a website 

105
00:06:23,732 --> 00:06:25,025
并下载了它们的数据库,
and downloaded their database 

106
00:06:25,125 --> 00:06:28,075
他们可能得到了你的密码的某种模糊形式,
and they have some obfuscated form of your password, 

107
00:06:28,075 --> 00:06:29,425
并且正在尝试找出正确的密码.
and they're trying to figure out what the password is. 

108
00:06:29,425 --> 00:06:31,078
也许他们可以并行攻击,
Maybe they can parallelize this attack

109
00:06:31,078 --> 00:06:32,975
让每秒猜测数达到一百万次.
 and make it go to a million guesses a second .

110
00:06:32,975 --> 00:06:36,650
所以你需要多少熵值,取决于你试图保护什么.
and so exactly how much entropy you need depends on exactly what you're trying to protect against. 

111
00:06:36,775 --> 00:06:40,725
不过要是密码已经受到了{\rcode2}网站保护[*]{\r},
But roughly forty bits of entropy might be good enough for, 
*[这里的意思应该是网站本身会对密码有一些加密等保护措施]

112
00:06:40,725 --> 00:06:45,550
那大约四十个比特的熵可能就够了.
which is protected by a website and you're concerned about online password guesses. 

113
00:06:45,575 --> 00:06:48,675
如果你担心离线攻击并且想要真正的安全,
And then maybe something like 80 bits of entropy might be good

114
00:06:48,675 --> 00:06:52,300
那么可能需要八十比特的熵.
if you're concerned about offline attacks and you want to be really, really secure. 

115
00:06:52,300 --> 00:06:54,400
刚刚讲的这些只是一个大致指南.
So they're rough guidelines you can use. 

116
00:06:58,425 --> 00:07:01,050
那么,如何生成强密码呢?
And then how do you actually generate strong passwords? 

117
00:07:01,050 --> 00:07:02,700
首先,你需要一些密码模型.
Well, you have some model for a password. 

118
00:07:02,700 --> 00:07:04,525
例如,常用的字典,
For example, the for dictionary works thing, 

119
00:07:04,525 --> 00:07:06,075
你可以用一个字典.
and you can actually get a dictionary. 

120
00:07:06,075 --> 00:07:08,275
然后,你可以使用类似于掷骰子的方法.
And then you can use methods like dice, where, 

121
00:07:08,275 --> 00:07:10,246
在课程笔记中有一些链接,
so there's some we linked to in the lecture notes 

122
00:07:10,246 --> 00:07:13,100
你可以获得一个仿真物理骰子并将其滚动,
where you can actually get physical dice and roll them 

123
00:07:13,100 --> 00:07:15,272
然后你可以将掷骰结果映射到字典,
and then map dice rolls to dictionary words

124
00:07:15,272 --> 00:07:17,250
最终将其转换为密码.
 in order to eventually turn that into a password. 

125
00:07:17,300 --> 00:07:21,575
使用一些随机的物理标记,
And doing something like this, \N using some kind of physical token that you know is random,

126
00:07:21,575 --> 00:07:26,441
如平衡骰子或硬币,是一个好方法,
like a balanced die or a coin that you know is balanced, is a good thing to do.

127
00:07:26,441 --> 00:07:29,375
因为人类实际上并不擅长选择随机数字.
Because humans are actually not good at choosing random numbers, right? 

128
00:07:29,375 --> 00:07:31,825
如果我让你从1到100中随机选择一个数字,
If I just asked you to name a random number for 1 to 100,

129
00:07:31,825 --> 00:07:35,000
你很有可能不能均匀随机地进行选择.
chances are that you're probably not doing so uniformly at random very well. 

130
00:07:35,000 --> 00:07:38,950
这就是为啥我们要使用物理标记来进行随机.
And so that's why it's actually good to use these physical tokens in order to produce randomness. 

131
00:07:41,525 --> 00:07:43,975
熵是我们的第一个密码学概念.
So entropy, that's our first concept recovering 

132
00:07:43,975 --> 00:07:50,450
到现在为止有啥问题吗?好的.
Any questions about that or about this comic? Great. 

133
00:07:50,450 --> 00:07:54,225
那么进入有趣但稍微复杂的话题,
So getting into slightly more interesting and complicated topics,

134
00:07:54,225 --> 00:07:57,625
下一个我们要谈论的是哈希函数.
the next thing we're going to talk about is hash functions. 

135
00:07:57,625 --> 00:08:00,617
大部分应该都参加了上一次关于Git的讲座吧,
So hopefully, most of you were here during the get lecture

136
00:08:00,617 --> 00:08:03,125
那次讲座就提到了Git使用了SHA-1哈希函数.
 where we talked about the SHA-1 hash function used in get. 

137
00:08:03,125 --> 00:08:06,450
现在我们要聊聊更多细节,
So now going into that topic in a little bit more detail,

138
00:08:11,475 --> 00:08:18,150
哈希函数能够将任意长度的输入数据压缩为固定长度的输出.
hash functions at a high level are functions that map a variable amount of data into a fixed size output. 

139
00:08:18,150 --> 00:08:23,675
例如,SHA-1哈希函数就是一个哈希函数.
So for example, the SHA-1 hash function is one example of a hash function 

140
00:08:23,675 --> 00:08:26,682
SHA-1需要输入一些byte数据,
that takes in some input of some number of bytes 

141
00:08:26,682 --> 00:08:33,350
但它会有恰好160bits输出.
and outputs exactly 160 bits of output. 

142
00:08:33,800 --> 00:08:38,025
这就是SHA-1的一个特点.
So that's kind of the type signature of this particular hash function. 

143
00:08:38,025 --> 00:08:41,725
哈希函数具有一些有用的属性.
And then these functions have some number of properties that are useful. 

144
00:08:41,725 --> 00:08:45,025
总的来说,哈希函数可以被认为是
So at a high level, these can be thought about as

145
00:08:45,025 --> 00:08:49,325
输出一个随机数且难以逆推的函数.
 hard-to-invert functions that have random-looking outputs. 

146
00:08:49,325 --> 00:08:54,125
我们可以举些例子看看.
We can actually try this out on some random piece of data. 

147
00:08:54,125 --> 00:09:01,225
例如,如果我在我的终端中输入 {\rcode}printf 'hello'{\r},
For example, if I enter into my terminal "printf 'hello'", this does exactly what you would expect it does, 

148
00:09:01,225 --> 00:09:02,725
他将输出"hello",
prints the set to standard out, 

149
00:09:02,725 --> 00:09:05,850
然后我可以将其传递给"sha1sum"命令.
and I can pipe this to the "sha1sum" command. 

150
00:09:05,850 --> 00:09:07,975
这是一个命令行程序,
So this is a command-line program 

151
00:09:07,975 --> 00:09:12,250
读取标准输入流,并计算SHA-1函数,
that accepts input via standard in and computes this SHA-1 function, 

152
00:09:12,250 --> 00:09:14,439
该函数从输入中获取不定长的数据
which takes in some variable number of bytes from the input

153
00:09:14,439 --> 00:09:16,625
并输出一个160bit的数据,
 and produces a 160-bit output,

154
00:09:16,625 --> 00:09:21,325
在这里它表示为十六进制字符串.
which in this particular case is represented or encoded as a hexadecimal string. 

155
00:09:21,325 --> 00:09:23,275
因此,它是一个长度为40的十六进制字符串,
So it's a length 40 hexadecimal string, 

156
00:09:23,275 --> 00:09:24,850
并且你可以看到此输出.
and you see this output right here. 

157
00:09:24,850 --> 00:09:29,025
"-"只是表示它从标准输入中获取了输入.
This "-" just means it took its input from standard in. 

158
00:09:29,025 --> 00:09:32,025
因此,此输出看起来像是一些随机数字,
So this output just looks like some random number, 

159
00:09:32,025 --> 00:09:35,675
但重要的是,这实际上是一个确定的数字.
but one important thing is that this is a deterministic number. 

160
00:09:35,675 --> 00:09:38,750
如果你在自己的设备上执行相同的命令,
If you try the same command on your own computer,

161
00:09:38,750 --> 00:09:41,550
{\rcode}printf 'hello' | sha1sum{\r},你将得到和这里相同的输出.
"printf 'hello' | sha1sum", you will get the same number out. 

162
00:09:41,575 --> 00:09:46,725
因此,SHA-1很有名,人们在其所有参数上都达成了共识.
So SHA-1 is some well-known function that people have agreed upon for all its parameters. 

163
00:09:46,725 --> 00:09:48,871
只要略微调整输入,
we'll see that if we tweak the input a little bit,

164
00:09:48,871 --> 00:09:53,050
比如说将"hello"更改为"Hello",
 like say changed "hello" to "Hello" with a capital "H", 

165
00:09:53,050 --> 00:09:55,375
现在我得到了一个完全不同的输出.
now I get a completely different looking output. 

166
00:09:55,375 --> 00:09:59,225
但它是确定的,即使看起来像是一个随机数,
And this also looks like some other kind of random-ish number, even though it is deterministic, 

167
00:09:59,225 --> 00:10:01,600
并且你可以在自己的计算机上复现这个输出.
and you could reproduce this on your own computer.

168
00:10:06,175 --> 00:10:15,725
哈希函数具有许多重要属性.
Hash functions have a number of properties that are pretty important. 

169
00:10:15,725 --> 00:10:20,050
加密哈希函数具有的第一个属性是它们是不可逆的.
The first property that cryptographic hash functions have is that they're non-invertible. 

170
00:10:20,050 --> 00:10:23,050
这意味着,如果你知道此函数的输出,
And what that means is that if you take the output from this function,

171
00:10:23,050 --> 00:10:28,150
例如那个"aaf4...34d"的输出,
for example, that "aaf4...34d" string shown there

172
00:10:28,150 --> 00:10:33,450
单单从这个输出很难弄清楚输入是什么.
from that output, it's hard to figure out what the input was that produced that output. 

173
00:10:33,725 --> 00:10:37,675
因此,你可以很容易地计算出SHA-1哈希值,
So you can go one way, compute the SHA-1 hash easily, 

174
00:10:37,675 --> 00:10:39,275
但是你无法逆向操作.
but you can't go backwards.

175
00:10:39,275 --> 00:10:44,975
这些函数具有的另一个特性是它们具有抗碰撞性.
Another property that these functions have is that they're collision-resistant. 

176
00:10:49,600 --> 00:10:51,175
这个属性的意思是
And what this property means 

177
00:10:51,175 --> 00:10:56,475
很难找到两个不同的输入产生相同的输出.
is that it's hard to find two different inputs that produce the same output. 

178
00:10:56,850 --> 00:11:01,525
我大概讲了下什么是加密哈希函数.
So this basically describes what a cryptographic hash function is.

179
00:11:01,525 --> 00:11:10,275
你们有什么问题吗?
So any questions about the kind of specification of a cryptographic hash function?  

180
00:11:10,275 --> 00:11:12,800
那么,这些哈希函数实际上有什么用途呢?
Okay, so what are these hash functions actually useful for? 

181
00:11:12,800 --> 00:11:17,150
我们实际上已经在Git讲座中看到了一个应用,就是内容地址存储.
Well, we've already seen one application in Git for content address storage. 

182
00:11:17,150 --> 00:11:24,650
在Git中,我们希望统一命名object仓库中的对象,
So in Git, we want some uniform way of naming different objects that are in the object store, 

183
00:11:24,650 --> 00:11:28,175
而Git可以将它们全部命名为它们的SHA-1哈希.
and it turns out that Git addresses all of them by their SHA-1 hash.

184
00:11:28,175 --> 00:11:31,225
因此,你有存储好的数据,
So you have the actual data you want to store, 

185
00:11:31,225 --> 00:11:35,550
然后要为该数据命名,只需命名其为SHA-1哈希即可.
and then to name that particular piece of data, you just name the SHA-1 hash. 

186
00:11:35,550 --> 00:11:38,525
所有这些都存储在object仓库中.
And all of that is stored in the object store in that particular way. 

187
00:11:39,475 --> 00:11:42,650
我们在查看Git的仓库的时候可以看到.
We see this when looking at many different parts of Git. 

188
00:11:42,650 --> 00:11:44,625
例如,这里,我进入Git仓库.
For example, right here, I'm going to Git repository. 

189
00:11:44,625 --> 00:11:46,725
如果我执行"git log"',它会显示历史记录.
If I do "git log"', it shows me the commits. 

190
00:11:46,750 --> 00:11:52,850
例如,这个数字是这个提交的SHA-1值,
And for example, this number up here is the cryptographic hash function SHA-1 

191
00:11:52,850 --> 00:11:56,325
是这个提交的名字.
applied to the commit object that describes this particular commit.

192
00:11:57,375 --> 00:12:01,022
那么,有人知道为什么Git在这里使用加密哈希函数
So does anybody know why Git uses a cryptographic hash function here

193
00:12:01,022 --> 00:12:02,100
而不是......
 as opposed to... 

194
00:12:02,150 --> 00:12:04,062
你可能在其他课程,
So you might have heard in your other computer science classes,

195
00:12:04,062 --> 00:12:06,200
比如算法的入门课中听说过散列函数,
 like say your introductory algorithms class, 

196
00:12:06,200 --> 00:12:11,575
这个前面没有像"加密哈希函数"加上"加密"这个前缀.
there are things called hash functions without the word 'cryptographic' appended in front of them. 

197
00:12:11,575 --> 00:12:13,975
它们具有类似的属性,
And they have similar properties

198
00:12:13,975 --> 00:12:17,775
能够将可变长的输入压缩为某个固定大小的输出.
 that they turn a variable-sized input into some fixed-size output. 

199
00:12:17,775 --> 00:12:20,878
但是它们并没有完全具备
But they don't quite have these properties 

200
00:12:20,878 --> 00:12:25,075
比如说,难以找到产生特定输出的输入等属性.
where it's hard to find an input that produces a particular output or things like that. 

201
00:12:25,075 --> 00:12:27,200
这是一种比较弱的定义.
It's a kind of weaker definition than this.

202
00:12:27,200 --> 00:12:30,825
那么,为什么在Git中我们要拥有一个加密哈希函数
So why is it that in Git we care about having a cryptographic hash function

203
00:12:30,825 --> 00:12:33,129
而不是一个普通的哈希函数?
as opposed to just a regular old hash function? 

204
00:12:33,129 --> 00:12:34,425
大家有什么想法吗?
Does anybody have any ideas?

205
00:12:45,625 --> 00:12:48,400
是的,基本上说对了,
Yeah, that's basically it,

206
00:12:48,400 --> 00:12:53,750
我们不希望这个哈希函数的输出产生冲突.
 that we don't want to have kind of conflicts in the output from this hash function. 

207
00:12:53,750 --> 00:12:56,016
就像每个提交都由一个哈希值标识,
Like every commit is identified by a hash function, 

208
00:12:56,016 --> 00:12:58,700
每个文件也该由该文件的哈希值标识.
every file is identified by the hash of that file. 

209
00:12:58,700 --> 00:13:03,858
如果有两个不同的内容产生了相同的输出,
If it were ever the case that two different pieces of content in practice produce the same output, 

210
00:13:03,858 --> 00:13:06,804
也就是说,该函数不具有抗碰撞性,
that is,  if the function were not collision-resistant,

211
00:13:06,804 --> 00:13:08,525
那么这可能会造成很大问题. 
 that could be really problematic, right? 

212
00:13:08,525 --> 00:13:12,925
因为你和我可能会尝试获取我们认为是相同的仓库,
Because then you and I, we could have to do to get repos that we think are the same,

213
00:13:12,925 --> 00:13:14,825
我们检出相同的提交哈希,
we check out the same commit hash, 

214
00:13:14,825 --> 00:13:17,250
但是最终我们却可能会得到不同的文件.
and we might end up with different files. 

215
00:13:17,350 --> 00:13:22,950
这绝对达咩,因为Git用于跟踪软件的开发,
And this is concerning because Git is used to track software, a track development of software, 

216
00:13:22,950 --> 00:13:28,625
同时它也要保证正确的人员在写代码,
and it's also kind of involved in making sure that the right people are authoring the software,

217
00:13:28,625 --> 00:13:29,925
过程中不能发生什么不妥之事.
nothing funny has happened in the process. 

218
00:13:29,925 --> 00:13:31,817
例如,有许多开源项目,
For example, there are all these open-source projects 

219
00:13:31,817 --> 00:13:35,050
如Linux内核,就使用Git进行进行跟踪.
like the Linux kernel where development is done using Git. 

220
00:13:35,075 --> 00:13:38,225
如果某个Git贡献者能够编辑某些文件
It would be really bad if some contributor to Git could say edit some file

221
00:13:38,225 --> 00:13:42,532
并提出一些看起来相当不错的优化请求,
and propose some change that looks pretty benign like, 

222
00:13:42,532 --> 00:13:44,346
比如"让我改进一下Linux的这个部分",
"Oh, let me go and improve this part of Linux",

223
00:13:44,346 --> 00:13:46,875
提交该申请给Linux开发人员,
 submit that change request to the Linux developers, 

224
00:13:46,875 --> 00:13:52,975
然后实际提供了一个具有相同提交哈希的Git仓库,
and then in practice actually supply a Git repository that has the same commit hash and whatnot, 

225
00:13:52,975 --> 00:13:55,375
但文件内容不同.
but actually the file contents are different. 

226
00:13:55,375 --> 00:13:56,300
这种情况非常糟糕.
There's something malicious. 

227
00:13:56,300 --> 00:14:01,790
因此,Git就需要依赖于这个SHA-1函数作为加密哈希函数,
So Git actually relies on this SHA-1 function being a cryptographic hash function

228
00:14:01,790 --> 00:14:04,675
以保证安全性.
in order to achieve security. 

229
00:14:05,275 --> 00:14:12,725
关于哈希函数的应用还有什么问题吗?
Any questions about that and some other interesting applications of hash functions?

230
00:14:12,725 --> 00:14:13,725
所以,就像我们看到的,
So, as we saw,

231
00:14:13,725 --> 00:14:16,150
哈希函数可以将很长的输入压缩为很短的输出,
 hash functions turn big inputs into small outputs, 

232
00:14:16,150 --> 00:14:19,325
而且由于哈希函数是抗碰撞的,
and in a way, because the hash function is collision-resistant, 

233
00:14:19,325 --> 00:14:23,075
输出可以用来验证或标识输入.
the output can be used to kind of attest to or identify the input. 

234
00:14:23,075 --> 00:14:28,025
因此,你可以将哈希看作文件的简短摘要.
And so you can think of a hash as a short summary of a file. 

235
00:14:28,200 --> 00:14:30,900
例如,在此目录中的一堆文件中,
For example, in this directory of a bunch of files,

236
00:14:30,900 --> 00:14:34,950
我可以计算该目录下的一些文件的 "sha1sum".
I can compute the "sha1sum" of some file in this directory. 

237
00:14:35,100 --> 00:14:39,875
这是"README.md"的SHA-1哈希值.
And this is the SHA-1 algorithm applied to this "README.md" file. 

238
00:14:39,925 --> 00:14:44,043
有趣的是,要想计算出另一个具有相同哈希输出的文件
And what's interesting is that it is computationally hard or like impossible,

239
00:14:44,043 --> 00:14:47,350
是相当困难的,
you can kind of think of it as impossible, to find any other file, 

240
00:14:47,350 --> 00:14:50,850
你甚至可以认为这是不可能的.
so a different file that has the same hash output. 

241
00:14:50,850 --> 00:14:56,125
这个对于验证在从互联网下载的文件非常有用.
And one scenario in which this is useful is when you download files from the internet. 

242
00:14:56,200 --> 00:14:59,867
例如,有许多Linux发行版
For example, there are lots of Linux distributions

243
00:14:59,867 --> 00:15:03,375
会在其网站发布大型CD或DVD映像文件.
 that distribute large CD or DVD images from their website. 

244
00:15:03,375 --> 00:15:06,750
像我可以到Debian.org上下载最新版本的Debian.
Like, I can go to Debian.org and download the latest version of Debian. 

245
00:15:07,000 --> 00:15:10,100
问题是,在网站上托管这些文件非常昂贵.
The thing is that hosting those files can be expensive. 

246
00:15:10,100 --> 00:15:13,075
因此,许多好心人会提供这些文件的镜像.
And so a lot of people are nice enough to host mirrors of these files. 

247
00:15:13,125 --> 00:15:15,675
所以,我可以去许多其他镜像站点去下载Debian,
So instead of downloading Debian from Debian.org, 

248
00:15:15,675 --> 00:15:18,550
不用从Debian.org下载Debian,
I can go to one of many other sites 

249
00:15:18,550 --> 00:15:22,900
镜像站上的Debian和在Debian.org托管的应该是相同的文件.
and download what are supposed to be the same files that are hosted at Debian.org. 

250
00:15:22,900 --> 00:15:25,750
但是,我怎么知道我有没有得到正确的文件?
But how do I know that I actually got the correct file?  

251
00:15:25,750 --> 00:15:28,995
比如,如果有一个恶意镜像,
Like, what if I set up a malicious mirror

252
00:15:28,995 --> 00:15:31,975
比如你去了类似"AnishaIsEvilDebian.com"
 and you go to like "AnishaIsEvilDebian.com"

253
00:15:31,975 --> 00:15:33,626
然后尝试在上面下载Debian,
and then try to download Debian,  

254
00:15:33,626 --> 00:15:36,575
那么结果可能是你的Linux安装程序被植入了{\rcode2}后门[*]{\r}.
turns out that your Linux installation is backdoored.  
*[后门是一种恶意程序，通常被恶意攻击者嵌入到软件或系统中，以便于随时掌控被攻击对象。\N 这些程序可以将攻击者拖入受害者的计算机系统，使他们在未经授权的情况下访问被攻击对象，\N 并执行各种危害性行为，比如窃取敏感信息、破坏数据等.]

255
00:15:36,575 --> 00:15:40,650
一种解决方案就是就是从官网下载一份副本,
Well, one thing you could do is download a copy from the original Debian website 

256
00:15:40,650 --> 00:15:42,450
然后和你从镜像站下载的版本进行比较.
and then download my version and compare them. 

257
00:15:42,450 --> 00:15:44,000
但这有点违背了初衷,对吧?
But that kind of defeats the purpose, right? 

258
00:15:44,000 --> 00:15:46,225
我们不想从Debian.org下载文件,
Because we want to avoid downloading things from Debian org

259
00:15:46,225 --> 00:15:47,850
因为托管这些文件很昂贵,
 because hosting these files is expensive, 

260
00:15:47,850 --> 00:15:51,650
我们希望让人们能够使用在其他地方的镜像.
and we want all these different people to be able to mirror copies of the files elsewhere. 

261
00:15:51,700 --> 00:15:57,175
那么,有没有人察觉到加密哈希函数可以用来解决这个问题.
So, does anybody see how cryptographic hash functions could be useful to solve this problem? 

262
00:15:57,175 --> 00:16:00,300
我想从一个不信任的源下载文件,
That I want to download a file from an untrusted source

263
00:16:00,300 --> 00:16:03,850
不是从可信源本身下载文件.
but and not from like the trusted source itself.

264
00:16:03,850 --> 00:16:06,975
但我也许可以从这个可信源获取一些简短的信息,
But maybe I can get some small piece of information from this trusted source, 

265
00:16:06,975 --> 00:16:12,400
以便验证我从不信任的源下载的文件.
in order to know whether the file I downloaded from \N the untrusted source is the thing I was supposed to get. 

266
00:16:16,450 --> 00:16:20,650
是的,它就是一个加密哈希函数的简单应用.
Yes, like it's basically just a straightforward application of cryptographic hash functions. 

267
00:16:20,650 --> 00:16:26,775
Debian可以生成正确的ISO文件或其他文件,
So what Debian.org can do is they can produce their kind of correct ISO file or whatever they want, 

268
00:16:26,775 --> 00:16:30,257
并且不用在他们的网站上发布文件本身,
and instead of publishing the file itself on their website, 

269
00:16:30,257 --> 00:16:33,250
而是发布该文件的哈希值.
they can publish a hash of that file. 

270
00:16:33,250 --> 00:16:36,575
与文件本身相比,
So, compared to the file itself which may be many gigabytes,

271
00:16:36,575 --> 00:16:39,875
这个哈希值可能只有160位数据,相对于发布源文件,
this is only like in this particular case 160 bits of data, right?

272
00:16:39,875 --> 00:16:41,425
发布哈希值非常便宜.
 So very cheap to host. 

273
00:16:41,425 --> 00:16:44,425
然后,作为用户,我可以随便从什么网站下载该文件,
And then what I can do as a user is I can download 

274
00:16:44,425 --> 00:16:48,225
可能是一个不受信任的网站,
that file from any random website, it could be an untrusted website, 

275
00:16:48,225 --> 00:16:51,600
下载完成后,我只需双重检查sha-1哈希值.
and after I download, I just double-check the sha-1 hash. 

276
00:16:51,600 --> 00:16:56,175
如果哈希匹配,则我知道我有正确的文件,
And if the hash matches, then I know that I have the right file 

277
00:16:56,175 --> 00:16:58,529
因为如果有一些不同的文件,
because it's computationally infeasible for somebody 

278
00:16:58,529 --> 00:17:02,175
而这些文件恰好具有相同的哈希值,这基本上是不可能的,
to give me some different file that happens to have the same hash, 

279
00:17:02,175 --> 00:17:04,975
因为哈希函数是抗碰撞的.
because hash functions are collision-resistant. 

280
00:17:06,000 --> 00:17:07,850
对此应用有任何问题吗?
So any questions about that application?  

281
00:17:07,850 --> 00:17:08,525
是的,
Yeah,

282
00:17:18,250 --> 00:17:20,272
这是一个很好的问题,
 so that's a good question, 

283
00:17:20,272 --> 00:17:23,000
问题是,为什么需要不同的人来托管信息?
like why do you need different people to host the information? 

284
00:17:23,000 --> 00:17:25,225
难道对于每个人来说托管的成本是不一样的吗?
Like wouldn't it be equally expensive for everybody?

285
00:17:25,225 --> 00:17:27,700
这个问题的答案有点复杂,
So the answer to that question is a little bit complicated, 

286
00:17:27,700 --> 00:17:29,925
但我会解释一部分.
but like here's a partial answer. 

287
00:17:29,925 --> 00:17:34,865
一件事是从服务器下载文件会受到服务器距离的限制.
One thing is that downloading files from a server is affected by how far away the server is from you. 

288
00:17:34,865 --> 00:17:38,975
举个例子,如果服务器在马萨诸塞州,而你在中国,
So for example, if the server is in Massachusetts and you're in say China, 

289
00:17:38,975 --> 00:17:41,975
你必须通过互联网进行大量数据的往返,
you have to kind of make a big round trip across the internet, 

290
00:17:41,975 --> 00:17:44,200
有许多原因,会让这个操作变得昂贵,
and that may be expensive for a number of reasons. 

291
00:17:44,200 --> 00:17:47,442
比如延迟高,
Like the latency is high and the traffic needs to go through kind of 

292
00:17:47,442 --> 00:17:49,975
流量需要通过许多不同的线才能到达你所在的位置.
lots of different wires to make its way all the way to where you are. 

293
00:17:49,975 --> 00:17:52,337
因此,这些网站所做的
And so one thing that these websites do

294
00:17:52,337 --> 00:17:55,225
就是将他们的文件分发到世界各地的服务器上,
 is that they distribute their content to servers that are all over the world, 

295
00:17:55,225 --> 00:17:58,025
然后作为用户,你从离你最近的服务器下载.
and then as a user, you download from the server that's closest to you. 

296
00:17:58,025 --> 00:18:01,425
比如,MIT维护一个Debian软件包仓库,
Like for example, MIT maintains a Debian package repository 

297
00:18:01,425 --> 00:18:03,375
里面涵盖所有的Debian软件的镜像.
and kind of mirrors all the Debian stuff. 

298
00:18:03,375 --> 00:18:06,097
因此,如果你是MIT的Debian用户,
So if you're a Debian user at MIT, 

299
00:18:06,097 --> 00:18:09,150
你可以使用MIT提供的镜像文件,
you can use the MIT copy of everything, 

300
00:18:09,150 --> 00:18:12,175
然后通过我们的本地网络快速访问资源,
and then you can kind of access it over our fast local network, 

301
00:18:12,175 --> 00:18:15,225
这样流量根本不需要通过外部互联网,
and that traffic never needs to go to the outside Internet at all, 

302
00:18:15,225 --> 00:18:16,450
所以速度非常快.
so it's very fast. 

303
00:18:16,450 --> 00:18:18,200
这是个好问题.
That's a good question. 

304
00:18:18,200 --> 00:18:21,650
还有其他问题吗?
Any other questions?

305
00:18:21,650 --> 00:18:24,575
好的,还有一个有趣的应用是
Okay, and then one final kind of interesting application of hash functions

306
00:18:24,575 --> 00:18:26,500
哈希函数的承诺机制.
is something called a commitment scheme. 

307
00:18:26,500 --> 00:18:29,100
我想玩一个游戏,
So I want to play a game, 

308
00:18:29,100 --> 00:18:30,300
我需要一个志愿者.
and I need a volunteer for this. 

309
00:18:30,300 --> 00:18:33,610
你不需要从座位上站起来,只需要你跟我交流一下.
So you don't actually need to get up from your seat or anything, I just need you to talk with me. 

310
00:18:33,610 --> 00:18:35,226
有人自愿参与吗?
So any volunteers raise your hand? 

311
00:18:35,226 --> 00:18:39,800
好的,你叫什么名字?Abdul Aziz?好的,太好了.
Yeah, okay, what's your name? Abdul Aziz? Okay, great. 

312
00:18:39,800 --> 00:18:44,808
所以,Abdul Aziz,我们要玩一个游戏,我要掷一枚硬币,
So Abdul Aziz, we're going to play a game where I'm going to flip a coin

313
00:18:44,808 --> 00:18:46,450
然后你要猜正面或反面,
and then you're gonna call heads or tails, 

314
00:18:46,475 --> 00:18:48,325
如果你猜对了,你就赢了,
and if you call it right, you win, 

315
00:18:48,325 --> 00:18:49,875
如果你猜错了,你就输了.
and if you call it wrong, you lose. 

316
00:18:49,875 --> 00:18:52,400
这个游戏没有任何利益关系,
And there are no stakes for this game, 

317
00:18:52,400 --> 00:18:53,950
就是为了成就感.
but just the pride of winning. 

318
00:18:55,450 --> 00:18:59,275
但是不幸的是,我看了一下我的钱包,只有美元,没有硬币.
Sadly, I checked my wallet and all I have is dollar bills, I don't have any coins with me. 

319
00:18:59,275 --> 00:19:01,575
所以,我只能在脑海中掷硬币.
So instead, I'm just going to flip the coin in my head. 

320
00:19:01,575 --> 00:19:02,425
好的,
Alright, 

321
00:19:02,425 --> 00:19:05,650
我掷硬币了,请你叫正面或反面.
so okay, I flip the coin, call heads or tails. 

322
00:19:05,650 --> 00:19:07,775
很抱歉,你输了,是正面.
Sorry, you lost, it was heads. 

323
00:19:07,775 --> 00:19:09,775
还想再来一局吗?
Do you wanna play again?

324
00:19:11,000 --> 00:19:14,025
我可以作弊,对吧?
I can cheat, right?

325
00:19:14,025 --> 00:19:16,425
我可以先听到你说的,然后我说相反的结果.
 I can just see what you say and say the opposite thing. 

326
00:19:16,425 --> 00:19:18,150
所以让我们试着让这个游戏变得公平一些.
So let's try fixing this game. 

327
00:19:18,150 --> 00:19:25,475
就是如果我提前告诉你翻转结果是正面还是反面,你再猜.
How about you call heads or tails after I say what the flip result was? 

328
00:19:25,475 --> 00:19:27,055
好的,如果我说"结果是反面",
Okay, yeah, so if I say, "Oh, the result is tails," 

329
00:19:27,055 --> 00:19:32,800
你会怎么猜?你会选反面?是的.
What are you gonna say? Are you gonna call tails? Yeah. 

330
00:19:33,325 --> 00:19:36,950
那么,我们怎么可以
So, is it possible to play this 

331
00:19:36,950 --> 00:19:43,675
在没有硬币的情况下公平地玩这个"猜硬币"的游戏呢?
"Guess what the coin flip result is" game in a fair way without having a physical coin that we share? 

332
00:19:43,675 --> 00:19:46,000
因为我现在没有硬币.
Like, because I can't really manipulate your physical reality. 

333
00:19:46,000 --> 00:19:48,800
如果我在你面前抛硬币,你会相信它是公平的,对吧?
If I flip a coin in front of you, you probably trust that it's okay, right? 

334
00:19:48,800 --> 00:19:50,750
所以,人们发现了一种利用哈希函数的方法,
So, it turns out that hash functions 

335
00:19:50,750 --> 00:19:53,050
为我们提供了一种解决这个问题的很酷的方案,
give us a kind of cool way to solve this problem 

336
00:19:53,050 --> 00:19:55,725
也就是所谓的承诺方案的思想,
through an idea called a commitment scheme. 

337
00:19:55,800 --> 00:20:00,575
因此,这是解决问题的一种方案.
So, I can say, "Here's the construction of the solution. 

338
00:20:00,600 --> 00:20:02,825
我可以选择正面或反面,
I can pick heads or tails, 

339
00:20:02,825 --> 00:20:06,250
实际上我要选择一个大的随机数,
and I'm actually going to pick a big random number, 

340
00:20:06,250 --> 00:20:09,400
比如这个数,
say like this number here, 

341
00:20:09,400 --> 00:20:15,750
我能做的是计算这个数字的 sha1sum.
and what I can do is compute the sha1sum of this number. 

342
00:20:15,750 --> 00:20:17,910
在这个时刻,你还没有看到这个数,
At this moment, you haven't seen this number yet,

343
00:20:17,910 --> 00:20:19,300
我只是在脑海中做所有这些.
 I'm just doing all this in my head. 

344
00:20:19,300 --> 00:20:23,175
然后,我告诉你:"好的,我抛了硬币,
And then what I do is I tell you, "Okay, I flipped a coin, 

345
00:20:23,175 --> 00:20:27,775
我现在不会告诉你结果,因为你还没有猜正面或反面,
and I'm not going to tell you what the result is just yet because you haven't called heads or tails, 

346
00:20:27,775 --> 00:20:30,125
但我会告诉你结果的sha1sum.
but I'll tell you what the sha1sum of the result is. 

347
00:20:30,125 --> 00:20:32,075
就是这个值.
Here you go,and I tell you this value. 

348
00:20:32,075 --> 00:20:34,450
现在,你可以猜正面或反面了.
Now, after this, you can call heads or tails. 

349
00:20:34,450 --> 00:20:37,600
所以,你选什么?选正面.
So, what do you say? Like, say heads afterwards. 

350
00:20:37,600 --> 00:20:41,000
那么,我现在告诉你我的输入,
What I can do is I can reveal to you what my input to this function was, 

351
00:20:41,000 --> 00:20:42,886
然后你可以进行验证,
and then you can cross-check this, right? 

352
00:20:42,886 --> 00:20:47,725
对输入进行sha1sum以验证输出是否与我之前给你的一样,
You can compute the sha1sum on the input to verify that the output is what I said it was earlier, 

353
00:20:47,725 --> 00:20:50,850
我们需要将这些数字对应到正面或反面.
and then we can have some way of mapping these numbers to heads or tails. 

354
00:20:50,850 --> 00:20:55,550
比如说我们事先协商同意偶数为正面,奇数为反面,
So, I might have agreed upon beforehand that even numbers are heads and odd numbers are tails, 

355
00:20:55,550 --> 00:20:57,600
这是一种让游戏变公平的方法.
and so this is a way of fixing that game. 

356
00:20:57,600 --> 00:20:59,850
所以,现在我们可以在我们的脑海中玩这个游戏了.
So, we can actually play this game in our heads. 

357
00:21:00,450 --> 00:21:02,600
我可以选择一个值,
I can pick a value, 

358
00:21:02,600 --> 00:21:04,200
我不会告诉你这个值是什么,
but not reveal that value to you, 

359
00:21:04,200 --> 00:21:05,825
但我可以承诺该值.
but I can commit to the value. 

360
00:21:05,825 --> 00:21:07,656
因此,这是一种承诺机制,
So, this is a kind of binding commitment scheme 

361
00:21:07,656 --> 00:21:10,375
我在告诉你之后无法改变主意,
that I can't change my mind after I've told you this, 

362
00:21:10,375 --> 00:21:12,825
但不会向你透露原始值.
but it doesn't reveal the original value to you. 

363
00:21:13,325 --> 00:21:16,775
因此,这是加密哈希函数的另一个不错的应用.
And so, this is one other neat application of cryptographic hash functions. 

364
00:21:16,925 --> 00:21:20,750
对于承诺机制有什么问题吗?
Any questions about this particular construction?

365
00:21:20,750 --> 00:21:23,075
好的.
 Okay, great. 

366
00:21:23,100 --> 00:21:28,775
接下来,我们将讨论密钥生成函数,
So, moving on to the next topic, we're going to talk about key derivation functions. 

367
00:21:38,950 --> 00:21:41,775
通常缩写为KDF.
Often abbreviated as KDFs. 

368
00:21:44,050 --> 00:21:48,024
这是一个与哈希函数非常相似的概念,
So, this is a concept that's very similar to hash functions,

369
00:21:48,024 --> 00:21:52,700
但是它还有一个额外的特性,即计算速度较慢.
except it has kind of one extra property that it is slow to compute. 

370
00:21:52,775 --> 00:22:07,690
举个例子,有一个叫PBKDF2的哈希函数
For example, there's a hash function or key derivation function known as PBKDF2, 

371
00:22:07,690 --> 00:22:09,803
或者说密钥生成函数,
password-based key derivation function, 

372
00:22:09,803 --> 00:22:15,045
它具有我们先前所说的这些哈希函数类似的性质,
that has a kind of similar form as these hash functions we were talking about here,

373
00:22:15,045 --> 00:22:18,053
它们接受可变长度的输入并生成固定长度的输出.
that they take in some variable length input and produce a fixed length output. 

374
00:22:18,150 --> 00:22:20,425
但它们通常被用于一特定目的.
But they're meant to be used for one particular purpose. 

375
00:22:20,425 --> 00:22:23,325
这个目的通常是将固定长度的输出
The purpose is generally to use the fixed length output 

376
00:22:23,325 --> 00:22:26,000
作为另一个加密算法中的密钥.
as a key in another cryptographic algorithm. 

377
00:22:26,000 --> 00:22:30,625
我们稍后将讨论这些算法,比如这个函数的用途.
And we'll talk about those algorithms, like what use the output of this thing for in a moment. 

378
00:22:30,625 --> 00:22:34,525
但这些函数的一个特性就是它们很慢.
But one property of these things is that they're slow. 

379
00:22:34,525 --> 00:22:39,613
有没有人知道为什么要让算法变慢?
Does anybody have any idea why you'd want an algorithm to be slow? 

380
00:22:39,613 --> 00:22:41,800
通常我们希望算法很快,对吧?
Like, normally we want algorithms to be fast, right? 

381
00:22:41,800 --> 00:22:43,725
那么为什么我们希望算法很慢呢?
So why would we want an algorithm to be slow? 

382
00:22:43,725 --> 00:22:44,375
请说
Yes, 

383
00:22:54,975 --> 00:22:56,525
没错,就是这个原因.
yeah, that's exactly it. 

384
00:22:56,525 --> 00:22:59,125
我重复一遍.
So, I'll repeat so it goes into the microphone.

385
00:22:59,125 --> 00:23:01,493
希望它变慢的原因是
The reason you want these to be slow is 

386
00:23:01,493 --> 00:23:05,175
在实际使用它进行密码认证时.
when you're actually using it for something like password authentication. 

387
00:23:05,175 --> 00:23:07,435
你保存了密码的哈希值,
Where you have the hash of a password saved

388
00:23:07,435 --> 00:23:10,493
然后有人输入密码,你想知道它是否与哈希值相对应.
and then somebody inputs the password, you want to know if that corresponds to the hash. 

389
00:23:10,493 --> 00:23:13,925
它慢一些也没关系,因为你只需要做一次这个检查.
It's okay if it's slow because you're only doing this check kind of once. 

390
00:23:13,925 --> 00:23:16,625
但是这个函数需要慢的真正的原因是,
But the other scenario in which you're going to be using this function 

391
00:23:16,625 --> 00:23:19,075
当有人试图暴力破解密码时.
is when somebody's trying to brute-force a password. 

392
00:23:19,100 --> 00:23:21,873
比如一个网站的密码数据库被盗,
Say a website has their password database stolen 

393
00:23:21,873 --> 00:23:24,750
有人在尝试破解所有密码.
and somebody's going through all the accounts, trying to break all the passwords. 

394
00:23:24,750 --> 00:23:27,725
那么在这种情况下,你就需要这个函数变慢,
Well, in that case, you want this to be slow

395
00:23:27,725 --> 00:23:30,000
因为有人将要做这个操作数百万次.
because someone's gonna be doing this like millions and millions of times. 

396
00:23:30,000 --> 00:23:32,725
通过使这个函数变慢,可以大大减缓攻击者的破解速度.
And you can slow down the attacker a lot by making this function slow. 

397
00:23:32,725 --> 00:23:34,354
所以,如果这需要
And so it's fine if this takes you like

398
00:23:34,354 --> 00:23:36,825
一秒钟才能计算出这个函数,这不影响密码的验证.
 one second upon logging in to compute this function. 

399
00:23:36,825 --> 00:23:38,210
但当有人进行暴力破解时,
But when you're brute-forcing it,

400
00:23:38,210 --> 00:23:41,525
他们无法像那个xkcd漫画中一样每秒尝试一千次.
we don't go to a thousand guesses a second like in that xkcd comic. 

401
00:23:41,525 --> 00:23:42,525
我们可以让它慢一点.
We can slow it down a little bit. 

402
00:23:44,625 --> 00:23:48,400
那么密钥生成函数的输出实际上用于什么呢?
So what is the output of key derivation functions actually used for? 

403
00:23:48,400 --> 00:23:50,882
这就是我们接下来要讨论的,
Well, the next topic we're going to talk about,

404
00:23:50,882 --> 00:23:54,200
可能是一提到密码学你就会想到的东西,
probably like one of the most classic things when you think about cryptography,

405
00:23:54,200 --> 00:23:56,300
就是加密和解密.
is encryption and decryption. 

406
00:23:58,300 --> 00:24:01,525
我们先讲是对称加密.
The next topic is symmetric key cryptography. 

407
00:24:14,400 --> 00:24:17,874
就像先前讲哈希函数一样,
And like the rest of this lecture,

408
00:24:17,874 --> 00:24:19,875
我们不会讨论实现它们的具体细节,
 we're not going to talk about how you implement these. 

409
00:24:19,875 --> 00:24:24,950
而是仅仅讨论对称加密的API,即它们该如何使用.
We're going to talk about the API for a symmetric key, symmetric key crypto, like how it's used. 

410
00:24:24,950 --> 00:24:29,275
对称加密系统有几个不同的函数.
So symmetric key crypto systems have a couple different functions. 

411
00:24:29,975 --> 00:24:32,275
它们有一个密钥生成函数,
They have a key generation function,

412
00:24:32,275 --> 00:24:37,800
这是一个随机生成函数,生成所谓的密钥.
which is a randomized function that produces a thing we call the key. 

413
00:24:37,850 --> 00:24:41,550
有另外一对函数,进行加密和解密.
And then they have a pair of functions, encrypt and decrypt. 

414
00:24:46,175 --> 00:24:52,375
加密需要将明文作为输入,
And encrypt take as input something we refer to as the plaintext, 

415
00:24:52,375 --> 00:24:54,900
明文可以是一些字节序列,一些数据.
and this is just some sequence of bytes,  some data.  

416
00:24:54,900 --> 00:24:56,925
它需要输入一个密钥,
And it takes in a key, 

417
00:24:56,925 --> 00:24:59,950
密钥就是来自这个密钥生成函数,
so something that came as an output of this key generation function, 

418
00:24:59,950 --> 00:25:06,275
然后产生所谓的密文.
and produces what we call the ciphertext. 

419
00:25:06,275 --> 00:25:08,450
然后解密函数则是相反的过程.
And then decrypt does the opposite of this. 

420
00:25:08,450 --> 00:25:17,325
输入密文和密钥,输出明文.
So it takes the ciphertext along with the key and produces the plaintext. 

421
00:25:21,375 --> 00:25:26,150
这个三个函数有几个属性.
And this triple of functions has a couple properties. 

422
00:25:26,150 --> 00:25:30,619
其中之一,如我们所料,
One is that, like one you might expect, is that 

423
00:25:30,619 --> 00:25:35,950
单单从密文无法得知明文.
this thing doesn't really tell you all that much about this input to the encryption. 

424
00:25:35,950 --> 00:25:45,467
所以第一个性质是,
So property number one is given the ciphertext, 

425
00:25:45,467 --> 00:25:56,800
只有在拥有密钥的情况下,你才能通过密文找出明文.
you can't figure out the plaintext without the key. 

426
00:26:00,825 --> 00:26:04,575
另一个是一个非常显然的属性,
And the other property is kind of the obvious correctness property, 

427
00:26:04,575 --> 00:26:13,325
即如果你使用密钥k加密
that if you take something and you encrypt it, 

428
00:26:13,825 --> 00:26:16,075
一个信息m,
some message m with a key k, 

429
00:26:16,075 --> 00:26:20,075
然后使用相同的密钥(即k)解密该密文,
and then you decrypt that ciphertext using the same key, 

430
00:26:20,075 --> 00:26:23,175
那么你将得到相同的消息(即m).
that gives you back the same message. 

431
00:26:25,000 --> 00:26:28,075
这是显而易见的.
This is the kind of obvious correctness property. 

432
00:26:28,950 --> 00:26:30,775
我讲明白了吗?
So, does this description make sense? 

433
00:26:30,775 --> 00:26:33,175
现在你们能不能
Does it fit your kind of intuitive understanding of

434
00:26:33,175 --> 00:26:35,650
更直观地理解密钥生成函数?
 taking some piece of data and obscuring it?

435
00:26:35,650 --> 00:26:38,300
我们通常将某些数据加密来隐藏原始输入,
So you can't really tell anything about the original input, 

436
00:26:38,300 --> 00:26:41,333
这样别人就无法知道原始输入,
but then taking that obscured result,

437
00:26:41,333 --> 00:26:47,450
然后我们自己使用密钥进行解密就可以获取原始数据.
and then passing it through some decryption function given that key to retrieve the original input?

438
00:26:48,900 --> 00:26:53,775
这个描述并不能完全阐明"安全"这一概念,
And this isn't really a rigorous definition of what it means for something to be secure, 

439
00:26:53,775 --> 00:26:58,000
但它足够直观,我们可以使用它来帮我们理解.
but it's a good enough intuitive definition that we can work with it. 

440
00:26:59,300 --> 00:27:04,275
那么,关于这个描述有没有问题?
So any questions about that description there?

441
00:27:05,775 --> 00:27:09,003
那么对称加密有什么应用呢?
So where can symmetric key cryptography be useful?

442
00:27:09,003 --> 00:27:11,175
这节课后面我们会讲解许多例子,
We'll talk about a whole bunch of examples later in this lecture, 

443
00:27:11,175 --> 00:27:13,059
但现在我就先举一个例子,
but one example we'll talk about right now 

444
00:27:13,059 --> 00:27:17,025
即将文件加密,然后把它存在一个不受信任的云服务中.
is encrypting files for storage in an untrusted cloud service. 

445
00:27:17,050 --> 00:27:22,847
比如说像Dropbox或Google Drive这样的服务,
So consider something like Dropbox or Google Drive,or things like that 

446
00:27:22,847 --> 00:27:24,888
你上传文件到这些云服务器上面,
where you're uploading files there 

447
00:27:24,888 --> 00:27:29,150
信任它们不会偷窥你的文件或者对其进行什么恶意操作.
and trusting the service to not look at your files or do anything malicious with them. 

448
00:27:29,725 --> 00:27:32,520
这些云服务商,至少在我刚刚提到的那几个,
These services, at least the ones I named,

449
00:27:32,520 --> 00:27:34,925
并没有在上传的时候进行加密等操作.
 are not encrypted or anything like that. 

450
00:27:34,925 --> 00:27:38,450
所以理论上,这些公司的任何员工都可以查看你的文件.
In theory, any employee of those companies could look at your files. 

451
00:27:38,450 --> 00:27:41,837
当然,这些公司有许多政策和技术控制
Now, of course, these companies have lots of policies and technical controls in place

452
00:27:41,837 --> 00:27:43,975
来确保这种情况不会发生,
for making sure that that sort of thing doesn't happen, 

453
00:27:43,975 --> 00:27:47,125
但这并不意味着偷窥在技术上不可实现.
but that doesn't mean that it's not technically possible. 

454
00:27:47,150 --> 00:27:49,399
如果你不信任这些云服务,
So one thing you might want to do if you don't want to 

455
00:27:49,399 --> 00:27:51,925
不想让他们偷窥你的数据,
trust these cloud services to not peek at your data, 

456
00:27:51,925 --> 00:27:53,655
比如拿你的数据进行机器学习,
not do like machine learning over them, 

457
00:27:53,655 --> 00:27:55,895
或者进行其他你不想要的操作等等.
or do other sorts of things that you wouldn't really want, 

458
00:27:55,895 --> 00:27:57,815
那么你可以在上传这些文件到云服务器之前
is you can just take your files 

459
00:27:57,815 --> 00:28:02,505
对其进行加密.
and encrypt them before uploading them to these web services. 

460
00:28:02,600 --> 00:28:05,700
这样是不是就提高了安全性?我可以将我的文件
So does that idea make sense? That I can take my file, 

461
00:28:05,700 --> 00:28:09,722
比如照片之类的,通过一个加密函数,产生密文,
like center pictures or whatever, pass it through an encryption function and produce the ciphertext, 

462
00:28:09,722 --> 00:28:11,927
然后加密后的文件就可以
and then place that ciphertext on the web service safe 

463
00:28:11,927 --> 00:28:13,675
安全地上传到云服务器上进行备份等操作,
for backup purposes or whatever, 

464
00:28:13,675 --> 00:28:14,582
如果我需要该文件,
and if I ever need that, 

465
00:28:14,582 --> 00:28:19,000
我可以检索该密文的密钥,然后将其解密回明文,
I can retrieve the ciphertext, then use my key to decrypt it back into the plaintext, 

466
00:28:19,000 --> 00:28:21,625
这样就得到了原始文件.
and then use the result for doing whatever I need to do. 

467
00:28:21,625 --> 00:28:23,125
你们有什么问题吗?
Does that make sense?

468
00:28:27,425 --> 00:28:28,170
是的,
Yeah, 

469
00:28:28,170 --> 00:28:29,500
这是一个好问题.
that's a good question. 

470
00:28:29,500 --> 00:28:33,125
问题是,是不是所有人都通过相同的加密程序进行加密?
The question is, couldn't anybody else run it through the same encryption program? 

471
00:28:33,125 --> 00:28:37,075
或许我应该更详细地解释一下,
One detail maybe I should have explained in a little bit more detail is 

472
00:28:37,075 --> 00:28:41,250
这个密钥生成函数生成的密钥是随机的,
this key generation function is randomized, 

473
00:28:44,500 --> 00:28:47,225
并且这个密钥具有高熵值.
and this key has high entropy. 

474
00:28:47,225 --> 00:28:49,250
回到我们之前讨论的主题,
So going back to that topic we talked about earlier, 

475
00:28:49,250 --> 00:28:53,525
比如我们可能还会使用AES-256加密.
like an example is we might have AES-256. 

476
00:28:54,650 --> 00:28:57,600
这是一种对称加密,
This is one particular symmetric cipher, 

477
00:28:57,600 --> 00:29:02,750
你们可能可以从它的名称猜到它的密钥具有256位熵.
and this, as the name might indicate, has 256 bits of entropy in the key. 

478
00:29:02,750 --> 00:29:05,302
这意味着只要攻击者(即从网络服务下载密文的人)
And so that means that as long as the attacker, 

479
00:29:05,302 --> 00:29:09,206
不知道你的密钥,
whoever downloads the ciphertext from the web service, doesn't know your key, 

480
00:29:09,206 --> 00:29:11,266
除非他们的攻击手段很牛杯,
unless they have some better attack in place, 

481
00:29:11,266 --> 00:29:13,875
否则他们只能暴力尝试所有可能的密钥.
they'll have to try all the different possible keys. 

482
00:29:13,875 --> 00:29:15,746
如果可能的密钥有2^256个,
And if there are 2 to the 256 keys, 

483
00:29:15,746 --> 00:29:18,650
那么在一定的时间内尝试所有密钥是不可能的.
that's too many keys to try in a reasonable amount of time. 

484
00:29:18,650 --> 00:29:20,500
这回答了你的问题吗?
Does that answer the question?

485
00:29:20,500 --> 00:29:22,675
好的,还有其他问题吗?
Okay, any other questions?

486
00:29:35,525 --> 00:29:37,025
这是一个很好的问题,
That's an excellent question, 

487
00:29:37,025 --> 00:29:39,425
也引出了我接下来要谈论的话题.
and that leads into what I was going to talk about next. 

488
00:29:39,425 --> 00:29:40,225
所以感谢你的提问.
So thanks for that question. 

489
00:29:40,225 --> 00:29:45,000
正如你所指出的,如果我丢了我的密钥,就寄了,对吧?
As you point out, like if I lose my key, I'm kind of stuck, right? 

490
00:29:45,000 --> 00:29:45,960
我需要我的密钥来解密.
I need my key to decrypt. 

491
00:29:45,960 --> 00:29:47,275
密钥就是这个加密系统的重点.
That's kind of the point of this thing. 

492
00:29:47,275 --> 00:29:49,086
如果我不需要密钥来解密,
If I didn't need my key to decrypt, 

493
00:29:49,086 --> 00:29:50,900
那么这个加密系统就不会有很好的安全性.
then this wouldn't be a very good crypto system. 

494
00:29:50,900 --> 00:29:54,294
所以我可以将这个对称加密的想法
And so I can combine this idea of symmetric key cryptography 

495
00:29:54,294 --> 00:29:57,575
与我们刚才谈论的密钥生成函数相结合.
with the topic we just talked about, key derivation functions. 

496
00:29:57,575 --> 00:30:04,350
因此,与其通过密钥生成函数随机生成密钥.
So instead of having some key that's randomly generated with my key generation function,\N say sampling entropy from somewhere on my machine, 

497
00:30:04,350 --> 00:30:14,025
我可以使用一个口令,并将其传递给我的密钥生成函数,
I can have a passphrase and pass it through my key derivation function box, 

498
00:30:14,375 --> 00:30:16,475
处理后就可以得到我的密钥.
and this gives me my key. 

499
00:30:16,475 --> 00:30:26,275
然后,我可以将我的明文和密钥输入到我的加密函数中,
Then, I can take my plaintext and combine it with my key in my encrypt function, 

500
00:30:28,450 --> 00:30:30,925
从而产生我的密文.
and this produces my ciphertext. 

501
00:30:33,900 --> 00:30:36,800
我将这个密文存储在网络服务上,
I store this ciphertext on the web service, 

502
00:30:36,800 --> 00:30:38,975
现在我不需要保存这个密钥了.
but now I don't need to save this key. 

503
00:30:38,975 --> 00:30:41,425
我只需要记住我的口令,
Instead, I can just remember my passphrase, 

504
00:30:41,425 --> 00:30:43,274
每当我需要我的密钥时,
and whenever I need my key, 

505
00:30:43,274 --> 00:30:45,625
我就可以通过密钥生成函数中重新生成它.
I can reconstruct it from the key derivation function. 

506
00:30:45,700 --> 00:30:46,625
问题?
Question? 

507
00:30:56,825 --> 00:30:58,550
是的,这是一个好问题.
Yeah, so that's a good question. 

508
00:30:58,550 --> 00:31:03,737
问题是,密钥生成函数为了防止暴力破解是否足够慢?
The question is, is the key derivation function slow enough to prevent brute-force guessing? 

509
00:31:03,737 --> 00:31:07,050
答案是,这取决于你的口令有多长.
The answer is, it depends on how long your passphrase is. 

510
00:31:07,050 --> 00:31:10,841
例如,如果你的口令像字符串"password"一样简单,
For example, if your passphrase is like the string 'password', 

511
00:31:10,841 --> 00:31:12,441
那么它很可能很快就能被破解.
it is probably going to get broken very quickly. 

512
00:31:12,475 --> 00:31:15,800
但要是你的口令具有高熵,安全性就足够高.
But as long as there's enough entropy in your passphrase, this is good enough. 

513
00:31:15,800 --> 00:31:17,875
所以,如果我要上传一些文件到Dropbox,
So, like if I was uploading something to Dropbox

514
00:31:17,875 --> 00:31:19,375
我希望它有很高的安全性,
 and I really want it to stay secret, 

515
00:31:19,375 --> 00:31:21,375
那么一个64位口令,
I think a 64-bit passphrase, 

516
00:31:21,375 --> 00:31:26,525
一个具有64位熵的口令,在这种情况下将足够安全.
really a passphrase with 64 bits of entropy, it would be more than enough in that scenario, for example. 

517
00:31:27,250 --> 00:31:31,225
这里还有一个简单的演示:有一些工具可以简化这个流程.
And just a quick demo of this: so there are tools to make this really easy to do. 

518
00:31:31,225 --> 00:31:33,050
实际上,这是课程笔记的一个练习,
This is actually one of the exercises, 

519
00:31:33,050 --> 00:31:36,250
我们可以使用一个名为openssl的工具,
but we can take a tool, for example, called openssl, 

520
00:31:36,250 --> 00:31:40,025
对某个文件实施对称加密.
and use it to apply a symmetric cipher to some file. 

521
00:31:40,025 --> 00:31:42,700
例如,我有"README.md".
So, I had my README text here, for example, "README.md". 

522
00:31:42,700 --> 00:31:44,775
它里面有很多东西,
It has a bunch of stuff in it, 

523
00:31:44,775 --> 00:31:52,500
我可以输入"openssl aes-256-cbc","aes-256-cbc"是一个对称加密算法,
and I can do "openssl aes-256-cbc", this is the name of a particular symmetric cipher, 

524
00:31:52,650 --> 00:31:57,671
然后我可以说我要将它应用于"README.md",
and I can say that I want to apply this to "README.md" 

525
00:31:57,671 --> 00:32:02,450
并输出为...让我们给它起一个名字,"README.enc.md",
and produce "README.enc.md", let's give it some name.

526
00:32:02,450 --> 00:32:03,900
然后它会要求你输入一个密码.
And then it's asking you for a password. 

527
00:32:03,900 --> 00:32:06,615
所以,默认情况下,它是这样工作的,我提供一个口令,
So, by default, this works in this mode where I provide a passphrase, 

528
00:32:06,615 --> 00:32:08,471
它经过KDF处理后生成一个密钥,
it's run through a KDF to produce a key, 

529
00:32:08,500 --> 00:32:09,850
然后用于加密.
and that's used for encryption. 

530
00:32:09,850 --> 00:32:12,725
所以,我会输入一个密码.再输入一遍....
So, I'll type in some password, type it in again, 

531
00:32:12,725 --> 00:32:15,600
然后现在已经生成了这个"README.enc.md".
and now I produce this "README.enc.md" file. 

532
00:32:15,600 --> 00:32:20,025
如果我查看这个文件,感觉它啥也不是.
If I look at this, it kind of looks like garbage, 

533
00:32:20,050 --> 00:32:22,725
但这正是对称加密的关键.
And that's, at a high level, the point of a symmetric cipher. 

534
00:32:22,725 --> 00:32:27,450
它产生的密文和随机数据一样,我们没法区分.
It produces some ciphertext that should be kind of indistinguishable from random data. 

535
00:32:28,025 --> 00:32:30,890
当我想要解密这个文件时,
And when I want to decrypt this, I can run 

536
00:32:30,890 --> 00:32:36,950
我可以运行类似的命令:"openssl aes-256-cbc -d",表示解密,
a similar command: 'openssl aes-256-cbc -d', for decrypt,

537
00:32:36,950 --> 00:32:39,883
"README.enc.md"作为输入,
take the input from "README.enc.md", 

538
00:32:39,925 --> 00:32:46,950
并将"README.dec.md"作为输出.
and I like to do "README.dec.md" as the output. 

539
00:32:47,650 --> 00:32:50,800
我可以比较这两个文件,
And I can compare these two files, 

540
00:32:52,750 --> 00:32:58,300
对称加密的属性告诉我解密后的结果应该与原始数据完全一致.
and the correctness property of symmetric cryptography tells me that this should be identical. 

541
00:32:58,300 --> 00:32:59,975
确实如此.
And this indeed is identical. 

542
00:32:59,975 --> 00:33:02,125
如果我查看返回值,返回值为0,
If I look at the return value, compare return 0, 

543
00:33:02,125 --> 00:33:03,825
这意味着它们是相同的文件.
so that means that are the same file. 

544
00:33:04,550 --> 00:33:12,725
所以,关于对称加密有什么问题吗?
So, any questions about symmetric key cryptography? Yeah, 

545
00:33:19,750 --> 00:33:24,125
这个命令确实创建了一个新文件,
so the particular command did make a new file, 

546
00:33:24,125 --> 00:33:26,360
所以它以"README.md"作为我们的输入
so it took us input "README.md" 

547
00:33:26,360 --> 00:33:27,950
并产生了这个文件作为输出,
and produced output this file, 

548
00:33:27,950 --> 00:33:30,400
这就是该文件的加密版本.
so that is the encrypted version of the file.

549
00:33:30,400 --> 00:33:32,650
它并没有改变原始文件,
It left the original untouched, 

550
00:33:32,650 --> 00:33:35,250
但是如果我想,我可以删除它.
but then of course I could delete it if I wanted to. 

551
00:33:45,325 --> 00:33:47,244
这是一个很好的问题.
 that's a good question. 

552
00:33:47,244 --> 00:33:49,400
但是我不会详细讨论.
This is something I wasn't gonna talk about in too much detail. 

553
00:33:49,400 --> 00:33:52,600
问题是,我在这里加了一些盐,那么它存储在哪里?
The question is, I provided the salt argument here, and where is that stored?

554
00:33:52,600 --> 00:33:58,525
答案是,它在这个输出的文件里面.
So, the answer is that that is stored in this output here. 

555
00:33:58,725 --> 00:34:05,150
因此,此输出文件存储了盐值和密文,
So, this output format stores both the salt and the actual output ciphertext, 

556
00:34:05,150 --> 00:34:07,875
它可以用于重构和解密.
so can be used in the reconstruction and decrypt. 

557
00:34:11,925 --> 00:34:12,875
是的,没错.
Yeah, that's correct. 

558
00:34:12,875 --> 00:34:14,950
它不需要任何数据库或其他东西.
It doesn't keep any database or anything. 

559
00:34:14,950 --> 00:34:16,500
它是自包含的.
This is fully self-contained. 

560
00:34:18,700 --> 00:34:19,380
是的,
Yeah, 

561
00:34:19,380 --> 00:34:22,000
正如John所说,盐并不是密码,
and as John says, the salt is not the secret, 

562
00:34:22,000 --> 00:34:26,350
口令才是秘密.
like the passphrase is what is the secret thing here. 

563
00:34:27,725 --> 00:34:30,350
好的,
Okay, 

564
00:34:31,450 --> 00:34:34,050
让我们回到问题.
so let's go back to the question. 

565
00:34:34,050 --> 00:34:35,480
什么是盐?
What is salt? 

566
00:34:35,480 --> 00:34:38,950
在哈希函数的背景下,
The idea of a cryptographic salt 

567
00:34:38,950 --> 00:34:42,790
加密盐的概念最好还是要解释一下.
is probably best explained in the context of hash functions. 

568
00:34:46,050 --> 00:34:50,375
哈希函数的一个常见应用是在数据库中存储密码.
So, one common application of hash functions is to store passwords in a password database. 

569
00:34:50,375 --> 00:34:51,646
如果我有一个网站,
If I have a website 

570
00:34:51,646 --> 00:34:55,475
并且有用户会输入用户名和密码进行登录,
and I have logins for users, like people log in with their username and password, 

571
00:34:55,550 --> 00:34:59,925
我不想以明文的形式存储人们的密码.
I don't actually want to store people's passwords in plain text just like as is. 

572
00:34:59,925 --> 00:35:02,225
有人知道我为什么不想这样做吗?
Does anybody know why I wouldn't want to do that?  

573
00:35:04,100 --> 00:35:04,800
是的.
Yes, 

574
00:35:06,900 --> 00:35:09,656
如果有攻击者获取了密码数据库,那会怎么样呢?
Exactly.What if there was a breach and someone got all your data?

575
00:35:09,656 --> 00:35:12,536
所以,如果泄漏了所有用户的密码,那就真的很糟糕.
So, it's really bad if you leak all your users' passwords. 

576
00:35:12,536 --> 00:35:16,150
特别是许多人会在不同的网站上重复使用他们的密码.
It's especially bad because a lot of people reuse their passwords across different sites. 

577
00:35:16,150 --> 00:35:18,118
如果攻击者侵入一个网站,
So, you'll see attackers break into one thing, 

578
00:35:18,118 --> 00:35:19,725
例如,前段时间雅虎的大规模泄露事件,
like there was big Yahoo breach a while ago, 

579
00:35:19,725 --> 00:35:21,900
他们可能会找到所有的用户名和密码,
and they find all these usernames and passwords, 

580
00:35:21,900 --> 00:35:24,324
然后试图在Google,Facebook和YouTube等网站上
and then they go and try those same login credentials

581
00:35:24,324 --> 00:35:26,725
使用这些相同的密码进行登录.
 on Google and on Facebook and on YouTube and whatnot. 

582
00:35:26,725 --> 00:35:28,375
因为有些人会重复使用密码,
These people reuse passwords, 

583
00:35:28,750 --> 00:35:31,525
所以存储明文密码达咩！
so it's bad to store plaintext passwords. 

584
00:35:31,525 --> 00:35:35,274
为了保护账户安全,我们应该使用哈希函数
So, one thing you should do is you should store hashed passwords with a hash function, 

585
00:35:35,274 --> 00:35:39,750
或者是速度比较慢的加密哈希函数来存储加密后的密码.
or ideally a password hashing function that's intentionally designed to be slow. 

586
00:35:39,750 --> 00:35:43,424
一旦攻击者知道
But one thing attackers started doing 

587
00:35:43,424 --> 00:35:46,112
人们开始存储哈希密码之后,
once they realized that people started storing hashed passwords 

588
00:35:46,112 --> 00:35:48,700
攻击者开始做的一件事情就是构建所谓的"彩虹表".
is they built these things called rainbow tables. 

589
00:35:48,700 --> 00:35:53,256
攻击者会使用一些工具来生成可能的密码哈希映射数据库,
What people did was they took a way of generating big password lists,

590
00:35:53,256 --> 00:35:56,075
通常是基于一些密码模型来推断用户密码.
like the kind of model what passwords might look like. 

591
00:35:56,075 --> 00:35:57,790
例如,它将字典中的所有单词
Say, take all the dictionary words, 

592
00:35:57,790 --> 00:36:03,707
以及长度为0到8的字符串等全部进行哈希处理,
take all strings of like length from zero to eight and whatnot, take all of those and then hash them 

593
00:36:03,707 --> 00:36:07,868
并将哈希值映射回原始密码,然后存储到数据库中.
and produce a big database mapping hashes back to their pre-image. 

594
00:36:07,868 --> 00:36:09,850
因此,给定一个哈希函数的输出,
And so given the output of a hash function, 

595
00:36:09,850 --> 00:36:12,300
不必像之前说的那么暴力尝试,
rather than have to like brute force said on the fly, 

596
00:36:12,300 --> 00:36:13,761
你可以去这个数据库中查找,
you can just go look up in this database, 

597
00:36:13,761 --> 00:36:15,800
"哦,对应于这个输出的输入是什么?"
"Oh, what is the input that corresponds to this output?" 

598
00:36:15,800 --> 00:36:17,234
实际上,有些攻击者已经
And people have built these 

599
00:36:17,234 --> 00:36:19,475
针对相当大的真实密码数据库建立了彩虹表.
for reasonably large password databases. 

600
00:36:19,650 --> 00:36:24,314
作为防御,你可以做的一件事是,
And so one thing that you can do in reaction to that as a defense 

601
00:36:24,314 --> 00:36:33,375
不是仅在你的数据库中存储密码的哈希值,
is rather than storing in your database.\N Rather than storing just the hash of the password, 

602
00:36:33,375 --> 00:36:37,975
可以计算一个盐值.
what you do is you compute what's called a salt value. 

603
00:36:42,300 --> 00:36:44,975
这是一个长的随机字符串.
And what this is is a large random string. 

604
00:36:44,975 --> 00:36:50,000
然后,可以在密码数据库中存储盐,
And then what you do is you store in your password database the salt, 

605
00:36:50,000 --> 00:36:52,404
加密盐不是一个秘密,
which is not really a secret

606
00:36:52,404 --> 00:36:54,502
可以将盐值附加到密码后面再进行哈希处理,
 like you can store this in your password database

607
00:36:54,502 --> 00:37:02,850
然后把最终的哈希值存储在密码数据库中.
along with a hash of the password with the salt appended to it. 

608
00:37:03,200 --> 00:37:05,150
这有什么用处呢?
Why is this useful?

609
00:37:05,150 --> 00:37:09,050
这种盐是对于每个用户来说是随机唯一的.
Well, this salt is a random unique value for every user. 

610
00:37:09,050 --> 00:37:10,900
如果有人在两个网站上使用相同的密码
And so if someone has the password 

611
00:37:10,900 --> 00:37:13,275
"safe password one two three",
"safe password one two three" on two web service, 

612
00:37:13,275 --> 00:37:15,966
两个网站都直接对原始密码进行哈希并存储在数据库中,{\rcode2}[*]{\r}
if you are just storing the hash of the password, 
*[这里假设两个网站使用的是相同的哈希函数]

613
00:37:15,966 --> 00:37:18,334
则存储的哈希值在两个web服务器上都是相同的,对吧?
then the hash would be the same on both Web Services, right?

614
00:37:18,334 --> 00:37:20,382
因为这个哈希函数是一个确定性函数.
Because this hash function is a deterministic function. 

615
00:37:20,382 --> 00:37:23,646
但是现在,由于我们使用了这个随机的盐值,
But now, since we're using this randomized salt value, 

616
00:37:23,646 --> 00:37:27,486
我们存储了密码加上盐的哈希值.
we store the hash of the password plus the salt. 

617
00:37:27,486 --> 00:37:30,686
因此,即使有的人在多个网站上使用相同的密码,
And so even if someone's using the same password on multiple sites, 

618
00:37:30,686 --> 00:37:33,950
数据库里存储的密码看起来也都不同.
this thing looks different in both cases. 

619
00:37:33,950 --> 00:37:44,175
这个方案就会让彩虹表攻击不再有用.
And it makes it so these big databases mapping these short passwords \N or hash outputs to the short passwords that they came from, those are no longer useful. 

620
00:37:44,175 --> 00:37:45,950
当你的密码使用了加密盐的保护时,
When you have salted passwords, 

621
00:37:45,950 --> 00:37:50,825
攻击者需要为每个受攻击的用户和网站单独进行暴力破解,
you kind of need to do the brute-force attack for every user once you find their salt value, 

622
00:37:50,825 --> 00:37:53,350
因为他们无法使用预先计算好的大型彩虹表.
rather than being able to use this big precomputed database. 

623
00:37:53,350 --> 00:37:57,315
这回答了什么是盐的问题吗?
Does that answer the question of what a salt is?

624
00:37:57,315 --> 00:38:01,275
那么,这些就是有关盐的一些事情.
And so that's what that salt argument is related to. 

625
00:38:07,300 --> 00:38:11,150
看看,对我们刚刚讲的有什么问题吗?
Let's see, any questions about anything we talked about so far? 

626
00:38:12,000 --> 00:38:12,875
好的,
Great,

627
00:38:13,150 --> 00:38:17,294
那么我要擦掉这个.
 okay, so the I'm gonna go ahead and erase this.

628
00:38:17,294 --> 00:38:20,927
然后我们最后要谈论的是
And then the last topic we'll talk about is 

629
00:38:20,927 --> 00:38:23,325
密码学中最令人兴奋的发展之一.
one of the most exciting developments of cryptography. 

630
00:38:23,325 --> 00:38:24,375
在很久很久以前就产生了这个概念,
Happen quite a while ago, 

631
00:38:24,400 --> 00:38:25,850
但放在现在也仍然非常酷,
but it's still a really cool concept, 

632
00:38:25,850 --> 00:38:28,375
即所谓的非对称加密.
something called asymmetric key cryptography. 

633
00:38:40,550 --> 00:38:49,075
这个想法,是现今许多安全和隐私相关的功能的基础
And so this is an idea that actually enables a lot of the security \N and privacy-related features of basically anything you use today. 

634
00:38:49,075 --> 00:38:52,034
例如,当你要转到"www.google.com"时,
Like when you need to go and type in "www.google.com"

635
00:38:52,034 --> 00:38:55,475
非对称加密就会被用来保护你通信和数据传输安全.
asymmetric key cryptography is used as part of what goes on there. 

636
00:38:56,325 --> 00:39:00,548
这看起来与我们讲的对称加密非常相似,
So this is going to look pretty similar to what we talked about in symmetric key cryptography,

637
00:39:00,548 --> 00:39:02,020
但有一个区别.
except with a twist. 

638
00:39:04,200 --> 00:39:06,275
这里有一个密钥生成函数,
There's a key generation function,

639
00:39:06,275 --> 00:39:09,603
同样是随机的,但不是生成单个密钥,
which similarly is randomized but instead of producing a single key, 

640
00:39:09,603 --> 00:39:12,419
而是生成一对密钥,
it produces a pair of keys, two different things, 

641
00:39:15,969 --> 00:39:19,436
其中一个被称为公钥,
one of which is referred to as a public key 

642
00:39:21,961 --> 00:39:26,425
另一个被称为私钥.
and the other is referred to as a private key. 

643
00:39:26,425 --> 00:39:29,048
然后可以使用它们进行加密和解密,
And then these can be used for encryption and decryption 

644
00:39:29,048 --> 00:39:31,800
方式与对称加密类似,
in a manner kind of similar to symmetric key crypto, 

645
00:39:31,800 --> 00:39:34,525
但这俩密钥的用途不同.
except these different keys have different uses now. 

646
00:39:34,550 --> 00:39:36,677
现在我们有一个加密函数,
So we have an encryption function 

647
00:39:36,677 --> 00:39:40,775
我在这里放一个P,表示它是明文,
which takes in a plaintext, I'll write P here, 

648
00:39:40,775 --> 00:39:47,700
这个加密函数还要接受公钥,然后输出密文.
and it takes in the public key and produces the ciphertext. 

649
00:39:47,700 --> 00:39:50,675
然后我有一个解密函数,
And then I have a decryption function 

650
00:39:50,675 --> 00:40:01,225
它接收我的密文和私钥,并还原出明文.
which takes in my ciphertext and the private key and gives me back my plaintext. 

651
00:40:02,425 --> 00:40:07,605
与前面所讲的两个属性类似,
And then similarly to those two properties we had over there,

652
00:40:07,605 --> 00:40:09,909
仅凭密文,
given just the ciphertext,

653
00:40:09,909 --> 00:40:14,517
我们无法解密出明文,除非我们有私钥.
we can't figure out the plaintext unless we have the private key. 

654
00:40:14,575 --> 00:40:16,611
然后,我们也有一个显然正确的属性,
And then we have the obvious correctness property that 

655
00:40:16,611 --> 00:40:19,350
如果我们用公钥加密某些东西,
if we encrypt something with the public key, 

656
00:40:19,350 --> 00:40:24,125
然后拿着那个密文
and then take that ciphertext and try decrypting it 

657
00:40:24,125 --> 00:40:27,709
尝试用相应的私钥来解密,
with the corresponding private key that came from this key generation process, 

658
00:40:27,709 --> 00:40:29,924
(公钥和私钥就是来自这个密钥生成函数),
(That outputs these two different things at once)

659
00:40:29,924 --> 00:40:32,859
那么最终我将得到明文P.
then I get the same result back. 

660
00:40:35,025 --> 00:40:37,300
所以这非常类似于上面所说的对称加密,
So this is very similar to what's above, 

661
00:40:37,300 --> 00:40:40,925
但有一个不同的地方,我们有两个不同用处的密钥.
but there's a twist that we have these two different keys that have different functions. 

662
00:40:40,925 --> 00:40:45,975
有个很棒的事儿,这个公钥就像它的名字一样,可以进行公开,
It's really neat that this public key can actually be made, as the name indicates, public. 

663
00:40:45,975 --> 00:40:48,775
任何人都可以在互联网上使用非对称加密,
Like I could be using a crypto system that works like this, 

664
00:40:48,775 --> 00:40:51,775
然后发布一个公钥供任何人查看,
post a public key on the internet for anybody to see, 

665
00:40:51,775 --> 00:40:53,400
但保持私钥的私密性.
but keep my private key secret. 

666
00:40:53,400 --> 00:40:56,511
然后我有了这个有趣的属性,
And then I have this interesting property that anybody on the internet 

667
00:40:56,511 --> 00:41:00,991
任何人都可以使用我的公钥加密任何内容
can take any piece of content and encrypt it for me using my public key, 

668
00:41:01,025 --> 00:41:02,850
并通过互联网将其发送给我.
and send it over the internet to me. 

669
00:41:02,850 --> 00:41:05,125
然后我可以使用我的私钥解密它,
And then I can decrypt it using my private key, 

670
00:41:05,125 --> 00:41:07,725
只要我的私钥保持私密,
and as long as my private key stays secret, 

671
00:41:07,725 --> 00:41:10,989
任何人都可以使用我的公钥,这是无关紧要的.
it doesn't matter if my public key is available to anybody on the internet.

672
00:41:11,000 --> 00:41:13,450
这就是非对称性.
So here's where the asymmetry comes from. 

673
00:41:13,925 --> 00:41:18,775
之前,有这样一种情况,假设我在网上,
Before, we were in a scenario where, suppose I was on the internet, 

674
00:41:18,775 --> 00:41:21,300
你没有和我面对面交谈,
but you weren't like talking to me face-to-face, 

675
00:41:21,300 --> 00:41:24,425
你想在一些未加密的频道上,
and you wanted to send me some data over the internet over some 

676
00:41:24,425 --> 00:41:29,600
使用对称加密把数据传送给我,
unencrypted channel where anybody could listen on what you were saying, \N and you wanted to use symmetric key cryptography. 

677
00:41:29,600 --> 00:41:32,475
我们需要事先交换密钥,
Well, we need some way of exchanging a key in advance 

678
00:41:32,475 --> 00:41:34,435
然后你可以使用密钥加密一些纯文本,
so that you could encrypt some plaintext with a key

679
00:41:34,435 --> 00:41:36,059
并将那个密文传输给我,
 and give me that ciphertext over the internet

680
00:41:36,059 --> 00:41:38,700
然后我可以使用该密钥进行解密.
so that I could decrypt it with that key.

681
00:41:38,700 --> 00:41:43,650
在对称加密中,如果密钥被公开了,那么游戏就结束了,
In symmetric key crypto, if the keys public, it's game over, like anybody can decrypt your stuff. 

682
00:41:43,675 --> 00:41:45,975
任何人都可以解密你的东西.
Whereas in asymmetric key cryptography, 

683
00:41:45,975 --> 00:41:47,500
而在非对称加密中,我可以拿出我的公钥
I could take my public key 

684
00:41:47,500 --> 00:41:49,450
并将其张贴在互联网上的公告板上,
and post it on a bulletin board on the internet, 

685
00:41:49,450 --> 00:41:53,000
你可以使用公钥来加密一些内容,
and you can go look at that, take some contents and encrypt them for me, 

686
00:41:53,000 --> 00:41:54,150
然后在网上发放,
and then send them over, 

687
00:41:54,150 --> 00:41:55,775
这将是完全可以的,
and that would be totally fine. 

688
00:41:55,775 --> 00:41:58,100
但是这些内容只能使用私钥来解密.
You can only decrypt it with the private key.

689
00:41:58,100 --> 00:42:00,620
所以有一个比喻,
So one analogy that may be helpful 

690
00:42:00,620 --> 00:42:04,275
是将这些数学思想与现实中的锁进行类比.
is comparing these mathematical ideas to physical locks. 

691
00:42:04,275 --> 00:42:07,600
你的房门可能有一个锁,
You probably have a lock on your door to your house, 

692
00:42:07,600 --> 00:42:12,950
你可以用钥匙锁门,开门
and you can put in a key and like turn the thing in order to lock the door \N or you can turn it the other way to unlock the door. 

693
00:42:12,950 --> 00:42:14,000
所以现在有一把的钥匙,
So there's a single key, 

694
00:42:14,000 --> 00:42:16,075
它既可以锁门也可以开门.
and it can both lock and unlock the door. 

695
00:42:16,075 --> 00:42:18,096
现在回到我们的情景上去,
But now consider this alternative construction,

696
00:42:18,096 --> 00:42:23,728
如果我想让你能够通过互联网发送向我发送一条消息
which you might use if, say, I want you to be able to send me a message \N and have it be sent over the internet, 

697
00:42:23,728 --> 00:42:27,825
而且你和我之间不需要交换钥匙.
and you and I don't really need a way to exchange a key with you beforehand.

698
00:42:27,825 --> 00:42:30,175
我可以买一个盒子,你可以把信放在里面,
I could get a box which you could put a letter inside, 

699
00:42:30,175 --> 00:42:31,525
然后你可以关上盒子.
and you can close the box. 

700
00:42:31,525 --> 00:42:33,375
我可以买一个锁,
And I can get one of the padlock things, 

701
00:42:33,375 --> 00:42:38,367
我可以打开锁并把它给你.
which I can give you by I could like take those padlock and open it and give it to you. 

702
00:42:38,367 --> 00:42:42,271
你可以把你的信息放在盒子里,
And you, at your own leisure, could put your message inside a box 

703
00:42:42,271 --> 00:42:44,475
然后用这个打开的锁,
and take this padlock, which is open, 

704
00:42:44,750 --> 00:42:48,025
再把盒子锁上,然后将盒子发给我.
and shut it around the box and then send it over to me. 

705
00:42:48,025 --> 00:42:49,775
然后我可以用我的钥匙打开盒子.
And then I could put in my key and unlock it.

706
00:42:49,775 --> 00:42:53,337
从这里你能看到这种不对称性,
So do you see how there is this asymmetry there as opposed to the 

707
00:42:53,337 --> 00:42:55,225
与我用来打开我家门的钥匙不同,
key that I used to open the door to my house, 

708
00:42:55,225 --> 00:42:57,225
我家门只要用同一把钥匙就可以开关门.
where the same key opens and closes the thing? 

709
00:42:57,225 --> 00:42:59,447
而我给你这个打开的锁,
Instead, I give you this open padlock

710
00:42:59,447 --> 00:43:01,750
你有能力锁上它但无法打开它.
 that you have the ability to close but not open. 

711
00:43:01,750 --> 00:43:04,825
在你锁上之后,我可以使用我钥匙
And after you closed it, I can use my key, which I've kept secret, 

712
00:43:04,825 --> 00:43:07,150
来打开它并取出里面的东西.
in order to open the thing and retrieve what's inside. 

713
00:43:07,275 --> 00:43:09,425
这个比喻也许对你们理解有帮助,也许没有.
Maybe this analogy is helpful, maybe it's not. 

714
00:43:09,425 --> 00:43:12,600
如果你理解了数学原理,那么这个技术就可以很好地为你效劳.
The mathematical construction works just fine if that works for you.

715
00:43:12,600 --> 00:43:18,384
关于非对称加解密,
So any questions about asymmetric key encryption and decryption 

716
00:43:18,384 --> 00:43:22,900
以及它与对称加密的关系有什么问题吗?
and how it relates to symmetric key crypto, how it's a little bit different?

717
00:43:24,225 --> 00:43:27,728
在我们讨论非对称加密的应用之前,
So before we talk about applications of this idea, 

718
00:43:27,728 --> 00:43:33,875
我将先讲讲非对称加密中的另一组概念.
I'm going to talk about one other set of concepts in asymmetric key cryptography. 

719
00:43:33,875 --> 00:43:39,440
这些加密系统为你提供了加密/解密相关的工具,
These crypto systems give you another set of tools which are related to encryption and decryption, 

720
00:43:39,475 --> 00:43:41,625
称为签名和验证.
something called signing and verifying. 

721
00:43:41,625 --> 00:43:44,575
这在一定程度上与现实世界有些类似,
And this is kind of similar to the real world like I can 

722
00:43:44,575 --> 00:43:46,950
我可以得到一份文件并签上我的大名.
get a document and sign it with my signature. 

723
00:43:46,950 --> 00:43:50,525
现实世界的签名相对容易伪造,
Except real-world signatures are, I don't think that hard to forge. 

724
00:43:50,525 --> 00:43:53,425
但是这里这些签名是相当难伪造的,因此更有用.
These are pretty hard to forge and, therefore, more useful. 

725
00:43:53,425 --> 00:43:57,497
签名方案是什么样的?
What do signature schemes look like?

726
00:43:57,497 --> 00:44:05,025
有一个函数"sign",它接收消息和私钥,
There's a function "sign" that takes us some message and the private key, 

727
00:44:07,125 --> 00:44:10,075
注意这是私钥,而不是公钥,
so notice this, this is the private key, not the public key, 

728
00:44:10,075 --> 00:44:12,325
它会生成一个签名.
and it produces a signature. 

729
00:44:14,125 --> 00:44:23,600
然后还有另一个函数"verify",它接收消息和签名
And then there's another function "verify" which takes in the message, the signature, 

730
00:44:23,725 --> 00:44:26,150
以及这里是公钥,
and the public key this time, 

731
00:44:31,850 --> 00:44:36,425
它会返回一个布尔值,告诉我签名是否正确.
and it tells me it returns a boolean whether or not the signature checks out. 

732
00:44:36,425 --> 00:44:42,406
然后这一对函数具有一些特性,
And then this pair of functions has the property that, again, 

733
00:44:42,406 --> 00:44:50,050
这些特性与现实里的签名和验证类似,
these are kind of properties that follow the intuition that come from physical signatures that, 

734
00:44:50,625 --> 00:44:55,142
即如果没有私钥,很难为任何消息产生一个签名,
without the private key, it's hard to produce a signature

735
00:44:55,142 --> 00:44:59,046
你就无法将消息和公钥一起提供给"verify"函数
for any message such that you can give the message in the signature 

736
00:44:59,046 --> 00:45:02,675
以获取返回值为true.
and the public key to the "verify" function to get it to return true. 

737
00:45:02,675 --> 00:45:06,175
它很难被伪造.
Like at a high level, it's hard to forge. 

738
00:45:09,775 --> 00:45:13,750
没有私钥是很难伪造签名的.
It's hard to forge a signature, of course, without the private key. 

739
00:45:19,825 --> 00:45:22,680
然后也有显然正确的属性,
And then there's the obvious correctness property 

740
00:45:22,680 --> 00:45:25,736
即如果你使用公钥签署了一个东西,
that if you signed a thing with a public key

741
00:45:25,736 --> 00:45:27,672
然后尝试使用相应的私钥进行验证,
 and then try verifying it with the corresponding, 

742
00:45:27,675 --> 00:45:29,511
不好意思,应该是用私钥签署了一个东西,
sorry, if you sign a thing with the private key 

743
00:45:29,511 --> 00:45:31,559
然后尝试使用相应的公钥进行验证,
and try to verify it with the corresponding public key, 

744
00:45:31,559 --> 00:45:35,000
它将返回一个好的验证结果.
it returns okay that this verification checks out. 

745
00:45:36,700 --> 00:45:44,525
因此,这是非对称加密可以做的两件事.
So these are two different kinds of things you can do with asymmetric key crypto systems. 

746
00:45:44,525 --> 00:45:47,707
你可能听说过,
An example of an asymmetric key crypto system that you might have heard of 

747
00:45:47,707 --> 00:45:49,350
有一个叫RSA的非对称加密.
is something called RSA. 

748
00:45:49,350 --> 00:45:51,464
RSA是由许多人共同设计的,
So RSA is designed by a number of people, 

749
00:45:51,464 --> 00:45:53,650
其中一人是Ron Rivest,他是这里的教授.
one of whom is Ron Rivest who's a professor here. 

750
00:45:57,525 --> 00:46:01,531
实际上还有很多很有趣的非对称加密应用,
So there are a couple of interesting applications of asymmetric key crypto, 

751
00:46:01,531 --> 00:46:04,667
真要讲可能需要花上几天时间,
actually like tons and tons and tons of, you spend like days talking about this, 

752
00:46:04,667 --> 00:46:07,525
但其中有个例子是电子邮件加密.
but a couple examples are email encryption. 

753
00:46:07,525 --> 00:46:09,675
我们之前谈到了发送消息的一些事情.
So we talked a little bit about sending messages. 

754
00:46:09,675 --> 00:46:14,375
通过非对称加密,你可以在网上发布公钥.
What we can do with asymmetric key crypto is that you can have public keys posted online. 

755
00:46:14,375 --> 00:46:18,414
我认为一些教练在他们的网站上发布了PGP公钥.
I think some of the instructors have PGP public keys on their website. 

756
00:46:18,414 --> 00:46:21,775
例如,如果你访问我的网站或John的网站,你可以找到一个公钥.
So for example, you go to my website or John's website, you'll find a public key. 

757
00:46:21,775 --> 00:46:25,675
然后你可以发送给我们一个加密的电子邮件.
And then what you can do is you can send us an encrypted email. 

758
00:46:25,675 --> 00:46:28,788
即使该消息通过Gmail
And so even if that message goes through Gmail 

759
00:46:28,788 --> 00:46:30,750
或其他电子邮件服务传递到MIT的邮件服务器,
or whatever other mail service throughout MIT's mail servers, 

760
00:46:30,750 --> 00:46:33,758
如果有攻击者偷窥消息,
if there happens to be an attacker snooping on the messages,

761
00:46:33,758 --> 00:46:37,175
他们也无法理解其内容,因为它们都被加密了.
they can't make any sense of their contents because they're all encrypted. 

762
00:46:37,175 --> 00:46:40,734
这真的很酷,你可以做到这一点,
And this is really cool because you can do this without kind of

763
00:46:40,734 --> 00:46:43,190
而且你也无需亲自找到我们并交换密钥,
finding us in person and exchanging keys, 

764
00:46:43,190 --> 00:46:45,406
要是使用对称加密,你必须要交换密钥.
which you might have to do in a symmetric key crypto system. 

765
00:46:45,406 --> 00:46:49,175
但是现在你只要在网上找到我们的公钥,
You can just find our public key, which can be posted online without causing any issues, 

766
00:46:49,175 --> 00:46:51,400
然后发送加密邮件给我们.
and then send us encrypted email. 

767
00:46:51,400 --> 00:46:55,425
此外,非对称加密还可以用于私人通信.
Another thing asymmetric key crypto is used for is private messaging.

768
00:46:55,425 --> 00:46:57,409
如果你使用过
So raise your hand if you've used anything like

769
00:46:57,409 --> 00:47:01,650
类似Signal或Telegram或者WhatsApp{\rcode2}[*]{\r}的请举手,
signal or telegram or I think what's up is in theory antenna encrypted, 
*[理论上支持端对端加密]

770
00:47:01,650 --> 00:47:02,500
不错,很多人都用过了...
so a good number of you. 

771
00:47:03,125 --> 00:47:07,850
这些私人通信应用程序也使用
These private messaging applications also use asymmetric key crypto 

772
00:47:07,850 --> 00:47:10,575
非对称加密技术建立私人通信通道.
to establish private communication channels. 

773
00:47:10,575 --> 00:47:14,675
基本上,每个人都有一对密钥,
Basically, every person has associated with them a key pair, 

774
00:47:14,675 --> 00:47:17,450
你的设备会运行密钥生成函数
and so your device has run this key generation function 

775
00:47:17,450 --> 00:47:19,370
并生成了一个公钥和一个私钥,
produced a public key and a private key 

776
00:47:19,370 --> 00:47:22,225
并且自动将你的公钥发布到互联网上.
and automatically posted your public key to the internet. 

777
00:47:22,225 --> 00:47:25,675
例如,如果你使用Signal,你的公钥就在Signal服务器上,
So, for example, if you're using signal, your public key is on the signal servers, 

778
00:47:25,675 --> 00:47:27,700
当有人想要联系你时,
and then when someone wants to contact you,

779
00:47:27,700 --> 00:47:30,950
他们的手机可以查找你的公钥,
their phone can look up your public key, retrieve it, 

780
00:47:30,950 --> 00:47:34,025
一旦检索到你的公钥,他们就可以为你加密信息.
and once it's retrieved your public key, they can encrypt information for you. 

781
00:47:34,025 --> 00:47:36,275
他们算法大概就是这样工作的,
This is a kind of approximation of how their algorithm works, 

782
00:47:36,275 --> 00:47:38,075
概括来说,这就是实实在在发生的事情.
but at a high level that's what's going on.

783
00:47:38,525 --> 00:47:42,477
非对称密钥密码的另一个有趣应用是
Another neat application of asymmetric key crypto is 

784
00:47:42,477 --> 00:47:44,141
我们之前谈到的,
we were talking about earlier like 

785
00:47:44,141 --> 00:47:46,625
就是确保你从互联网上下载了正确的软件.
making sure you have the right software we downloaded from the internet. 

786
00:47:46,625 --> 00:47:50,100
非对称密钥密码可用于签署软件发布,
Asymmetric key crypto can be used to sign software releases, 

787
00:47:50,100 --> 00:47:54,486
这是人们在从互联网上下载例如Debian软件包,
and this is something that people do for example like Debian packages

788
00:47:54,486 --> 00:47:56,237
或其他东西时所做的操作.
or whatever things you download from the internet. 

789
00:47:56,237 --> 00:47:59,450
开发人员会尝试签署他们的软件,以便你可以确保
The developer will try to sign their software so that you can make sure 

790
00:47:59,450 --> 00:48:01,082
从互联网上下载的任何东西
that whatever you've downloaded from the internet 

791
00:48:01,082 --> 00:48:03,725
都是来自正确的人.
is actually the right thing that came from the right person.

792
00:48:04,025 --> 00:48:08,075
我们在git的讲座中谈到了你可以使用git做的所有有趣的事情.
We talked about in the git lecture all the interesting things you can do with git. 

793
00:48:08,100 --> 00:48:12,850
但是我们没有涉及git中签名相关的功能.
One thing we didn't cover was signing related functionality and git. 

794
00:48:13,450 --> 00:48:16,375
所以git有提交,
So git has commits, 

795
00:48:16,375 --> 00:48:19,325
你可以将一些东西与提交关联起来,这被称为标签.
and you can associate with commits something called tags. 

796
00:48:19,325 --> 00:48:23,188
你可以将一个git提交与一个签名相关联,
At a high level, you can basically take a git commit and attach a signature to it

797
00:48:23,188 --> 00:48:27,375
将你的公钥绑定到此提交中,
which binds your public key to this commit, 

798
00:48:27,375 --> 00:48:29,460
然后任何拥有你的公钥的人
and then anybody who has your public key

799
00:48:29,460 --> 00:48:31,956
都可以使用此提交和你的公钥,
can take the commit and your public key 

800
00:48:31,956 --> 00:48:36,300
所以需要确保提交上有一个合法的签名.
and make sure that there's a legitimate signature on the commit.

801
00:48:39,475 --> 00:48:43,200
让我随便去个仓库看一下.
So let me go to like some random repository that I have. 

802
00:48:43,900 --> 00:48:47,725
我可以查看与仓库相关联的一些标签.
I can look at a bunch of tags associated with the repository. 

803
00:48:47,725 --> 00:48:53,716
如果我查看与该标签相关联的原始数据,
If I do... look at the raw data associated with this tag, 

804
00:48:56,191 --> 00:49:02,125
它有一些元数据,然后是一段ascii码的信息块,
it has some metadata and then a blob of like ascii encoded information 

805
00:49:02,175 --> 00:49:06,708
我可以使用"git tag -v"命令来进行验证,
that I can use the "git tag -v" for verify command 

806
00:49:06,708 --> 00:49:11,444
以确保这就是来自于我.
to make sure that oh this is a good signature from this person happens to be me.

807
00:49:11,444 --> 00:49:14,708
所以我签署了软件发布,这样任何从互联网下载软件的人
so I sign the software release so that anybody who downloads it from the Internet 

808
00:49:14,708 --> 00:49:17,625
都可以确保他们得到了真实的副本.
can make sure that they actually got an authentic copy.

809
00:49:17,625 --> 00:49:19,125
是的,问题?
Yes, question. 

810
00:49:28,525 --> 00:49:31,100
所以问题是
So the question is 

811
00:49:31,100 --> 00:49:35,000
"verify"函数具体是在做什么或者它检查什么?
what exactly is the verify function doing or what is it checking against? 

812
00:49:37,000 --> 00:49:42,350
如果你想在数学原理上了解具体是什么,可以在本讲座之后找我交流.
If you want to know mathematically what's going on, talk to me after this lecture. 

813
00:49:42,350 --> 00:49:45,815
从API的角度来看,
But from kind of an API perspective, what's going on here

814
00:49:45,815 --> 00:49:50,375
这里的签名和消息只是一组字节数据.
is that the signature and also the message here are just a blob of bytes, 

815
00:49:50,375 --> 00:49:53,495
这些数据基本上是这样的:
and it happens to be the case that these things are designed 

816
00:49:53,495 --> 00:50:00,200
对于某个特定的公钥,比如我的公钥,
such that basically if you take for some particular public key, like if you take my public key, 

817
00:50:00,200 --> 00:50:04,119
如果你没有我的私钥,
It's impossible for you, without knowledge of my private key,

818
00:50:04,119 --> 00:50:09,575
就不可能找到第二个钥匙使函数返回 true .
for any message to find a second argument to this function that makes it return true. 

819
00:50:09,575 --> 00:50:13,100
你可以将它类比为签署一份文件.
You can kind of compare it to signing a document. 

820
00:50:13,100 --> 00:50:15,050
就像你不知道如何伪造我的签名一样,
Like, you don't know how to forge my signature. 

821
00:50:15,050 --> 00:50:17,400
我可以在任何纸张上签名,
I can take any piece of paper and sign it, 

822
00:50:17,400 --> 00:50:20,183
然后任何知道我的签名样式的人,
and then anybody who knows what my signature looks like,

823
00:50:20,183 --> 00:50:23,025
可以查看我的文件,验证签名正确.
I can show my document - you can be like, yeah, that checks out. 

824
00:50:23,025 --> 00:50:26,839
但没有私钥的人,
But nobody without the private key can produce a signature 

825
00:50:26,839 --> 00:50:31,650
无法为任何消息产生一个使此函数返回true的签名.
that will make this function return true for any particular message. 

826
00:50:33,800 --> 00:50:38,425
还有问题吗?我是否需要用其他方式再解释一下?
And any related questions started, you want me to explain any other way, or does that make sense? 

827
00:50:50,750 --> 00:50:53,458
那么对于软件签名以及非对称加密的几种应用,
So, any questions about signing software or any of the other

828
00:50:53,458 --> 00:50:57,525
有什么问题吗?
handful of applications talked about of asymmetric key crypto?

829
00:50:59,025 --> 00:51:04,550
好的,最后我想谈谈密钥分发.
Well, so one final thing I want to talk about, we're almost out of time, is key distribution. 

830
00:51:04,550 --> 00:51:08,125
这是非对称加密的一个有趣的方面.
This is a kind of interesting side effect of asymmetric key cryptography. 

831
00:51:08,125 --> 00:51:10,207
它可以实现许多有趣的功能,
It enables a bunch of interesting functionality

832
00:51:10,207 --> 00:51:12,300
比如我可以在互联网上发布我的公钥,
 like I can post my public key on the internet. 

833
00:51:12,300 --> 00:51:14,325
你可以找到它并给我发加密邮件.
You can go find it and send me encrypted email. 

834
00:51:14,325 --> 00:51:17,612
但你怎么知道找到的公钥实际上是我的公钥?
But how do you know that the public key found is actually my public key? 

835
00:51:17,612 --> 00:51:20,600
这似乎存在一个{\rcode2}引导问题[*]{\r},对吗?
It seems like there's a bootstrapping problem here, right? 
*[在数字安全和加密领域,引导问题通常是指如何在 \N 没有预共享密钥和信任基础的情况下建立安全通信渠道的问题]

836
00:51:20,600 --> 00:51:26,060
所以,这是一个非常有趣但是有些困难的现实世界问题,
So, this is like a really interesting and really hard real-world problem, 

837
00:51:26,060 --> 00:51:30,325
可能有这么几种方法来解决这个问题.
and there are a couple different approaches you might take to this problem.

838
00:51:30,325 --> 00:51:32,836
第一种是有点糟糕的解决方案,
One is kind of a lame solution, 

839
00:51:32,836 --> 00:51:34,865
但它可以解决许多密码学问题.
but this thing solves a lot of cryptography problems. 

840
00:51:34,865 --> 00:51:37,450
就是在非网络渠道交换信息,
This exchange the information out-of-band. 

841
00:51:37,450 --> 00:51:40,600
也就是你想给我发加密邮件,
What that means is, you want to send me encrypted email, 

842
00:51:40,600 --> 00:51:42,225
你直接下课后来找我,
we'll just talk to me after class. 

843
00:51:42,225 --> 00:51:44,550
我会给你一张纸条上面写着我的公钥,
I'll give you my public key on a piece of paper, 

844
00:51:44,550 --> 00:51:47,942
由于你亲自与我交谈,你知道这确实就是我的公钥,
and since you were talking to me in person, you know that it's actually my public key,

845
00:51:47,942 --> 00:51:51,270
而不是有人黑进我的网站,放上的一些虚假信息.
not just somebody like hacked my website and stuck some random number on there. 

846
00:51:51,325 --> 00:51:52,675
这样可以解决问题,
That solves the problem, 

847
00:51:52,675 --> 00:51:53,825
但不太优雅.
but it's not the most elegant.

848
00:51:53,825 --> 00:51:56,400
还有几种不同的方法,不同的应用程序使用不同的方法.
There are a couple other approaches that different applications use. 

849
00:51:56,400 --> 00:51:58,275
比如,用过Signal的人,
So, those of you who use signal,

850
00:51:58,275 --> 00:52:01,859
你们有没有遇到过"safety number"这个短语?
have you ever encountered the phrase "safety number" 

851
00:52:01,859 --> 00:52:04,035
或是"用..来验证你的safety number"?
like "verify your safety number with so and so"? 

852
00:52:04,035 --> 00:52:08,628
对于Signal,他们有一种交换公钥的方法,
So, with signal, they have a way of exchanging public keys 

853
00:52:08,628 --> 00:52:10,275
就是通过Signal服务器.
which is through the signal servers. 

854
00:52:10,275 --> 00:52:13,351
运行Signal服务的人只需在其服务器上
Whoever runs the signal service just maintains on their servers 

855
00:52:13,351 --> 00:52:15,775
维护一个从电话号码到公钥的映射.
basically a mapping from phone numbers to public keys. 

856
00:52:15,775 --> 00:52:18,275
当我说"我要给这个号码的人发消息"时,
And when I say, "Oh, I want to message this person with this number", 

857
00:52:18,275 --> 00:52:20,775
我的手机会从互联网上检索他们的公钥,
my phone just goes and retrieves their public key from the internet 

858
00:52:20,775 --> 00:52:23,050
然后用该公钥加密消息.
and then encrypts the message for that public key.

859
00:52:23,100 --> 00:52:30,900
现在,有人对这个设置有什么问题吗?
Now, does anybody see a problem with the setup?  

860
00:52:34,925 --> 00:52:37,850
是的,正是如此.Signal服务器是保证安全性的关键点,
Yeah, exactly. The signal servers are the point of failure there 

861
00:52:37,850 --> 00:52:41,150
因为如果Signal服务器给我错误的公钥,
because if the signal servers give me the wrong public key, 

862
00:52:41,150 --> 00:52:44,890
比如假设 Signal 只是生成了一对新的密钥,并给我这个新生成的公钥,
like suppose signal just produces a new key pair and give me their public key,

863
00:52:44,890 --> 00:52:46,426
那他们就可以读取我所有的消息,
now they can read all my messages. 

864
00:52:46,426 --> 00:52:47,707
他们甚至可以在我和我的朋友之间,
And they could even sit in between

865
00:52:47,707 --> 00:52:50,522
透明地解密我发送给他们的消息,
 and transparently decrypt the messages I send them 

866
00:52:50,522 --> 00:52:53,200
然后重新加密并发送到最终目的地.{\rcode2}[*]{\r}
and then re-encrypt them and send them on to their final destination. 
*[这种攻击方式被称为"中间人攻击"]

867
00:52:53,200 --> 00:52:57,475
所以我需要某种方法来验证我获得的公钥,
Like, basically, I need some way of authenticating the public key I get.

868
00:52:57,475 --> 00:53:03,825
因此,Signal有一个解决方案,本质上还是线下交换密钥.
And so, signal has one solution to this, which is also just kind of punting the issue to out-of-band key exchange. 

869
00:53:03,825 --> 00:53:04,625
你可以与某个人见面,
You can meet up with somebody, 

870
00:53:04,625 --> 00:53:08,575
他们有一个稍微简化的流程,可以在屏幕上显示二维码.
and they have a slightly streamlined flow where they show QR codes on the screen. 

871
00:53:08,575 --> 00:53:10,975
你可以拿一部手机拍下二维码的图片,反之亦然,
You take one phone and take a picture of the other phone screen,  and vice versa,  

872
00:53:10,975 --> 00:53:13,350
现在你已经交换了公钥.
and now you've exchanged public keys in person. 

873
00:53:13,350 --> 00:53:14,625
从那时起,
And from that point on,

874
00:53:14,625 --> 00:53:17,075
你已经启动了加密的端到端通信.
You've bootstrap your encrypted end-to-end communication. 

875
00:53:17,700 --> 00:53:22,450
它还有一个方法,即固定公钥.
It also has an issue of, or it also has an approach of, pinning a public key. 

876
00:53:22,450 --> 00:53:26,162
一旦你知道一个特定的电话号码有一个特定的公钥,
So once you know that a particular phone number has a particular public key, 

877
00:53:26,162 --> 00:53:27,250
你的手机就会记住它,
your phone remembers that, 

878
00:53:27,250 --> 00:53:29,725
如果发生更改,它就会向你发出警告.
and if that ever changes, it'll complain to you. 

879
00:53:30,150 --> 00:53:33,050
然后还有几个解决这个问题的方法.
And then there are a couple of other solutions to this problem. 

880
00:53:33,050 --> 00:53:35,950
PGP是一个曾经流行过的解决方案,
PGP, one popular solution used to be popular a while ago,

881
00:53:35,950 --> 00:53:37,525
它有一个"信任网"的概念.
has this idea of a web of trust. 

882
00:53:37,525 --> 00:53:39,450
就像,我信任我朋友信任的人.
So, like, I trust people who my friends trust. 

883
00:53:39,450 --> 00:53:41,582
所以如果John和我的教授进行了一次线下交换,
So if John has done an out-of-band exchange with, 

884
00:53:41,582 --> 00:53:44,950
那么我可以向我的教授发送电子邮件,
say, my professor, then I can probably email my professor because, 

885
00:53:44,950 --> 00:53:47,350
因为我知道John信任我的教授,而我信任John.
like, I know that John trusts my professor and I trust John. 

886
00:53:47,350 --> 00:53:49,125
所以你可以通过这种方式建立信任链.
So you got this chain of trust through there. 

887
00:53:49,125 --> 00:53:50,525
这是一种有趣的方法.
That's one interesting approach. 

888
00:53:50,525 --> 00:53:53,142
还有另一种模型,最近非常火,
And then another model that's called pretty recently, 

889
00:53:53,142 --> 00:53:55,050
是一种叫做"keybase"工具,
as something that a tool called keybases.

890
00:53:55,050 --> 00:54:03,450
有一个叫做"keybase.io"的网站,
This is a really neat whoops, there's a website called keybase.io, 

891
00:54:03,450 --> 00:54:07,925
他们有一个非常有趣的解决方案,叫做社会证明.
and they have a really interesting solution to this bootstrapping problem, which is social proof. 

892
00:54:07,925 --> 00:54:11,850
比如说,你可能在Facebook和Twitter上有你的朋友,
So saying you probably have your friends on Facebook and on Twitter and whatnot, 

893
00:54:11,850 --> 00:54:14,782
对于攻击者来说
and it's probably pretty hard for an attacker 

894
00:54:14,782 --> 00:54:18,225
同时入侵你朋友的Facebook账号,Twitter账号
to break into your friend's Facebook account at the same time as their Twitter account, 

895
00:54:18,225 --> 00:54:20,475
以及Hacker News账号等等,是非常非常困难的
at the same time as their hacker news account,  and so on.  

896
00:54:20,475 --> 00:54:21,765
因此,有一种有趣的方式,
And so there's this interesting way

897
00:54:21,765 --> 00:54:25,285
将公钥绑定到一组社交身份上,
of binding public keys to a set of social identities 

898
00:54:25,285 --> 00:54:27,272
如果你相信某个社交身份与你的朋友相对应,
such that you can retrieve a public key

899
00:54:27,272 --> 00:54:31,775
那么你可以通过这个社交身份来获取公钥.
once you trust some number of social identities corresponding to your friend. 

900
00:54:32,000 --> 00:54:36,275
如果你想要更详细地了解这些内容,我们在讲义中提供了链接.
We have links to these in the lecture notes if you want to see these things in more detail. 

901
00:54:36,275 --> 00:54:40,175
这就是我们的安全和密码学讲座,
So that's it for our security and cryptography lecture, 

902
00:54:40,175 --> 00:54:43,325
明天的讲座将讲一些
and tomorrow's lecture will be on a random collection of topics 

903
00:54:43,325 --> 00:54:45,025
我们认为很有趣的话题.
that your instructors find interesting. 

904
00:54:45,025 --> 00:54:48,000
希望明天在讲座上见到你们.
So hopefully, see you in lecture tomorrow. 

905
00:54:51,675 --> 00:54:54,825
如果有任何问题,我会在课后呆上几分钟.
I'll also be here for a couple of minutes after class if anybody has questions. 

906
00:55:05,800 --> 00:55:07,075
好的,
Yes, okay, 

907
00:55:07,075 --> 00:55:09,575
John,如果你要走,请随意.
so John, feel free to leave if you have to leave, 

908
00:55:09,575 --> 00:55:11,025
但我想没有人在我们之后使用这个教室.
but I think nobody's using the classroom after us. 

909
00:55:11,025 --> 00:55:13,450
噢,我还想谈谈另一个有趣的话题.
I'm going to talk about one other interesting topic. 

910
00:55:13,450 --> 00:55:18,343
John提到非对称加密速度慢,
So John brought up the fact that asymmetric key cryptography is slow

911
00:55:18,343 --> 00:55:20,850
对称加密速度快的事实.
and symmetric key cryptography is fast. 

912
00:55:20,850 --> 00:55:27,175
因此,在实践中,你可以不仅仅使用非对称加密.
And so in practice, you don't really use just asymmetric key cryptography by itself. 

913
00:55:27,175 --> 00:55:33,550
通常情况下,非对称加密用于启动更复杂的协议.
It's usually used to bootstrap a more sophisticated protocol that you're using. 

914
00:55:37,550 --> 00:55:39,269
你可能想使用
One thing you might want to do is

915
00:55:39,269 --> 00:55:43,816
非对称加密来签名加密邮件,对吧?
 use asymmetric key cryptography for signing encrypted email, right?

916
00:55:43,816 --> 00:55:45,050
我们已经讲过了这个例子.
We talked about that example. 

917
00:55:45,050 --> 00:55:46,575
实际上的工作原理
And the way that works 

918
00:55:46,575 --> 00:55:51,119
并不像我所讲的那样简单.
isn't what you might have guessed from our \N straightforward explanation of asymmetric key crypto. 

919
00:55:51,119 --> 00:55:54,525
你不能只是使用上面的加密函数就结束了.
Like, you don't just use that encrypt function up there and call it a day. 

920
00:55:54,525 --> 00:55:56,592
实际上,
In practice, what you do is 

921
00:55:56,592 --> 00:55:58,960
你所要做的是使用混合加密技术,
you use hybrid encryption

922
00:55:58,960 --> 00:56:08,825
结合对称加密和非对称加密.
to use a combination of symmetric key and asymmetric key cryptography. 

923
00:56:08,950 --> 00:56:13,150
这里,我会画一个大的图.
What you do is, here, I'll draw this as a big block diagram. 

924
00:56:13,150 --> 00:56:14,900
这是你要发送的信息m,
You take your message m, 

925
00:56:14,900 --> 00:56:22,350
然后用我所拥有的公钥进行加密.
and then I have my public key that I want to encrypt for. 

926
00:56:22,350 --> 00:56:23,554
但是,
But rather than just 

927
00:56:23,554 --> 00:56:26,815
与其将这两个信息直接通过那里的加密函数加密,
take these two things and pass it through the encryption up there, 

928
00:56:26,815 --> 00:56:39,550
实际上,你需要使用对称密钥生成函数来产生一个对称密钥K.
what I do is I use the symmetric key gen function to produce a symmetric key K. 

929
00:56:41,100 --> 00:56:43,750
我会在开头加上"symmetric(对称)"这个词,
I'm gonna, like, prepend this with "symmetric"

930
00:56:43,750 --> 00:56:47,040
以便我们可以将其与非对称的密钥生成函数区分开来.
so we can distinguish it from the public key key generation function. 

931
00:56:47,400 --> 00:56:50,342
然后我将这两个东西通过对称加密
And then what I do is I take these two things, 

932
00:56:50,342 --> 00:56:53,850
传递给我的对称加密盒子.
pass them through my symmetric encryption box. 

933
00:57:02,300 --> 00:57:05,250
这将产生密文,
This produces the ciphertext, 

934
00:57:08,475 --> 00:57:16,539
这个加密后的内容
And now this by itself to the sender. \N Sorry, this by itself to the receiver who has the private key 

935
00:57:16,539 --> 00:57:19,739
对拥有公钥的接收者来说并没有什么用处,
corresponding to this public key here, this is not really useful, right? 

936
00:57:19,800 --> 00:57:23,899
因为它用的是本地的对称密钥生成函数生成的
Because this is encrypted with a symmetric cipher with this key K 

937
00:57:23,899 --> 00:57:29,425
密钥K进行对称加密的.
that came from this function that I ran on my local machine. 

938
00:57:29,425 --> 00:57:31,621
因此,我需要用某种方式将这个对称密钥K
So I need some way of getting this

939
00:57:31,621 --> 00:57:34,075
发给用于解密邮件的人.
 to the person who actually used to decrypt the email. 

940
00:57:34,075 --> 00:57:38,950
因此,我将K单独拿出来.这个m可能很大,
And so what I do is I take this thing. And now this email might have been big, 

941
00:57:38,950 --> 00:57:42,125
所以我使用对称加密将其加密.
and I use symmetric encryption with that because symmetric encryption is fast. 

942
00:57:42,125 --> 00:57:45,575
但是这个密钥很小,可能只有256位,
But this key is small, like it might be 256 bits or something, 

943
00:57:45,575 --> 00:57:50,950
所以我可以用公钥对它进行非对称加密,
so I can take this thing and encrypt it with asymmetric encryption using the public key, 

944
00:58:04,550 --> 00:58:07,650
这样就可以生成一个加密密钥.
and this gives me an encrypted key. 

945
00:58:07,800 --> 00:58:16,825
因为那个公钥,这个加密密钥可以使用相应的私钥来解密,
And this thing can be decrypted using the private key corresponding to that public key to reconstruct this. 

946
00:58:16,825 --> 00:58:19,150
这是在发送者端进行的.
So this is on the sender's end. 

947
00:58:19,150 --> 00:58:24,170
现在,接收者获得这个密钥,将倒序进行以下步骤:
Now, the receiver gets this and this and kind of does these things backwards. 

948
00:58:24,170 --> 00:58:25,541
因此,你从加密密钥开始,
So you start with the encrypted key

949
00:58:25,541 --> 00:58:30,405
使用与这个公钥对应的私钥
and use asymmetric decryption using your public using your private key that

950
00:58:30,405 --> 00:58:36,150
来解密这个加密密钥得到K,
corresponds to the posted public key  to reconstruct this key \N that were used for the symmetric encryption box, 

951
00:58:36,150 --> 00:58:40,343
然后使用刚刚解出来的对称密钥K
and then use symmetric key decryption using that key that was reconstructed 

952
00:58:40,343 --> 00:58:44,650
结合密文还原出原始消息.
to take this ciphertext and produce the original message. 

953
00:58:44,750 --> 00:58:47,986
因此,这是对称和非对称加密
So there's a kind of interesting example of how

954
00:58:47,986 --> 00:58:52,300
在实践中结合的有趣例子.
in practice symmetric and asymmetric key cryptography is combined. 

955
00:58:54,475 --> 00:58:55,925
问题?
Question?

956
00:59:00,450 --> 00:59:05,425
那么问题是,在这里你会使用相同的对称密钥生成器吗?
So the question is, will you be using the same symmetric key generators?

957
00:59:07,275 --> 00:59:13,400
是的.因此,你需要事先协商在此处使用哪个盒子{\rcode2}[*]{\r}
Yes. Okay, so you need to kind of agree ahead of time which box you're using here. 
*[也就是使用哪个加密算法啦~]

958
00:59:13,400 --> 00:59:19,450
例如,你可能会说,我将在这里使用AES-256-GCM,
So you might be like, oh, I'm going to use AES-256-GCM up here, 

959
00:59:19,450 --> 00:59:22,500
但这是一个众所周知的函数,
but this is a well-known function, 

960
00:59:22,500 --> 00:59:23,975
它是公开的.
and it's public. 

961
00:59:23,975 --> 00:59:26,950
攻击者可以知道此函数的所有参数.
Like the attackers allowed to know all the parameters this function. 

962
00:59:26,950 --> 00:59:31,025
这是攻击者不知道的唯一秘密.
This is the only secret thing that the attacker doesn't know, the key. 

963
00:59:31,750 --> 00:59:35,399
还有其他问题吗?是的,
Any other questions? Yeah, 

964
00:59:39,124 --> 00:59:40,525
那是一个非常好的问题.
that's a really good question. 

965
00:59:40,525 --> 00:59:42,765
什么样的数据值得加密?
What kind of data is important enough to encrypt?

966
00:59:42,765 --> 00:59:47,050
我认为这取决于你的威胁模型.
And I think that depends on your threat model. 

967
00:59:47,050 --> 00:59:49,060
你担心什么样的攻击者?
Like, who, what kind of attackers are you concerned about?

968
00:59:49,060 --> 00:59:51,300
你想保护什么?
What are you trying to protect against? 

969
00:59:51,300 --> 00:59:55,150
或者,你可能认为你根本什么都不在意,
So you might have the stance that you just don't really care, 

970
00:59:55,150 --> 00:59:58,100
你与任何人的通信都可以公开.
and that like anything you communicate with anybody is allowed to be public. 

971
00:59:58,100 --> 01:00:01,697
我愿意将我与每个人的所有对话
I might be willing to post all my conversation with everybody 

972
01:00:01,697 --> 01:00:03,900
公开发布到互联网上供所有人查看.
for everybody to see publicly on the Internet. 

973
01:00:03,900 --> 01:00:06,780
另一方面,
On the other hand, maybe you're doing some 

974
01:00:06,780 --> 01:00:08,572
也许你正在从事一些非常注重安全性的工作,
like security-sensitive works here, 

975
01:00:08,572 --> 01:00:10,876
比如为美国政府签订合同,
working under a contract for the US government, 

976
01:00:10,876 --> 01:00:13,125
开发一些敏感的军事项目等等.
developing some sensitive military stuff. 

977
01:00:13,125 --> 01:00:15,550
如果你在旅行中通过互联网发送这些信息,
If you're sending that through the open Internet while you're traveling, 

978
01:00:15,550 --> 01:00:18,044
你可能希望非常确定
you probably want to be pretty darn sure that no

979
01:00:18,044 --> 01:00:21,180
没有窃听者或其他人能够看到你发送的内容,
eavesdroppers or anybody else along the way can see what you're sending, 

980
01:00:21,180 --> 01:00:23,550
并且你发送的信息确实到达了正确的位置,
and that whatever you're sending is in fact going to the right place, 

981
01:00:23,550 --> 01:00:27,300
并且接收方能够验证该信息确实来自你.
and that whoever is receiving it can authenticate that it in fact came from you. 

982
01:00:28,475 --> 01:00:32,444
因此,根据你的情况不同,你会担心各种不同类型的对手,
So you might be worried about all different kinds of adversaries depending on your scenario, 

983
01:00:32,444 --> 01:00:33,724
从脚本小子
from random script kiddies 

984
01:00:33,775 --> 01:00:37,400
到国家级攻击者,
who are trying to break into websites to nation-state level attackers, 

985
01:00:37,400 --> 01:00:42,050
你需要不同类型的技术来防御不同类别的攻击者.
and you'll need different types of techniques for defending against the different categories of attackers. 

986
01:00:44,600 --> 01:00:51,850
还有其他问题吗?
Any other questions?

987
01:00:51,850 --> 01:00:54,019
好的,希望明天能看到你们,
Well, so hopefully, see some of you tomorrow

988
01:00:54,019 --> 01:00:58,375
明儿会讲一些我们仨都感兴趣的主题,这些主题之间比较跳跃.
 for a random collection of things that John, Jose,  and I find interesting. 

