1
00:00:00,900 --> 00:00:02,575
好，欢迎回来。
Okay, welcome back.

2
00:00:02,575 --> 00:00:07,600
今天我们将讨论与 Shell 相关的两个主要主题。
Today we're gonna cover kind of a couple separate like two main topics related to the Shell.

3
00:00:07,600 --> 00:00:11,376
首先，我们将进行一些 Shell 脚本编写，主要涉及到 bash，
First, we're gonna do some kind of Shell scripting, mainly related to bash, 

4
00:00:11,376 --> 00:00:18,875
这是大多数人在 Mac 或像大多数 Linux 系统中启动的默认 Shell。
which is the Shell that most of you will start in Mac, or like in most Linux systems, that's the default Shell.

5
00:00:18,875 --> 00:00:22,650
它也与其他 Shell（如 zsh）兼容，非常实用。
And it's also kind of backward compatible through other Shells like zsh, it's pretty nice.

6
00:00:22,650 --> 00:00:26,450
然后，我们将介绍一些其他非常方便的 Shell 工具，
And then we're gonna cover some other Shell tools that are really convenient,

7
00:00:26,450 --> 00:00:29,325
以便您避免执行一些重复的任务，
so you avoid doing like really repetitive tasks,

8
00:00:29,325 --> 00:00:33,350
例如查找某些代码或某些难以找到的文件。
like looking for some piece of code or for some elusive file.

9
00:00:33,400 --> 00:00:36,700
已经有一些内置命令非常有用，
And there are already kind of really nice built-in commands

10
00:00:36,700 --> 00:00:40,550
可以帮助您完成这些任务。
that will really help you to do those things.

11
00:00:40,550 --> 00:00:46,475
昨天，我们已经介绍了 Shell 的一些特性，
So yesterday we already kind of introduced you to the Shell and kind of like it's quirks,

12
00:00:46,475 --> 00:00:50,350
以及如何开始执行命令并将其重定向。
and some like how you start executing commands,redirecting them.

13
00:00:50,375 --> 00:00:57,525
今天，我们将更详细地介绍 Shell 的变量语法、控制流和函数等内容。
Today, we're gonna kind of cover more about like the syntax of more \N like the variables, the control flow,functions of the Shell.

14
00:00:57,575 --> 00:01:03,975
例如，一旦您进入 Shell，您可能想要定义一个变量，
So for example, once you kind of drop into a Shell, say you want to kind of define a variable, 

15
00:01:03,975 --> 00:01:09,250
这是学习编程语言的第一步。
which is kind of one of the first things you learn to do in a programming language.

16
00:01:09,250 --> 00:01:13,125
在这里，您可以执行类似{\rcode}foo=bar`{\r}的操作。
Here you could do something like `foo=bar`.

17
00:01:13,150 --> 00:01:17,775
现在，我们可以通过 "$foo" 来访问 foo 的值。
And now we can access the value of foo by doing "$foo".

18
00:01:18,300 --> 00:01:20,850
这是非常完美的。
And that's "bar", perfect.

19
00:01:20,900 --> 00:01:28,025
需要注意的一个问题是，在处理 bash 时，空格非常关键。
One quirk that you need to be aware of is that spaces are really critical when you're dealing with bash.

20
00:01:28,025 --> 00:01:33,500
主要是因为空格是保留字符，用于分隔参数。
Mainly because spaces are reserved, and that will be for separating arguments.

21
00:01:33,500 --> 00:01:41,950
因此，例如，"foo=bar" 将不起作用，Shell 会告诉您为什么不起作用。
So, for example, something like `foo = bar` won't work, and the Shell is gonna tell you why it's not working. 

22
00:01:41,950 --> 00:01:46,150
这是因为"foo"命令并没有执行，例如“foo"不存在。
It's because the "foo" command is not working, like "foo" is non-existent.

23
00:01:46,150 --> 00:01:49,925
事实上，我们并没有把“foo"分配到“bar"
And here what is actually happening, we're not assigning "foo" to "bar",

24
00:01:49,925 --> 00:01:56,575
换句话说，我们调用“foo"程序时，第一个参数是“="第二个参数是“bar"。
what is happening is we're calling the "foo" program with the first argument "=" and the second argument "bar".

25
00:01:57,400 --> 00:02:03,700
通常情况下，当您遇到一些问题时，例如一些带有空格的文件时，
And in general, whenever you are having some issues, like some files with spaces

26
00:02:03,700 --> 00:02:06,203
需要小心处理。
you will need to be careful about that.

27
00:02:06,203 --> 00:02:10,525
您需要小心引用字符串。
You need to be careful about quoting strings.

28
00:02:10,525 --> 00:02:14,350
因此，我们将讨论在 bash 中如何使用字符串。
So, going into that, how you do strings in bash. 

29
00:02:14,350 --> 00:02:16,700
有两种方法可以定义字符串：
There are two ways that you can define a string:

30
00:02:16,700 --> 00:02:25,000
您可以使用双引号定义字符串，也可以使用单引号（‘’）定义字符串。
You can define strings using double quotes and you can define strings using single,

31
00:02:25,000 --> 00:02:26,275
错辣，
sorry,

32
00:02:26,275 --> 00:02:28,775
是用单引号
using single quotes.

33
00:02:28,800 --> 00:02:32,900
然而，对于文字字符串，它们是等效的，
However, for literal strings they are equivalent,

34
00:02:32,900 --> 00:02:35,550
但对于其他情况则不然。
but for the rest they are not equivalent.

35
00:02:35,550 --> 00:02:43,200
例如，如果我们执行 {\rcode}echo Value is $foo{\r}，
So, for example, if we do `echo Value is $foo `,

36
00:02:43,650 --> 00:02:51,100
则会将 "$foo" 展开为字符串，并将其替换为 Shell中 "foo"的值。
The "$foo" has been kind of expanded like a string substituted to the value of the "foo" variable in the Shell. 

37
00:02:51,125 --> 00:02:58,900
而如果我们使用单引号，则只是获取 "$foo"，
Whereas if we do this with single quotes, we are just getting the "$foo" as it is

38
00:02:58,975 --> 00:03:01,850
而单引号不会进行替换。
and like single quotes won't be replacing.

39
00:03:01,850 --> 00:03:04,354
再次强调，很容易编写一个脚本，
And again,it's really easy to write a script, 

40
00:03:04,354 --> 00:03:08,350
假设这类似于您更熟悉的 Python，
assume that this is kind of like Python, that you might be more familiar with,  

41
00:03:08,350 --> 00:03:10,774
而没有意识到这一点。
and not realize all that.

42
00:03:10,775 --> 00:03:14,350
这是您将赋值变量的方式。
And this is the way you will assign variables.

43
00:03:14,350 --> 00:03:19,925
然后，bash 还具有控制流技术，例如 for 循环、while 循环，
Then bash also has control flow techniques that we'll see later,like for loops, while loops, 

44
00:03:19,925 --> 00:03:23,450
还有一个主要的事情是您可以定义函数。
and one main thing is you can define functions.

45
00:03:23,450 --> 00:03:28,325
我们可以调用我在这里定义的一个函数
And we can access like a function I have defined here.

46
00:03:28,325 --> 00:03:32,400
我们可以访问此处定义的“mcd"函数。
And here we have the "mcd" function, that has been defined, 

47
00:03:32,400 --> 00:03:35,737
目前为止，我们只是演示了
and the thing is, so far, we have just kind of seen 

48
00:03:35,737 --> 00:03:41,200
如何通过将多个命令使用管道传输来执行这些命令。昨天简要介绍了这种方法。
how to execute several commands by piping into them, kind of saw that briefly yesterday.

49
00:03:41,200 --> 00:03:45,150
但是在很多情况下，你会想先执行一件事，然后再做另一件事。
But a lot of times you want to do first one thing and then another thing.

50
00:03:45,150 --> 00:03:51,100
这就像我们在这里看到的按顺序执行的例子一样。
And that's kind of like the sequential execution that we get here.

51
00:03:51,100 --> 00:03:54,075
例如，在这里，我们调用了“mcd"函数。
Here, for example, we're calling the "mcd" function.

52
00:03:54,100 --> 00:04:02,625
我们首先调用mkdir命令来创建这个目录。
And we, first,are calling the mkdir command, which is like creating this directory.

53
00:04:02,625 --> 00:04:06,175
在这里，$1是一种特殊变量。
Here, $1 is like a special variable.

54
00:04:06,175 --> 00:04:12,175
这是Bash的工作方式。在其他脚本语言中，可能会有类似于argv的数组，
This is the way that bash works,whereas in other scripting languages there will be like argv,

55
00:04:12,175 --> 00:04:16,775
其中第一项将包含该参数。
the first item of the array argv will contain the argument.

56
00:04:16,775 --> 00:04:18,125
在Bash中，它表示为$1。
In bash it's $1. 

57
00:04:18,125 --> 00:04:22,320
通常，在Bash中，许多内容都以$加上一些内容为前缀，
And in general, a lot of things in bash will be $ something

58
00:04:22,320 --> 00:04:25,750
表示它们是保留关键字。稍后我们会看到更多例子。
and will be reserved, we will be seeing more examples later.

59
00:04:25,775 --> 00:04:30,675
一旦我们创建了文件夹，我们就进入该文件夹，
And once we have created the folder, we cd into that folder,

60
00:04:30,675 --> 00:04:34,550
这是一种相当常见的模式。
which is kind of a fairly common pattern that you will see.

61
00:04:34,550 --> 00:04:40,400
我们可以在Shell中直接输入这个命令，它会起作用并定义该函数。
We will actually type this directly into our Shell, and it will work  and it will define this function.  

62
00:04:40,450 --> 00:04:45,126
但是，有时将这些内容写入文件会更好。
But sometimes it's nicer to write things in a file.

63
00:04:45,126 --> 00:04:49,801
我们可以使用source命令来执行该脚本
What we can do is we can source this. 

64
00:04:49,801 --> 00:04:54,050
并在我们的Shell中加载它。
And that will execute this script in our Shell and load it.

65
00:04:54,050 --> 00:05:01,475
现在看起来好像什么都没有发生，但是现在“mcd"函数已经在我们的Shell中定义了。
So now it looks like nothing happened, but now the "mcd" function has been defined in our Shell. 

66
00:05:01,525 --> 00:05:05,225
因此，我们现在可以执行“mcd test"命令，
So we can now for example do like "mcd test", 

67
00:05:05,225 --> 00:05:09,675
然后我们从tools目录移动到test目录。
and now we move from the tools directory to the test directory. 

68
00:05:09,675 --> 00:05:13,675
我们先创建了文件夹，然后进入了它。
We both created the folder and we moved into it.

69
00:05:15,450 --> 00:05:18,875
还有什么？
What else. So a result is...

70
00:05:18,875 --> 00:05:22,275
我们可以使用$1来访问第一个参数。
We can access the first argument with $1.

71
00:05:22,275 --> 00:05:26,475
还有很多保留命令，
There's a lot more kind of  reserved commands for example,

72
00:05:26,475 --> 00:05:29,950
例如$0表示脚本的名称，
$0 will be the name of the script,

73
00:05:29,950 --> 00:05:37,125
$2到$9将是Bash脚本接收的第二到第九个参数。
$2 through $9 will be the second through the ninth arguments that the bash script takes.  

74
00:05:37,125 --> 00:05:42,225
其中一些保留关键字可以直接在Shell中使用，
Some of these reserved keywords can be directly used in the Shell, 

75
00:05:42,225 --> 00:05:50,300
例如“$?"可以获取上一个命令的错误代码，
so for example "$?" will get you the error code from the previous command,

76
00:05:50,300 --> 00:05:53,900
这个我也会简要解释一下。
which I'll also explain briefly.

77
00:05:53,900 --> 00:05:59,275
但例如“$_"可以获取上一个命令的最后一个参数。
But for example, "$_ " will get you the last argument of the previous command.

78
00:05:59,275 --> 00:06:07,325
因此，我们也可以这样做，例如使用“mkdir test"，
So another way we could have done this is we could have said like "mkdir test"

79
00:06:07,325 --> 00:06:14,282
而不需要重复输入test，我们可以使用$_作为上一个命令的一部分来访问上一个参数，
and instead of rewriting test, we can access that last argument as part of the (previous command),

80
00:06:14,282 --> 00:06:22,675
这样它将被替换为test，然后我们进入test。
using $_ ,like that will be replaced with test and now we go into test.

81
00:06:24,825 --> 00:06:27,675
还有很多这样的命令，你应该熟悉它们。
There are a lot of them, you should familiarize with them.

82
00:06:27,675 --> 00:06:31,975
我经常使用的另一个命令叫做"bang bang"（"!!"），
Another one I often use is kind of is called "bang bang" ("!!"), 

83
00:06:31,975 --> 00:06:36,650
当你尝试创建某些东西时你会遇到它。
you will run into this whenever you, for example, are trying to create something 

84
00:06:36,675 --> 00:06:38,775
但你没有足够的权限，
and you don't have enough permissions. 

85
00:06:38,775 --> 00:06:46,825
然后，你可以执行“sudo !!"命令，然后它将替换其中的命令，现在你可以尝试执行该命令。
Then, you can do "sudo !!" and then that will replace the command in there and now you can just try doing that. 

86
00:06:46,825 --> 00:06:50,000
现在它会提示你输入密码，因为你拥有sudo权限。
And now it will prompt you for a password,because you have sudo permissions.

87
00:06:53,550 --> 00:06:57,300
之前，我提到了错误命令。
Before, I mentioned the, kind of the error command.

88
00:06:57,300 --> 00:07:00,958
昨天我们提到，进程可以通过不同的方式
Yesterday we saw that, in general, there are different ways 

89
00:07:00,958 --> 00:07:04,825
与其他进程或命令进行通信。
a process can communicate with other processes or commands.

90
00:07:04,825 --> 00:07:07,709
我们提过标准输入，
We mentioned the standard input, 

91
00:07:07,709 --> 00:07:13,900
这个不像从标准输入中读取或是向标准输出输出
which also was less than like getting stuff through the standard input, putting stuff into the standard output.

92
00:07:13,900 --> 00:07:18,250
这里有很多有意思的东西，像是标准错误流
There are a couple more interesting things, there's also like a standard error,

93
00:07:18,250 --> 00:07:21,858
它用于在程序编写时输出错误信息，
a stream where you write errors that happen with your program 

94
00:07:21,858 --> 00:07:24,075
以避免污染标准输出。
and you don't want to pollute the standard output.

95
00:07:24,075 --> 00:07:29,365
还有一个错误代码，这是许多编程语言中通用的东西，
There's also the error code, which is like a general thing in a lot of programming languages, 

96
00:07:29,365 --> 00:07:34,700
可以报告程序的整体运行情况。
some way of reporting how the entire run of something went.

97
00:07:34,700 --> 00:07:43,275
因此，如果我们执行像"echo hello"这样的命令，并且检查其错误代码，它将为零。
So if we do  something like echo hello and we query for the value, it's zero.

98
00:07:43,325 --> 00:07:46,850
这是因为一切都很顺利，没有出现任何问题。
And it's " zero" because everything went okay and there weren't any issues. 

99
00:07:46,850 --> 00:07:51,916
“0"的退出代码与C语言中的退出代码相同，
And a "0" exit code is the same as you will get in a language like c, 

100
00:07:51,925 --> 00:07:54,900
例如“0"表示一切顺利，没有错误。
like "0" means everything went fine, there were no errors.

101
00:07:54,900 --> 00:07:57,450
但是，有时事情并不按照我们预期的方式进行。
However, sometimes things won't work.

102
00:07:57,450 --> 00:08:04,850
例如，如果我们在“mcd"脚本中使用"grep foobar"命令，
Sometimes, like if we try to grep for foobar in our "mcd" script,

103
00:08:04,850 --> 00:08:07,800
然后检查其错误代码，它将为1。
and now we check for that value, it's "1". 

104
00:08:07,800 --> 00:08:13,900
这是因为我们试图在“mcd"脚本中搜索"foobar"字符串，但是该字符串不存在。
And that's because we tried to search for the foobar string in the "mcd" script and it wasn't there.

105
00:08:13,900 --> 00:08:21,875
因此，grep不会输出任何内容，但是通过返回一个1的错误代码告诉我们发生了错误。
So grep doesn't print anything, but let us know that things didn't work by giving us a "1" error code.

106
00:08:21,925 --> 00:08:30,550
还有一些有趣的命令，比如"true"，它的错误代码始终为“0"，
There are some interesting commands like "true", for example, will always have a "0" error code, 

107
00:08:30,550 --> 00:08:35,075
而"false"的错误代码始终为1。
and "false" will always have a "1" error code.

108
00:08:35,075 --> 00:08:43,150
通过使用这些逻辑运算符，我们可以执行某些条件语句。
Then there are like these logical operators that you can use to do some sort of conditionals for example

109
00:08:43,150 --> 00:08:46,600
例如，你还可以用If和ELSE，这个我们稍后再说
one way...you also have IF's and ELSE's, that we will see later, 

110
00:08:46,600 --> 00:08:52,250
你可以输入一些命令，例如“false"或者“echo 'Oops fail'"
But you can do something like "false", and 'echo "Oops fail" '.

111
00:08:52,250 --> 00:08:56,300
这里，我们使用"OR"运算符连接两个命令
So here we have two commands connected by this OR operator.

112
00:08:56,300 --> 00:09:00,725
然后在这里，bash会执行第一个命令
What bash is gonna do here, it's gonna execute the first one

113
00:09:00,725 --> 00:09:06,075
如果第一个命令失败，则Bash将执行第二个命令。
and if the first one didn't work, then it's gonna execute the second one. 

114
00:09:06,075 --> 00:09:10,475
例如，一种方式是使用"OR"运算符连接两个命令，
So here we get it,because it's gonna try to do a logical OR. 

115
00:09:10,475 --> 00:09:14,525
如果第一个命令失败，则Bash将执行第二个命令。
If the first one didn't have a "0" error code, it's gonna try to do the second one. 

116
00:09:14,525 --> 00:09:19,675
同样的，如果我们不用“false",我们用“true"
Similarly, if we instead of use "false", we use something like "true",

117
00:09:19,675 --> 00:09:26,900
因为执行“true"不会报错，第二个命令就会跳过并且不会打印出来
since "true" will have a "0" error code, then the second one will be short-circuited and it won't be printed.

118
00:09:32,425 --> 00:09:41,450
同样，使用"AND"运算符连接两个命令时，只有在第一个命令没有错误的情况下才会执行第二个命令。
Similarly, we have an AND operator which will only execute the second part if the first one ran without errors.

119
00:09:42,175 --> 00:09:45,100
和之前一样，
And the same thing will happen.

120
00:09:45,100 --> 00:09:49,825
如果第一个命令失败，则Bash将不会执行第二个命令。
If the first one fails, then the second part of this thing won't be executed.

121
00:09:50,425 --> 00:09:56,125
此外，无论执行什么命令，
Kind of not exactly related to that, but another thing that you will see is

122
00:10:01,400 --> 00:10:05,062
都可以使用分号将它们连接在同一行中，
that no matter what you execute, then you can concatenate commands

123
00:10:05,062 --> 00:10:09,137
并将它们打印出来。
using a semicolon in the same line,and that will always print.

124
00:10:09,975 --> 00:10:19,475
除此之外,例如我们还没有看到如何将一个命令的输出存储到一个变量中.
Beyond that, what we haven't seen, for example, is how you go about getting the output of a command into a variable.

125
00:10:19,475 --> 00:10:24,300
我们可以通过像这样做来实现.
And the way we can do that is doing something like this.

126
00:10:24,300 --> 00:10:29,451
在这里,我们获取了PWP命令的输出,
What we're doing here is we're getting the output of the PWD command,

127
00:10:29,451 --> 00:10:33,900
该命令只是打印我们现在所在的当前工作目录,
which is just printing the present working directory where we are right now.

128
00:10:33,900 --> 00:10:37,175
然后将其存储到foo变量中.
And then we're storing that into the foo variable.

129
00:10:37,175 --> 00:10:42,575
所以我们这样做,然后我们要求foo,我们查看我们的字符串.
So we do that and then we ask for foo, we view our string.

130
00:10:42,575 --> 00:10:51,725
更一般地说,我们可以通过将它放入任何字符串中来执行这个被称为命令替换的事情.
More generally, we can do this thing called command substitution by putting it into any string.

131
00:10:51,725 --> 00:10:55,515
由于我们使用的是双引号而不是单引号,
And since we're using double quotes instead of single quotes

132
00:10:55,515 --> 00:11:02,450
这个东西将被扩展,并告诉我们我们在这个工作文件夹中.
that thing will be expanded and it will tell us that we are in this working folder.

133
00:11:02,450 --> 00:11:13,375
另一个有趣的事情是,现在,这个东西正在扩展为一个字符串,而不是它只是扩展为一个字符串.
Another interesting thing is, right now, what this is expanding to is a string instead of kind of it's just expanding as a string.

134
00:11:13,375 --> 00:11:19,867
另一个巧妙而不那么知名的工具称为进程替换,它有点类似.
Another nifty and lesser known tool is called process substitution which is kind of similar. 

135
00:11:19,867 --> 00:11:20,975
怎么做呢。。。
What it will do...

136
00:11:24,025 --> 00:11:31,350
它会在这里,例如,"<",一些命令和另一个括号,
it will, here for example, the "<", some command and another parenthesis,

137
00:11:31,350 --> 00:11:34,750
它会执行,将输出放到
what that will do is: that will execute, that will get the output to

138
00:11:34,750 --> 00:11:39,525
一个类似临时文件的东西中,并将文件句柄提供给命令.
kind of like a temporary file and it will give the file handle to the command.

139
00:11:39,650 --> 00:11:42,500
所以在这里,我们正在获取...
So here what we're doing is we're getting...

140
00:11:42,500 --> 00:11:45,800
我们正在对目录进行LS,
we're LS'ing the directory, putting it into a temporary file,

141
00:11:45,800 --> 00:11:50,500
将其放入一个临时文件中,对父文件夹做同样的事情,然后将两个文件连接起来.
doing the same thing for the parent folder and then we're concatenating both files. 

142
00:11:50,500 --> 00:11:57,825
这可能非常方便,因为一些命令不是期望从stdin中获得输入,
And this will, may be really handy, because some commands instead of expecting the input coming from the stdin,

143
00:11:57,950 --> 00:12:03,575
而是期望来自某些文件,这些文件提供了一些参数.
they are expecting things to come from some file that is giving some of the arguments.

144
00:12:04,725 --> 00:12:08,150
所以我们得到了两个连接在一起的东西.
So we get both things concatenated.

145
00:12:11,000 --> 00:12:15,238
我认为到目前为止有很多信息,
I think so far there's been a lot of information, 

146
00:12:15,238 --> 00:12:22,800
让我们看一个简单的示例脚本,在其中我们看到了一些这些东西.
let's see a simple, an example script where we see a few of these things.

147
00:12:22,800 --> 00:12:29,475
所以例如在这里我们有一个字符串和一个"$(date)".
So for example here we have a string and we have this "$(date)". 

148
00:12:29,475 --> 00:12:31,050
所以"$(date)"是一个程序.
So $(date) is a program.

149
00:12:31,050 --> 00:12:36,050
UNIX中有很多程序,你将逐渐熟悉其中的很多.
Again there's a lot of programs in UNIX you will kind of slowly familiarize with a lot of them.

150
00:12:36,050 --> 00:12:41,800
日期只是打印当前日期,您可以指定不同的格式.
Date just prints what the current date is and you can specify different formats.

151
00:12:41,800 --> 00:12:47,673
接下来,我们有这些"$0".
Then, we have these "$0" here. 

152
00:12:47,673 --> 00:12:50,525
"$0"是我们正在运行的脚本的名称.
"$0" is the name of the script that we're running.

153
00:12:50,525 --> 00:12:57,575
然后我们有"$#",这是我们给该命令的参数数量,
Then we have "$#", that's the number of arguments that we are giving to the command,

154
00:12:57,625 --> 00:13:02,325
然后"$$"是正在运行的该命令的进程ID.
and then "$$" is the process ID of this command that is running.

155
00:13:02,325 --> 00:13:06,500
再次提醒,有很多这些美元符号,它们不直观,
Again, there's a lot of kind of these dollar things, they're not intuitive 

156
00:13:06,500 --> 00:13:10,175
因为它们没有一种助记的记忆方式,比如"$#".
because they don't have like a mnemonic way of remembering, maybe, "$#".

157
00:13:10,175 --> 00:13:14,525
但是你会逐渐熟悉它们.
But it can be... you will just be seeing them and getting familiar with them.

158
00:13:14,525 --> 00:13:19,175
这里我们有"$@",它将展开为所有的参数.
Here we have this "$@", and that will expand to all the arguments.

159
00:13:19,175 --> 00:13:26,100
因此,我们不必假定可能有三个参数并编写$1,$2,$3,
So, instead of having to assume that, maybe say, we have three arguments and writing $1, $2, $3,

160
00:13:26,100 --> 00:13:29,925
如果我们不知道有多少参数,我们可以将所有这些参数放在那里.
if we don't know how many arguments we can put all those arguments there.

161
00:13:29,925 --> 00:13:33,153
然后将其传递给for循环.
And that has been given to a for loop. 

162
00:13:33,153 --> 00:13:43,950
for循环将在一段时间内获取文件变量,并将每个参数逐一传递.
And the for loop will, in time, get the file variable and it will be giving each one of the arguments.

163
00:13:43,950 --> 00:13:48,100
因此,我们为每个参数提供.
So what we're doing is, for every one of the arguments we're giving.

164
00:13:48,100 --> 00:13:53,612
接下来,在下一行中,我们运行grep命令,
Then, in the next line we're running the grep command

165
00:13:53,612 --> 00:14:01,450
它只是在某个文件中搜索子字符串,并在文件中搜索字符串foobar.
which is just search for a substring in some file and we're searching for the string foobar in the file.

166
00:14:01,450 --> 00:14:06,413
这里,我们将文件所取的变量放在了展开中.
Here, we have put the variable that the file took, to expand.

167
00:14:06,413 --> 00:14:11,484
昨天,我们了解了如果我们关心程序的输出,
And yesterday we saw that if we care about the output of a program,

168
00:14:11,484 --> 00:14:16,200
我们可以将其重定向到某个地方,以保存它或连接到其他文件.
we can redirect it to somewhere to save it or to connect it to some other file.

169
00:14:16,200 --> 00:14:19,075
但是有时候我们想要相反的效果.
But sometimes you want the opposite.

170
00:14:19,075 --> 00:14:21,225
有时,例如在这里,我们关注...
Sometimes, here for example, we care...

171
00:14:21,225 --> 00:14:23,175
我们需要关注错误代码.
we're gonna care about the error code. 

172
00:14:23,175 --> 00:14:28,200
对于这个脚本,我们需要关心grep命令是否成功运行.
About this script, we're gonna care whether the grep ran successfully or it didn't.

173
00:14:28,200 --> 00:14:33,661
因此,我们实际上可以完全忽略输出就像...
So we can actually discard entirely what the output like

174
00:14:33,661 --> 00:14:37,825
就像grep命令的标准输出和标准错误一样.
both the standard output and the standard error of the grep command.

175
00:14:37,825 --> 00:14:42,925
我们要做的是将输出重定向到/dev/null,
And what we're doing is we're redirecting the output to /dev/null 

176
00:14:42,925 --> 00:14:50,550
这是UNIX系统中的一种特殊设备,
which is kind of like a special device in UNIX systems where you can like write and it will be discarded. 

177
00:14:50,550 --> 00:14:54,500
您可以像写入文件一样写入数据,但它将被丢弃.
Like you can write no matter how much you want there, and it will be discarded. 

178
00:14:54,500 --> 00:15:00,225
这里有一个">"符号,我们昨天讨论过它用于重定向输出.
And here's the ">" symbol that we saw yesterday for redirecting output. 

179
00:15:00,375 --> 00:15:05,500
这里有一个"2>",正如一些人可能已经猜到的那样,
Here you have a "2>" and, as some of you might have guessed by now, 

180
00:15:05,500 --> 00:15:07,550
这是用于重定向标准错误的,
this is for redirecting the standard error, 

181
00:15:07,550 --> 00:15:10,275
因为这两个流是分开的,
because those two streams are separate, 

182
00:15:10,300 --> 00:15:14,750
您需要告诉bash如何处理它们.
and you kind of have to tell bash what to do with each one of them.

183
00:15:14,750 --> 00:15:18,300
所以在这里,我们检查文件是否包含foobar,
So here, we run, we check if the file has foobar, 

184
00:15:18,300 --> 00:15:22,575
如果文件包含foobar,它将具有零代码.
and if the file has foobar then it's going to have a "0" code. 

185
00:15:22,575 --> 00:15:25,750
如果没有foobar,它将具有非零错误代码.
If it doesn't have foobar, it's gonna have a nonzero error code. 

186
00:15:25,750 --> 00:15:28,125
因此,这正是我们检查的内容.
So that's exactly what we check in this 

187
00:15:28,125 --> 00:15:33,050
在这个if命令的一部分中,我们说"get me the error code".
If part of the command we say "get me the error code". 

188
00:15:33,050 --> 00:15:35,250
再次使用"$？"
Again, this "$?".

189
00:15:35,300 --> 00:15:37,700
然后我们有一个比较运算符——
And then we have a comparison operator

190
00:15:37,700 --> 00:15:39,800
"-ne",表示"不相等".
which is "-ne", for "non equal". 

191
00:15:39,800 --> 00:15:47,450
有些其他编程语言将有"=="、"！="这些符号.
And some other programming languages will have "==", "!=", 

192
00:15:47,450 --> 00:15:53,550
在bash中有一组保留的比较,
these symbols in bash there's like a reserved set of comparisons 

193
00:15:53,550 --> 00:15:57,675
这主要是因为您可能需要测试很多东西
and it's mainly because there's a lot of things you might want to test for 

194
00:15:57,675 --> 00:15:58,575
当您在shell中进行测试时,
when you're in the Shell. 

195
00:15:58,575 --> 00:16:03,800
例如,在这里,我们只是检查两个整数值是否相同.
Here for example we're just checking for two values, two integer values, being the same. 

196
00:16:03,800 --> 00:16:10,050
或者例如在这里,"-f"检查将让我们知道文件是否存在,
Or for example here, the "-f" check will let us know if a file exists, 

197
00:16:10,150 --> 00:16:13,800
这是您经常会遇到的一些事情.
which is something that you will run into very,very commonly. 

198
00:16:14,625 --> 00:16:18,450
我回到这个例子.
I'm going back to the example. 

199
00:16:18,450 --> 00:16:30,325
当文件没有foobar时会发生什么,例如存在非零错误代码,
Then, what happens when we,if the file did not have foobar, like there was a nonzero error code,

200
00:16:30,325 --> 00:16:34,650
则会打印"this file doesn't have any foobar,we're going to add one".
then we print "this file doesn't have any foobar,we're going to add one". 

201
00:16:34,650 --> 00:16:42,350
我们所做的是回显这个"# foobar"，希望这是对文件的注释，
And what we do is we echo this "# foobar", hoping this is a comment to the file 

202
00:16:42,350 --> 00:16:48,350
然后我们使用运算符">>"在文件末尾追加。
and then we're using the operator ">>" to append at the end of the file. 

203
00:16:48,350 --> 00:16:52,450
因为文件已经被送入脚本,
Here since the file has been fed through the script, 

204
00:16:52,450 --> 00:16:57,250
我们之前不知道它,因此我们必须替换文件名变量.
and we don't know it beforehand, we have to substitute the variable of the filename. 

205
00:16:58,025 --> 00:17:02,000
我们可以实际运行这个脚本.
We can actually run this. 

206
00:17:02,000 --> 00:17:07,900
我们已经在这个脚本中具有正确的权限,我们可以举出一些例子.
We already have correct permissions in this script and we can give a few examples. 

207
00:17:07,900 --> 00:17:13,950
在此文件夹中,我们有一些文件,"mcd"是我们在开头看到的"mcd"函数,
We have a few files in this folder, "mcd" is the one we saw at the beginning for the "mcd" function, 

208
00:17:13,950 --> 00:17:20,175
还有一些其他的"script"函数,我们甚至可以将自己的脚本输入到自己中,
some other "script" function and we can even feed the own script to itself to check 

209
00:17:20,175 --> 00:17:21,850
以检查它是否包含foobar.
if it has foobar in it.

210
00:17:22,150 --> 00:17:27,950
然后我们运行它,首先可以看到不同变量.
And we run it and first we can see that there's different variables that we saw, 

211
00:17:27,950 --> 00:17:31,575
并且这些变量是已成功扩展的
that have been successfully expanded. 

212
00:17:31,575 --> 00:17:36,350
我们有日期,已经被替换为当前时间,
We have the date, that has been replaced to the current time, 

213
00:17:36,350 --> 00:17:40,125
然后我们用三个参数运行这个程序,
then we're running this program, with three arguments, 

214
00:17:40,125 --> 00:17:44,400
用随机生成的PID
this randomized PID, 

215
00:17:44,400 --> 00:17:48,550
,然后它告诉我们"mcd"没有任何foobar,所以我们正在添加一个新的,
and it's telling us "mcd" doesn't have any foobar, so we are adding a new one,

216
00:17:48,550 --> 00:17:51,025
这个脚本文件没有一个foobar.
and this script file doesn't have one. 

217
00:17:51,025 --> 00:17:56,025
现在让我们举一个例子来看"mcd",它有我们需要的注释.
So now for example let's look at "mcd" and it has the comment that we were looking for.

218
00:17:58,875 --> 00:18:04,750
当你执行脚本时,还有一件事需要知道,
One other thing to know when you're executing scripts 

219
00:18:04,750 --> 00:18:09,000
就是这里有三个完全不同的参数,
is that here we have like three completely different arguments 

220
00:18:09,000 --> 00:18:12,875
但通常你会给出一些更简洁的参数.
but very commonly you will be giving arguments that can be more succinctly given in some way.

221
00:18:12,875 --> 00:18:16,600



222
00:18:16,675 --> 00:18:25,200
例如,在这里,如果我们想引用所有的".sh"脚本,
So for example here if we wanted to refer to all the ".sh" scripts 

223
00:18:25,200 --> 00:18:31,000
我们可以做一些像"ls *.sh"的事情,
we could just do something like "ls *.sh"

224
00:18:31,000 --> 00:18:37,250
这是大多数shell都有的一种称为"globbing"的文件名扩展方式.
and this is a way of filename expansion that most Shells have that's called "globbing". 

225
00:18:37,275 --> 00:18:40,925
在这里,正如你所期望的,
Here, as you might expect, this is gonna say anything 

226
00:18:40,925 --> 00:18:45,125
这将显示任何具有任何字符并以"sh"结尾的内容.
that has any kind of sort of characters and ends up with "sh".

227
00:18:46,600 --> 00:18:50,750
毫不奇怪,我们得到了"example.sh"和"mcd.sh".
Unsurprisingly, we get "example.sh" and "mcd.sh". 

228
00:18:50,775 --> 00:18:54,050
我们还有这些"project1"和"project2",
We also have these "project1" and "project2", 

229
00:18:54,050 --> 00:18:56,050
如果有一个...
and if there were like a... 

230
00:18:56,050 --> 00:19:00,375
我们可以做一个"project42",
we can do a "project42", for example

231
00:19:00,375 --> 00:19:03,559
例如,现在如果我们只想引用具有一个字符的项目,
And now if we just want to refer to the projects 

232
00:19:03,559 --> 00:19:10,400
但后面没有两个字符,像任何其他字符一样,我们可以使用问号.
that have a single character, but not two characters afterwards, like any other characters,we can use the question mark. 

233
00:19:10,400 --> 00:19:14,375
所以"？"将扩展为只有一个.
So "?" will expand to only a single one.

234
00:19:14,375 --> 00:19:20,525
通常情况下,globbing可以非常强大.你也可以结合使用.
In general, globbing can be very powerful. You can also combine it.

235
00:19:20,525 --> 00:19:27,700
另一种情况也很强大，我们同样可以结合使用
Another kind of the will be very powerful,and we can also combine it.

236
00:19:32,325 --> 00:19:36,025
一个常见的模式是使用所谓的花括号.
A common pattern is to use what is called curly braces.

237
00:19:36,050 --> 00:19:39,525
假设我们有一个图像,在这个文件夹中,
So let's say we have an image, that we have in this folder

238
00:19:39,525 --> 00:19:43,850
我们想将这个图像从PNG转换为JPG,
and we want to convert this image from PNG to JPG

239
00:19:43,850 --> 00:19:45,975
或者我们可以复制它,
or we could maybe copy it, 

240
00:19:45,975 --> 00:19:49,625
或者说，这是一个非常常见的模式,有两个或更多相似的参数,
or it's a really common pattern, to have two or more arguments 

241
00:19:49,625 --> 00:19:55,150
你想将它们作为参数传递给某个命令.
that are fairly similar and you want to do something with them as arguments to some command.

242
00:19:55,150 --> 00:20:08,850
你可以这样做,或者更简洁地说,你可以只是做"image.{png,jpg}".
You could do it this way, or more succinctly, you can just do "image.{png,jpg}"

243
00:20:08,850 --> 00:20:17,575
在这里,我得到了一些颜色反馈,但这将扩展为上面的行.
And here, I'm getting some color feedback, but what this will do, is expand into the line above.

244
00:20:17,575 --> 00:20:23,175
实际上,我可以让zsh替我做到这一点.
Actually, I can ask zsh to do that for me and that what's happening here.

245
00:20:24,600 --> 00:20:26,125
这真的很强大.
This is really powerful. 

246
00:20:26,150 --> 00:20:28,475
例如,你可以做一些像...
So for example you can do something like... 

247
00:20:28,475 --> 00:20:34,250
我们可以在一堆foo上做"touch",所有这些都会被扩展.
we could do "touch" on a bunch of foo's, and all of this will be expanded.

248
00:20:35,950 --> 00:20:42,425
你还可以在几个级别上做到这一点,你将做笛卡尔...
You can also do it at several levels and you will do the Cartesian...

249
00:20:44,000 --> 00:20:48,650
如果我们有这样的东西,我们有一个组在这里,
if we have something like this, we have one group here, 

250
00:20:48,750 --> 00:20:52,625
"{1,2}",然后这里有"{1,2,3}",
"{1,2}" and then here there's "{1,2,3}", 

251
00:20:52,625 --> 00:20:56,600
这将对这两个扩展的笛卡尔积进行扩展,
and this is going to do the Cartesian product of these two expansions 

252
00:20:56,600 --> 00:21:03,425
并将扩展为所有这些东西,我们可以快速地"touch".
and it will expand into all these things,that we can quickly "touch".

253
00:21:03,450 --> 00:21:10,825
你还可以将星号glob与花括号glob结合使用.
You can also combine the asterisk glob with the curly braces glob.

254
00:21:10,875 --> 00:21:13,900
你甚至可以使用类似于区间的东西.
You can even use kind of ranges.

255
00:21:13,900 --> 00:21:16,910
比如,我们可以做"mkdir",
 Like, we can do "mkdir"

256
00:21:16,910 --> 00:21:20,025
并创建"foo"和"bar"目录,
and we create the "foo" and the "bar" directories, 

257
00:21:20,075 --> 00:21:25,275
然后我们可以做类似这样的事情.
and then we can do something along these lines. 

258
00:21:25,275 --> 00:21:31,700
这将会扩展到 "fooa", "foob"... 所有这些组合,一直到 "j",
This is going to expand to "fooa", "foob" like all these combinations, through "j", 

259
00:21:31,725 --> 00:21:34,275
然后对于 "bar" 同样如此.
and then the same for "bar". 

260
00:21:34,375 --> 00:21:40,150
我还没有真正测试过它... 但是是的,我们得到了所有这些我们可以"touch"的组合.
I haven't really tested it... but yeah, we're getting all these combinations that we can "touch".

261
00:21:40,150 --> 00:21:47,700
现在,如果我们接触到这两个目录之间不同的东西,
And now, if we touch something that is different between these two (directories), 

262
00:21:47,700 --> 00:21:56,326
我们可以再次展示我们之前看到的过程替换.
we can again showcase the process substitution that we saw earlier. 

263
00:21:56,326 --> 00:22:00,450
比如我们想检查这两个文件夹之间有哪些文件不同.
So  we want to check what files are different between these two folders.

264
00:22:00,450 --> 00:22:03,425
对于我们来说很明显,我们刚刚看到了,是 X 和 Y,
For us it's obvious, we just saw it, it's X and Y,

265
00:22:03,425 --> 00:22:09,900
但是我们可以要求 shell 在一个 LS 的输出和另一个 LS 的输出之间进行"diff".
but we can ask the Shell to do this "diff" for us between the output of one LS and the other LS.

266
00:22:09,900 --> 00:22:18,375
毫不奇怪,我们得到的结果是:X 只存在于第一个文件夹中,而 Y 只存在于第二个文件夹中.
Unsurprisingly we're getting: X is only in the first folder and Y is only in the second folder. 

267
00:22:20,275 --> 00:22:25,400
更多的是,我们现在只看到了 bash 脚本.
What is more is, right now, we have only seen bash scripts. 

268
00:22:25,400 --> 00:22:31,600
如果你喜欢其他脚本,对于某些任务,bash 可能不是最好的,可能会很棘手.
If you like other scripts, like for some tasks bash is probably not the best,it can be tricky. 

269
00:22:31,600 --> 00:22:36,875
你实际上可以编写与以许多不同语言实现的 shell 交互的脚本.
You can actually write scripts that interact with the Shell implemented in a lot of different languages. 

270
00:22:36,875 --> 00:22:39,075
所以,例如,让我们看一下一个 Python 脚本,
So for example, let's see here a

271
00:22:39,075 --> 00:22:46,025
在开头有一个魔法行,我现在不解释.
Python script that has a magic line at the beginning that I'm not explaining for now.

272
00:22:46,025 --> 00:22:48,350
然后我们有"import sys",
Then we have "import sys",

273
00:22:48,350 --> 00:22:49,737
它有点像...... 
it's kind of like... 

274
00:22:49,737 --> 00:22:57,900
Python 默认情况下不会尝试与 shell 交互,所以你需要导入一些库.
Python is not, by default, trying to interact with the Shell so you will have to import some library. 

275
00:22:57,900 --> 00:23:06,624
然后我们正在做一件非常愚蠢的事情,就是迭代"sys.argv [1:]".
And then we're doing a really silly thing of just iterating over "sys.argv[1:]".

276
00:23:06,675 --> 00:23:13,150
"sys.argv" 有点类似于在 bash 中我们得到的 $0,$1 等,
"sys.argv" is kind of similar to what in bash we're getting as $0, $1,etc

277
00:23:13,150 --> 00:23:17,250
就像参数向量一样,我们将其按相反的顺序打印出来.
Like the vector of the arguments, we're printing it in the reversed order.

278
00:23:17,500 --> 00:23:22,300
开头的魔法行叫做 shebang,
And the magic line at the beginning is called a shebang 

279
00:23:22,300 --> 00:23:26,525
是 shell 知道如何运行这个程序的方式.
and is the way that the Shell will know how to run this program.

280
00:23:26,525 --> 00:23:33,575
你总是可以做一些像"python script.py"这样的事情,然后"a b c",
You can always do something like "python script.py", and then "a b c" 

281
00:23:33,600 --> 00:23:36,300
这样始终可以运行.
 and that will work, always, like that. 

282
00:23:36,300 --> 00:23:40,925
但是,如果我们想让它在 shell 中可执行呢？ 
But what if we want to make this to be executable from the Shell? 

283
00:23:40,925 --> 00:23:50,450
shell 知道它必须使用 python 作为解释器来运行此文件的方式是使用那个第一行.
The way the Shell knows that it has to use python as the interpreter to run this file is using that first line. 

284
00:23:50,550 --> 00:23:56,275
那第一行给它的是这个东西所在的路径.
And that first line is giving it the path to where that thing lives.

285
00:23:58,325 --> 00:24:00,225
但是,你可能不知道.
However, you might not know,like, 

286
00:24:00,225 --> 00:24:04,100
不同的机器可能会将 python 放在不同的位置,
different machines will have probably different places where they put python

287
00:24:04,100 --> 00:24:09,243
你可能不想假设 python 安装在哪里,或者其他解释器.
and you might not want to assume where python is installed, or any other interpreter.

288
00:24:09,243 --> 00:24:17,525
所以你可以使用"env"命令.
So one thing that you can do is use the "env" command.

289
00:24:17,525 --> 00:24:21,598
你也可以在 shebang 中给出参数,
You can also give arguments in the shebang, 

290
00:24:21,598 --> 00:24:26,273
所以我们在这里指定运行"env"命令,
so what we're doing here is specifying run the "env" command, 

291
00:24:26,273 --> 00:24:29,550
对于几乎所有系统来说,有一些例外,
that is for pretty much every system, there are some exceptions, 

292
00:24:29,550 --> 00:24:34,375
但是对于几乎所有系统来说,它都在"usr/bin"中,那里有很多二进制文件,
but like for pretty much every system it's is in "usr/bin", where a lot of binaries live,

293
00:24:34,375 --> 00:24:37,450
然后我们用参数"python"调用它
and then we're calling it with the argument "python". 

294
00:24:37,450 --> 00:24:43,625
然后它将利用我们在第一节课上学到的路径环境变量.
And then that will make use of the path environment variable that we saw in the first lecture. 

295
00:24:43,625 --> 00:24:46,500
它将在该路径中搜索Python二进制文件,
It's gonna search in that path for the Python binary 

296
00:24:46,500 --> 00:24:49,875
然后使用它来解释该文件.
and then it's gonna use that to interpret this file. 

297
00:24:49,875 --> 00:24:51,704
这将使得它更具可移植性,
And that will make this more portable 

298
00:24:51,704 --> 00:24:56,854
因此可以在我的电脑、你的电脑和其他电脑上运行.
so it can be run in my machine, and your machine and some other machine.

299
00:25:08,500 --> 00:25:14,350
另一件事是,Bash并不像现代化,
Another thing is that the bash is not really like modern, 

300
00:25:14,350 --> 00:25:16,025
它是一段时间以前开发的.
it was developed a while ago. 

301
00:25:16,025 --> 00:25:18,375
有时调试起来可能会很棘手.
And sometimes it can be tricky to debug. 

302
00:25:18,375 --> 00:25:23,475
默认情况下,有些故障可能不太直观,
By default, and the ways it will fail sometimes are intuitive 

303
00:25:23,475 --> 00:25:28,500
例如我们之前看到的foo命令不存在的方式,有时则不然.
like the way we saw before of like foo command not existing, sometimes it's not. 

304
00:25:28,500 --> 00:25:35,600
因此,在课堂笔记中我们提供了一个非常方便的工具,叫做"shellcheck",
So there's like a really nifty tool that we have linked in the lecture notes, which is called "Shellcheck", 

305
00:25:35,600 --> 00:25:40,400
它可以为您提供警告、语法错误
that will kind of give you both warnings and syntactic errors

306
00:25:40,400 --> 00:25:43,600
和其他可能不正确引用
and other things that you might not have quoted properly,

307
00:25:43,600 --> 00:25:46,975
或文件中错放空格的问题.
or you might have misplaced spaces in your files. 

308
00:25:46,975 --> 00:25:54,450
例如,对于非常简单的"mcd.sh"文件,我们会得到一些错误提示,
So for example for extremely simple "mcd.sh" file we're getting a couple of errors saying hey, 

309
00:25:54,450 --> 00:25:56,225
令人惊讶的是,我们缺少了shebang,
surprisingly,we're missing a shebang, 

310
00:25:56,225 --> 00:26:00,675
如果在不同的系统上运行,可能无法正确解释它.
like this might not interpret it correctly if you're running it at a different system. 

311
00:26:00,750 --> 00:26:07,325
此外,这个CD命令可能不会正确扩展,
Also, this cd is taking a command and it might not expand properly 

312
00:26:07,325 --> 00:26:11,060
因此，与其使用CD，不如使用其他方法
so instead of using cd you might want to use something 

313
00:26:11,060 --> 00:26:14,160
像是使用类似于CD或者"exit"这样的东西.
like cd and then an OR and then an "exit". 

314
00:26:14,160 --> 00:26:21,325
我们回到之前解释的内容,这样做的效果就是,如果CD没有正确结束,
We go back to what we explained earlier, what this will do is like if the cd doesn't end correctly, 

315
00:26:21,325 --> 00:26:25,850
您不能CD进入该文件夹,因为要么您没有权限,要么它不存在...
you cannot cd into the folder because either you don't have permissions, it doesn't exist...

316
00:26:25,850 --> 00:26:30,800
这将给出一个非零的错误命令,
That will give a nonzero error command, 

317
00:26:30,800 --> 00:26:34,275
所以您将执行退出,这将停止脚本,
so you will execute exit and that will stop the script

318
00:26:34,275 --> 00:26:39,100
而不是继续执行好像您实际上并不在的地方.
instead of continue executing as if you were in a place that you are actually not in. 

319
00:26:39,175 --> 00:26:47,750
实际上,我还没有测试过,但我认为我们可以检查"example.sh",
And actually I haven't tested, but I think we can check for "example.sh"

320
00:26:47,775 --> 00:26:54,625
在这里我们得到的是我们应该以不同的方式检查退出代码,
and here we're getting that we should be checking the exit code in a different way, 

321
00:26:54,625 --> 00:26:58,625
因为这种方法可能不是最好的方法.
because it's probably not the best way, doing it this way.  

322
00:26:59,850 --> 00:27:07,575
我想要做最后一个备注的是,在编写bash脚本或函数时,
One last remark I want to make is that when you're writing bash scripts or functions for that matter,

323
00:27:07,575 --> 00:27:12,800
有一种情况是在隔离的环境中编写脚本,
there's kind of a difference between writing bash scripts in isolation 

324
00:27:12,800 --> 00:27:16,700
就像一个您要运行的东西,还有一种情况是将其加载到您的shell中.
like a thing that you're gonna run, and a thing that you're gonna load into your Shell.

325
00:27:16,700 --> 00:27:22,950
我们将在命令行环境讲座中看到一些内容,
We will see some of this in the command line environment lecture, 

326
00:27:22,950 --> 00:27:26,800
那里我们将会处理bashrc和sshrc.
where we will kind of be tooling with the bashrc and the sshrc. 

327
00:27:26,800 --> 00:27:30,325
但总的来说,如果您对例如您所在的位置进行更改,
But in general, if you make changes to 

328
00:27:30,325 --> 00:27:36,050
例如如果您CD进入一个bash脚本并且只执行该bash脚本,
for example where you are, like if you cd into a bash script and you just execute that bash script, 

329
00:27:36,050 --> 00:27:39,075
它不会CD进入您现在所在的shell.
it won't cd into the Shell are right now. 

330
00:27:39,150 --> 00:27:45,325
但是,如果您直接将代码加载到您的shell中,例如您加载......
But if you have loaded the code directly into your Shell, for example you load...

331
00:27:45,325 --> 00:27:51,293
您源代码函数并执行该函数,那么您将获得这些副作用.
you source the function and then you execute the function then you will get those side effects. 

332
00:27:51,293 --> 00:27:55,625
同样的道理也适用于在shell中定义变量.
And the same goes for defining variables into the Shell.

333
00:27:57,075 --> 00:28:05,950
现在我将讨论一些我认为在处理shell时非常好用的工具.
Now I'm going to talk about some tools that I think are nifty when working with the Shell. 

334
00:28:05,950 --> 00:28:10,250
这也是昨天简单介绍过的.
The first was also briefly introduced yesterday.

335
00:28:10,250 --> 00:28:15,500
你如何知道使用哪些选项或确切的命令.
How do you know what flags, or like what exact commands can go

336
00:28:15,500 --> 00:28:21,475
比如我该如何知道LS加上"-L"会以列表格式列出文件,
like how I am supposed to know that LS minus L will list the files in a list format, 

337
00:28:21,475 --> 00:28:26,725
或者如果我执行"move -i",它会提示我输入内容.
or that if I do "mv - i", it's gonna like prom me for stuff. 

338
00:28:26,825 --> 00:28:29,500
为此,你可以使用"man"命令.
For that what you have is the "man" command. 

339
00:28:29,500 --> 00:28:35,100
man命令会提供很多信息...
And the man command will kind of have like a lot of information of how will you go about... 

340
00:28:35,100 --> 00:28:40,025
例如在这里它会解释"-i"选项
so for example here it will explain for the "-i" flag, 

341
00:28:40,025 --> 00:28:42,700
有哪些可选项.
there are all these options you can do. 

342
00:28:43,800 --> 00:28:45,800
这其实非常有用,
That's actually pretty useful and it will work 

343
00:28:45,800 --> 00:28:51,525
不仅适用于你操作系统中打包好的简单命令,
not only for really simple commands that come packaged with your OS

344
00:28:51,525 --> 00:28:56,600
而且还适用于你从互联网上安装的一些工具.
but will also work with some tools that you install from the internet for example

345
00:28:56,600 --> 00:29:02,900
例如,如果进行安装的人同时安装了"man"包,
if the person that did the installation made it so that the man package were also installed. 

346
00:29:02,950 --> 00:29:07,025
那么我们稍后要介绍的一个名为"ripgrep"的工具,
So for example a tool that we're gonna cover in a bit

347
00:29:07,025 --> 00:29:11,375
它的命令叫做rg,
which is called "ripgrep" and is called with rg, 

348
00:29:11,425 --> 00:29:18,525
这并没有与我的系统一起提供,但它安装了自己的man页面,我可以在这里访问它.
this didn't come with my system but it has installed its own man page and I have it here and I can access it. 

349
00:29:18,975 --> 00:29:23,950
对于某些命令,man页面是有用的,
For some commands the man page is useful 

350
00:29:23,950 --> 00:29:30,075
但有时它们可能很难解释,因为它更像是一份文档或是描述工具
but sometimes it can be tricky to decipher because it's more kind of a documentation 

351
00:29:30,075 --> 00:29:33,400
关于所能做的所有事情的说明.
and a description of all the things the tool can do. 

352
00:29:33,400 --> 00:29:37,500
有时它会有示例,但有时不会,
Sometimes it will have examples but sometimes not, 

353
00:29:37,525 --> 00:29:43,475
有时工具可以做很多事情,
and sometimes the tool can do a lot of things so a couple of good tools 

354
00:29:43,475 --> 00:29:47,475
所以我经常使用的一些好工具是"convert"或"ffmpeg",
that I use commonly are "convert" or "ffmpeg", 

355
00:29:47,525 --> 00:29:51,975
它们分别处理图像和视频,man页面是巨大的.
which deal with images and video respectively and the main pages are like enormous. 

356
00:29:52,000 --> 00:29:56,000
你还可以安装一个很好的，叫做"tldr"的工具,
So there's one neat tool called "tldr" that you can install 

357
00:29:56,000 --> 00:30:04,900
然后你就可以得到一些很好的解释性的例子,说明如何使用这个命令.
and you will have like some nice kind of explanatory examples of how you want to use this command. 

358
00:30:04,900 --> 00:30:10,925
你可以随时在谷歌上搜索,但我发现我总是要先进入浏览器,
And you can always Google for this, but I find myself saving going into the browser, 

359
00:30:10,925 --> 00:30:16,825
查找一些例子,然后回来,而"tldr"是社区贡献的,
looking about some examples and coming back, whereas "tldr" are community contributed 

360
00:30:16,825 --> 00:30:19,000
它们非常有用.
and they're fairly useful. 

361
00:30:19,025 --> 00:30:25,550
然后,"ffmpeg"的页面有很多有用的例子,这些例子的格式更好
Then, the one for "ffmpeg" has a lot of useful examples that are more nicely formatted 

362
00:30:25,550 --> 00:30:29,025
如果你没有大号字体进行记录的话.
if you don't have a huge font size for recording. 

363
00:30:29,025 --> 00:30:35,450
或者像"tar"这样的简单命令,有很多你正在组合的选项.
Or even simple commands like "tar", that have a lot of options that you are combining. 

364
00:30:35,475 --> 00:30:40,875
例如,在这里,你可以组合2、3个不同的标志,
So for example, here you can be combining 2, 3... different flags 

365
00:30:40,875 --> 00:30:45,425
这可能不明显,当你想组合不同的标志时,
and it can not be obvious, when you want to combine different ones. 

366
00:30:47,175 --> 00:30:52,175
这就是你了解更多有关这些工具的方法.
That's how you would go about finding more about these tools. 

367
00:30:52,175 --> 00:30:58,350
关于查找文件的主题,让我们尝试学习如何查找文件.
On the topic of finding, let's try learning how to find files. 

368
00:30:58,350 --> 00:31:08,425
你可以随时使用"ls",比如"ls project1",并不断ls到底.
You can always go "ls", and like you can go like "ls project1", and keep LS'ing all the way through. 

369
00:31:08,475 --> 00:31:17,175
但是,也许如果我们已经知道我们要查找所有名为"src"的文件夹,
But maybe, if we already know that we want to look for all the folders called "src", 

370
00:31:17,225 --> 00:31:20,225
那么可能有更好的命令来完成这个任务.
then there's probably a better command for doing that. 

371
00:31:20,225 --> 00:31:21,425
这就是"find".
And that's "find".

372
00:31:21,450 --> 00:31:25,525
Find是几乎每个UNIX系统都带有的工具.
Find is the tool that, pretty much comes with every UNIX system. 

373
00:31:25,525 --> 00:31:30,250
我们要将把find用在...
And find, we're gonna give it... 

374
00:31:31,725 --> 00:31:39,375
我们将在当前文件夹中调用find,记住"."表示当前文件夹,
here we're saying we want to call find in the current folder, remember that "." stands for the current folder, 

375
00:31:39,375 --> 00:31:44,975
我们要让它的名称是"src",类型为目录.
and we want the name to be "src" and we want the type to be a directory. 

376
00:31:45,075 --> 00:31:50,625
通过输入这个命令,它将递归地浏览当前目录,
And by typing that it's gonna recursively go through the current directory 

377
00:31:50,625 --> 00:31:55,350
并查找所有符合此模式的文件或文件夹.
and look for all these files, or folders in this case, that match this pattern. 

378
00:31:55,350 --> 00:31:59,700
Find有很多有用的标志.
Find has a lot of useful flags. 

379
00:31:59,825 --> 00:32:04,800
例如,您甚至可以测试路径,
So for example, you can even test for the path to be in a way. 

380
00:32:04,800 --> 00:32:08,425
以便说我们希望有一些文件夹,
Here we're saying we want some number of folders,

381
00:32:08,425 --> 00:32:10,225
我们并不在意有多少文件夹,
we don't really care how many folders,

382
00:32:10,225 --> 00:32:13,750
然后我们关心所有的Python脚本,
and then we care about all the Python scripts, 

383
00:32:13,750 --> 00:32:18,600
所有的扩展名为".py"的东西,这些都在一个名为"test"的文件夹中.
all the things with the extension ".py", that are within a test folder. 

384
00:32:18,600 --> 00:32:22,950
而且,我们也检查一下,只是以防万一,但我们只是检查一下它也是...
And we're also checking, just in cases really but we're checking just that it's also are...

385
00:32:23,025 --> 00:32:25,400
按下F键，这代表文件
type F, which stands for file. 

386
00:32:25,425 --> 00:32:28,200
我们正在获取所有这些文件.
We're getting all these files.

387
00:32:28,200 --> 00:32:34,500
您还可以使用不是路径或名称的不同标志.
You can also use different flags for things that are not the path or the name.

388
00:32:34,500 --> 00:32:39,325
您可以检查已修改过的文件
You could check things that have been modified 

389
00:32:39,325 --> 00:32:41,550
"-mtime"用于修改时间,
"-mtime" is for the modification time, 

390
00:32:41,550 --> 00:32:45,350
在过去一天内修改过的文件,这几乎将是所有文件.
things that have been modified in the last day, which is gonna be pretty much 。

391
00:32:45,350 --> 00:32:47,225
因此,这将打印
Everything ,so this is gonna print

392
00:32:47,225 --> 00:32:50,950
我们创建的许多文件和已经存在的文件.
a lot of the files we created and files that were already there. 

393
00:32:50,950 --> 00:32:57,700
您甚至可以使用其他东西,例如大小,所有者,权限等.
You can even use other things like size, the owner, permissions, you name it. 

394
00:32:58,200 --> 00:33:02,150
更强大的是,"find"可以查找东西,
What is even more powerful is, "find" can find stuff

395
00:33:02,150 --> 00:33:05,875
但它也可以在找到这些文件时执行任务.
but it also can do stuff when you find those files. 

396
00:33:05,950 --> 00:33:15,250
因此,我们可以查找所有具有TMP扩展名的文件,
So we could look for all the files that have a TMP extension, 

397
00:33:15,250 --> 00:33:22,850
然后,我们可以告诉"find"对于这些文件中的每一个文件,
which is a temporary extension, and then, we can tell "find" that for every one of those files,

398
00:33:22,850 --> 00:33:26,500
只需为它们执行"rm"命令.
just execute the "rm" command for them. 

399
00:33:26,500 --> 00:33:30,150
这将调用"rm"来处理所有这些文件.
And that will just be calling "rm" with all these files. 

400
00:33:30,150 --> 00:33:36,050
因此,让我们首先执行它,然后再执行它.
So let's first execute it without, and then we execute it with it.

401
00:33:36,050 --> 00:33:42,050
再次,与命令行哲学一样,看起来好像什么也没发生.
Again, as with the command line philosophy, it looks like nothing happened. 

402
00:33:42,050 --> 00:33:48,875
但是由于我们有零错误代码,所以发生了一些事情 
But since we have a "0" error code, something happened 

403
00:33:48,875 --> 00:33:51,350
 只是一切都正确,一切都好.
just that everything went correct and everything is fine. 

404
00:33:51,350 --> 00:33:56,700
现在,如果我们搜索这些文件,它们就不在了.
And now, if we look for these files, they aren't there anymore.

405
00:33:56,700 --> 00:34:04,350
一般来说,关于Shell的另一个好处是有这些工具,
Another nice thing about the Shell in general is that there are these tools, 

406
00:34:04,350 --> 00:34:07,500
但人们会不断发现新的方法,
but people will keep finding new ways, 

407
00:34:07,500 --> 00:34:10,400
所以会有替代的方法来编写这些工具.
so alternative ways of writing these tools. 

408
00:34:10,400 --> 00:34:20,075
了解它非常好.例如,如果您只想匹配以"tmp"结尾的内容,
It's nice to know about it. So, for example find if you just want to match the things that end in "tmp"

409
00:34:20,075 --> 00:34:24,375
可能很难做到这一点,因为它有很长的命令.
it can be sometimes weird to do this thing, it has a long command.

410
00:34:24,375 --> 00:34:29,000
例如,"fd"这样的东西,
There's things like "fd" for example

411
00:34:29,050 --> 00:34:34,850
这是一个更短的命令,它默认使用正则表达式,并忽略您的git文件,
that is a shorter command that by default will use regex and will ignore your gitfiles, 

412
00:34:34,850 --> 00:34:37,225
因此您甚至不会搜索它们.
so you don't even search for them. 

413
00:34:37,250 --> 00:34:41,875
它会进行彩色编码,具有更好的Unicode体验...
It will color-code, it will have better Unicode support... 

414
00:34:41,875 --> 00:34:44,325
了解一些这些工具是很好的.
It's nice to know about some of these tools. 

415
00:34:44,325 --> 00:34:51,350
但是,再次强调的是,如果您知道这些工具的存在,
But, again, the main idea is that if you are aware that these tools exist, 

416
00:34:51,475 --> 00:34:56,575
您可以节省大量时间,不必做一些繁琐重复的任务.
you can save yourself a lot of time from doing kind of menial and repetitive tasks.

417
00:34:56,575 --> 00:35:00,850
还有一个命令要记住,就像"find"一样.
Another command to bear in mind is like "find". 

418
00:35:00,850 --> 00:35:02,775
有些人可能会想,
Some of you may be wondering, 

419
00:35:02,775 --> 00:35:09,075
"find"可能只是实际上在遍历目录结构并寻找内容,
"find" is probably just actually going through a directory structure and looking for things 

420
00:35:09,075 --> 00:35:11,650
但如果我一天要做很多"finds",那怎么办？
but what if I'm doing a lot of "finds" a day?

421
00:35:11,650 --> 00:35:17,675
是否更好,采用数据库方法并首先构建一个索引,
Wouldn't it be better, doing kind of a database approach and build an index first, 

422
00:35:17,675 --> 00:35:21,050
然后使用该索引并以某种方式进行更新.
and then use that index and update it in some way. 

423
00:35:21,075 --> 00:35:23,475
实际上,大多数Unix系统已经通过"locate"命令完成了这一点,
Well, actually most Unix systems already do it 

424
00:35:23,475 --> 00:35:32,262
而且定位将被使用... 
and this is through the "locate" command and the way that the locate will be used... 

425
00:35:32,262 --> 00:35:40,150
它只会查找您的文件系统中包含您想要的子字符串的路径.
it will just look for paths in your file system that have the substring that you work. 

426
00:35:40,150 --> 00:35:43,050
我实际上不知道它是否有效...
I actually don't know if it will work... 

427
00:35:43,050 --> 00:35:43,650
好的,它有效.
Okay, it worked. 

428
00:35:43,650 --> 00:35:49,825
让我试试像"missing-semester"这样的东西.
Let me try to do something like "missing-semester".

429
00:35:52,500 --> 00:35:57,300
它会花一些时间,但它找到了所有这些文件,这些文件都在我的文件系统中某个地方,
You're gonna take a while but it found all these files that are somewhere in my file system 

430
00:35:57,300 --> 00:36:02,400
因为它已经在它们上面构建了一个索引,所以它要快得多.
and since it has built an index already on them, it's much faster. 

431
00:36:02,400 --> 00:36:09,275
为了使其保持更新,我们使用"updatedb"命令来更新此数据库.
And then, to keep it updated, using the "updatedb" command 

432
00:36:09,275 --> 00:36:15,725
这正是通过cron运行的
that is running through cron, to update this database. 

433
00:36:15,725 --> 00:36:19,525
再次强调，查找文件真的很有用
Finding files, again, is really useful. 

434
00:36:19,525 --> 00:36:23,625
有时您实际上关心的不是文件本身,
Sometimes you're actually concerned about, not the files themselves,

435
00:36:23,625 --> 00:36:25,650
而是文件的内容.
but the content of the files. 

436
00:36:25,650 --> 00:36:32,575
为此,您可以使用我们迄今为止看到的grep命令.
For that you can use the grep command that we have seen so far. 

437
00:36:32,575 --> 00:36:38,525
因此,您可以在MCD中执行类似"grep foobar"的操作,它就在那里.
So you could do something like "grep foobar" in "mcd", it's there.

438
00:36:38,525 --> 00:36:45,700
如果您想要再次递归地搜索当前结构并查找更多文件,怎么办？
What if you want to, again, recursively search through the current structure and look for more files?

439
00:36:45,700 --> 00:36:48,975
我们不想手动完成这项工作.
We don't want to do this manually.

440
00:36:48,975 --> 00:36:51,025
我们可以使用"find"和"-exec",
We could use "find", and the "-exec", 

441
00:36:51,025 --> 00:37:02,550
但实际上,"grep"具有"-R"标志,它将遍历整个目录.
but actually "grep" has the "-R" flag that will go through the entire directory, here. 

442
00:37:02,550 --> 00:37:07,325
它告诉我们在这三个位置的example.sh
And it's telling us that oh we have the foobar line in "example.sh"

443
00:37:07,325 --> 00:37:11,800
和在这另外两个位置的foobar中都有foobar行.
at these three places and in this other two places in foobar. 

444
00:37:13,675 --> 00:37:15,975
这可能非常方便.
This can be really convenient. 

445
00:37:15,975 --> 00:37:22,675
主要用例是,您知道您已经在某种编程语言中编写了一些代码,
Mainly, the use case for this is you know you have written some code in some programming language, 

446
00:37:22,675 --> 00:37:26,850
并且知道它在您的文件系统的某个地方,但您实际上不知道在哪里.
and you know it's somewhere in your file system but you actually don't know. 

447
00:37:26,850 --> 00:37:29,175
但您可以快速搜索.
But you can actually quickly search.

448
00:37:29,175 --> 00:37:38,575
例如,我可以在scratch文件夹中
So for example, I can quickly search for all the Python files 

449
00:37:38,575 --> 00:37:45,600
快速搜索使用请求库的所有Python文件.
that I have in my scratch folder where I used the request library.

450
00:37:45,625 --> 00:37:51,300
如果我运行这个命令,它会通过所有这些文件,
And if I run this, it's giving me through all these files, exactly in

451
00:37:51,300 --> 00:37:53,425
并精确地给出在哪一行找到了它.
what line it has been found. 

452
00:37:53,425 --> 00:37:58,375
这里,我没有使用grep,(当然这也是可以的)
And here instead of using grep, which is fine, you could also do this, 

453
00:37:58,375 --> 00:38:03,325
而是使用了"ripgrep",它与grep的想法有点相同,
I'm using "ripgrep", which is kind of the same idea 

454
00:38:03,325 --> 00:38:12,750
但是又尝试带来更多的漂亮之处,比如彩色编码或文件处理等.
but again trying to bring some more niceties like color coding or file processing and other things. 

455
00:38:12,750 --> 00:38:15,325
它也支持unicode.
It think it has, also, unicode support. 

456
00:38:15,325 --> 00:38:21,425
它也非常快,因此您不必担心速度较慢的折衷.
It's also pretty fast so you are not paying like a trade-off on this being slower 

457
00:38:21,425 --> 00:38:25,216
还有许多有用的标志.
and there's a lot of useful flags. 

458
00:38:25,216 --> 00:38:30,550
您可以说,哦,我实际上想获得这些结果周围的一些上下文.
You can say, oh, I actually want to get some context around those results.

459
00:38:32,875 --> 00:38:37,275
因此,您可以看到导入所在的位置
So I want to get like five lines of context around that, 

460
00:38:37,275 --> 00:38:43,025
并查看周围的代码.
so you can see where that import lives and see code around it.

461
00:38:43,025 --> 00:38:47,825
在导入中,这并不是真正有用的,但是如果您正在寻找使用该函数的位置,
Here in the import it's not really useful but like if you're looking for where you use the function, for example, it will

462
00:38:49,250 --> 00:38:51,475
那么它将非常方便.
It will be very handy. 

463
00:38:51,475 --> 00:38:59,025
我们还可以做其他事情,例如在这里搜索.
We can also do things like we can search, for example here,.

464
00:38:59,075 --> 00:39:09,625
更高级的用法,我们可以说,"-u"是为了不忽略隐藏文件,
A more advanced use, we can say, "-u" is for don't ignore hidden files, 

465
00:39:09,625 --> 00:39:16,000
有时你想忽略隐藏文件,
sometimes you want to be ignoring hidden files, 

466
00:39:16,000 --> 00:39:21,625
除非你要搜索默认隐藏的配置文件.
except if you want to search config files, that are by default hidden. 

467
00:39:21,625 --> 00:39:25,075
然后,我们不是打印匹配项,
Then, instead of printing the matches, 

468
00:39:25,075 --> 00:39:31,525
而是要求执行一些可能很难使用grep实现从我的头脑中想出的操作
we're asking to do something that would be kind of hard, I think,to do with grep, out of my head, 

469
00:39:31,525 --> 00:39:37,250
那就是"我希望你打印出所有不匹配给定模式的文件",这可能是一个奇怪的请求,但我们继续下去...
which is I want you to print all the files that don't match the pattern I'm giving you, 

470
00:39:37,275 --> 00:39:41,800
这可能是一个奇怪的要求,但我们还是继续讲解...
which may be a weird thing to ask here but then we keep going... 

471
00:39:41,800 --> 00:39:45,125
这里的模式是一个小正则表达式,
And this pattern here is a small regex 

472
00:39:45,150 --> 00:39:51,514
它表示在行的开头有一个"#"和一个"!",这是一个shebang.
which is saying at the beginning of the line I have a "#" and a "!", and that's a shebang.

473
00:39:51,514 --> 00:39:57,100
这样,我们在这里搜索所有没有shebang的文件,
Like that, we're searching here for all the files that don't have a shebang

474
00:39:57,100 --> 00:40:03,415
然后在这里给它一个"-t sh"只查找"sh"文件,
and then we're giving it, here, a "-t sh" to only look for "sh" files,  

475
00:40:03,415 --> 00:40:09,000
因为你的Python或文本文件可能没有shebang也没问题.
because maybe all your Python or text files are fine without a shebang. 

476
00:40:09,025 --> 00:40:12,875
这里告诉我们,"哦,MCD显然缺少一个shebang",
And here it's telling us "oh, 'mcd' is obviously missing a shebang"

477
00:40:12,875 --> 00:40:15,775
我们甚至可以... 
We can even... 

478
00:40:15,775 --> 00:40:21,425
它有一些不错的标志,例如如果我们包括"stats"标志,
It has like some nice flags, so for example if we include the "stats" flag

479
00:40:28,600 --> 00:40:35,050
它将得到所有这些结果,但它还将告诉我们有关它所搜索的所有内容的信息.
it will get all these results but it will also tell us information about all the things that it searched. 

480
00:40:35,050 --> 00:40:40,900
例如,找到的匹配次数、行数、搜索的文件、
For example, the number of matches that it found, the lines, the file searched,

481
00:40:40,900 --> 00:40:42,775
打印的字节数等等.
the bytes that it printed, etc.

482
00:40:42,775 --> 00:40:47,675
与"fd"类似,它有时候不是很好用
Similar as with "fd", sometimes it's not as useful

483
00:40:47,775 --> 00:40:52,700
有时候特定的工具并不是很有用,就跟ripgrep一样,
using one specific tool or another and in fact, as ripgrep, 

484
00:40:52,700 --> 00:40:58,425
还有像"ack"这样的工具是最初编写的grep替代工具.
there are several other tools, like "ack", is the original grep alternative that was written. 

485
00:40:58,425 --> 00:41:03,350
然后是另一个工具"ag".
Then the silver searcher, "ag", was another one... 

486
00:41:03,350 --> 00:41:05,850
它们都可以相互替换,
and they're all pretty much interchangeable

487
00:41:05,850 --> 00:41:08,625
所以也许你所在的系统有一个而没有另一个,
 so maybe you're at a system that has one and not the other, 

488
00:41:08,625 --> 00:41:13,800
只要知道你可以使用这些工具就会非常有用.
just knowing that you can use these things with these tools can be fairly useful. 

489
00:41:13,800 --> 00:41:19,450
最后,我想谈谈如何查找你已经找到的命令,不是找文件或代码.
Lastly, I want to cover how you go about, not finding files or code, 

490
00:41:19,450 --> 00:41:24,525
就是你如何找到你已经知道的命令。
but how you go about finding commands that you already some time figured out. 

491
00:41:24,525 --> 00:41:30,525
第一种,显然的方法就是使用"↑",
The first, obvious way is just using the up arrow,

492
00:41:30,525 --> 00:41:34,675
慢慢浏览你的历史记录,寻找这些匹配项.
and slowly going through all your history, looking for these matches.

493
00:41:34,675 --> 00:41:37,650
这实际上并不是很高效,你可能已经猜到了.
This is actually not very efficient, as you probably guessed. 

494
00:41:37,650 --> 00:41:43,025
因此,bash有更轻松的方法来做这件事.
So the bash has ways to do this more easily.

495
00:41:43,025 --> 00:41:45,900
有一个"history"命令,会打印出你的历史记录.
There is the "history" command, that will print your history. 

496
00:41:45,900 --> 00:41:49,300
这里我在zsh中,它只打印出一部分历史记录,
Here I'm in zsh and it only prints some of my history, 

497
00:41:49,300 --> 00:41:53,575
但如果我说,我想要你从一切开始打印,
but if I say, I want you to print everything from the beginning of time, 

498
00:41:53,575 --> 00:41:57,325
它将从这个历史记录的开始打印一切.
it will print everything from the beginning of whatever this history is.

499
00:41:57,325 --> 00:42:02,225
由于这是很多结果,也许我们关心的是
And since this is a lot of results, maybe we care about the ones 

500
00:42:02,225 --> 00:42:08,925
我们使用"convert"命令从某种文件类型转换为另一种文件类型的那些结果.
where we use the "convert" command to go from some type of file to some other type of file.

501
00:42:08,925 --> 00:42:11,125

Some image, sorry. 

502
00:42:11,125 --> 00:42:18,250
然后,我们获得了所有与该子字符串匹配的结果.
Then, we're getting all these results here, about all the ones that match this substring.

503
00:42:18,250 --> 00:42:29,250
几乎所有的shell默认都会将"Ctrl+R"这个键绑定为反向搜索.
Even more, pretty much all Shells by default will link "Ctrl+R", the keybinding, to do backward search. 

504
00:42:29,300 --> 00:42:33,425
这里我们有一个反向搜索,我们可以输入"convert",
Here we have backward search, where we can type "convert" 

505
00:42:33,425 --> 00:42:36,050
它会找到我们刚输入的命令.
and it's finding the command that we just typed. 

506
00:42:36,050 --> 00:42:38,500
如果我们一直按"Ctrl+R",
And if we just keep hitting "Ctrl+R", 

507
00:42:38,500 --> 00:42:45,250
它会浏览这些匹配项,让我们在原地重新执行.
it will kind of go through these matches and it will let re-execute it in place. 

508
00:42:47,750 --> 00:42:53,375
另外一件你可以做的事情,与此相关的是你可以使用这个非常棒的工具叫做"fzf",
Another thing that you can do, related to that, is you can use this really nifty tool called "fzf", 

509
00:42:53,375 --> 00:42:56,792
就像模糊查找器,它可以然你...
which is like a fuzzy finder, like it will let you...

510
00:42:57,000 --> 00:43:00,275
它可以让你进行交互式的 grep.
It will let you do kind of like an interactive grep. 

511
00:43:01,750 --> 00:43:09,350
例如,我们可以使用 cat 命令打印我们的 example.sh 命令,
We could do for example this, where we can cat our "example.sh" command, 

512
00:43:09,350 --> 00:43:11,350
它将打印到标准输出，
that will print print to the standard output, 

513
00:43:11,350 --> 00:43:13,550
并将其传递到 fzf 中.
and then we can pipe it through "fzf". 

514
00:43:13,550 --> 00:43:20,325
它只是获取所有的行,然后我们可以交互式地查找我们关心的字符串.
It's just getting all the lines and then we can interactively look for the string that we care about. 

515
00:43:20,425 --> 00:43:23,700
fzf的好处是,
And the nice thing about fzf is that, 

516
00:43:23,700 --> 00:43:33,675
如果你启用了默认绑定,它会绑定到你的"Ctrl+R" shell执行,
if you enable the default bindings, it will bind to your "Ctrl+R" Shell execution 

517
00:43:33,675 --> 00:43:41,700
现在你可以快速动态地查找所有你尝试在历史记录中转换favicon的时间.
and now you can quickly and dynamically like look for all the times you try to convert a favicon in your history.

518
00:43:41,750 --> 00:43:44,925
它还具有模糊匹配的功能,.
And it's also like fuzzy matching, 

519
00:43:44,925 --> 00:43:50,175
而默认情况下grep或这些工具必须编写一个正则表达式或一些表达式来匹配
whereas like by default in grep or these things you have to write a regex or some expression that will match within here.

520
00:43:50,175 --> 00:43:52,475



521
00:43:52,475 --> 00:43:54,975
这里我只是输入"convert"和"favi",
Here I'm just typing "convert" and "favi" 

522
00:43:54,975 --> 00:44:00,000
它尝试做出最佳扫描,在它拥有的行中进行匹配.
and it's just trying to do the best scan, doing the match in the lines it has.

523
00:44:01,500 --> 00:44:05,350
最后,一个你可能已经见过的工具,
Lastly, a tool that probably you have already seen, 

524
00:44:05,350 --> 00:44:12,300
我用它来避免重新输入这些非常长的命令,它叫做"history substring search",
that I've been using for not retyping these extremely long commands is this "history substring search", 

525
00:44:12,300 --> 00:44:15,925
当我在shell中输入时,
where as I type in my Shell, 

526
00:44:15,925 --> 00:44:22,950
虽然两个F都没有提到,但是有个的概念一开始就已经引入这两个方面
and both F fail to mention but both face which I think was originally introduced, this concept, 

527
00:44:22,975 --> 00:44:25,375
然后zsh有一个非常好的实现,
and then zsh has a really nice implementation 

528
00:44:25,375 --> 00:44:28,700
它让你在键入命令时,
What it'll let you do is as you type the command, 

529
00:44:28,700 --> 00:44:34,700
动态地在历史记录中搜索具有相同前缀的相同命令,
it will dynamically search back in your history to the same command that has a common prefix,

530
00:44:34,700 --> 00:44:36,500
然后,如果你...
and then, if you...

531
00:44:38,850 --> 00:44:45,550
它会随着匹配列表停止工作而改变,然后当你按"→"”时,
it will change as the match list stops working and then as you do the right arrow. 

532
00:44:45,550 --> 00:44:49,325
你可以选择那个命令,然后重新执行它.
you can select that command and then re-execute it.

533
00:45:06,575 --> 00:45:09,175
我们已经看到了一些东西...
We've seen a bunch of stuff... 

534
00:45:09,175 --> 00:45:11,650
我想我还有几分钟的时间,
I think I have a few minutes left 

535
00:45:11,650 --> 00:45:19,950
所以我要介绍一些快速目录列表和目录导航的工具.
so I'm going to cover a couple of tools to do really quick directory listing and directory navigation.

536
00:45:19,950 --> 00:45:30,525
你总是可以使用"-R"来递归地列出某个目录结构,
So you can always use the "-R" to recursively list some directory structure,

537
00:45:30,525 --> 00:45:35,300
但这可能是次优的,我不能很容易地理解这个.
but that can be suboptimal, I cannot really make sense of this easily.

538
00:45:35,300 --> 00:45:45,775
有一个叫做"tree"的工具,它将是更友好的打印所有的东西,
There's tool called "tree" that will be the much more friendly form of printing all the stuff, 

539
00:45:45,775 --> 00:45:47,600
它也会根据颜色代码进行着色...
it will also color code based on...

540
00:45:47,600 --> 00:45:51,000
例如,这里的"foo"是蓝色的,因为它是一个目录,
here for example "foo" is blue because it's a directory 

541
00:45:51,000 --> 00:45:55,000
这个是红色的,因为它有执行权限.
and this is red because it has execute permissions.

542
00:45:55,325 --> 00:45:58,175
但我们可以做得更好.
But we can go even further than that. 

543
00:45:58,175 --> 00:46:04,325
有一些很好的工具,比如最近出现的一个叫做"broot"的工具,它可以做同样的事情,
There's really nice tools like a recent one called "broot" that will do the same thing 

544
00:46:04,325 --> 00:46:08,400
但是在这里,例如不像列出每一个单独的文件,
but here for example instead of doing this thing of listing every single file, 

545
00:46:08,400 --> 00:46:11,550
例如在"bar"中,我们有这些"a"到"j"的文件,
for example in bar we have these "a" through "j" files,

546
00:46:11,550 --> 00:46:14,375
它会说"噢,还有更多,这里就不列举了".
it will say "oh there are more, unlisted here".

547
00:46:14,525 --> 00:46:22,175
我实际上可以开始输入,它会再次匹配到那些存在的文件,
I can actually start typing and it will again facily match to the files that are there

548
00:46:22,175 --> 00:46:24,925
我可以快速选择它们并浏览它们.
and I can quickly select them and navigate through them.

549
00:46:24,925 --> 00:46:30,300
因此,了解这些事情很重要,
So, again, it's good to know that these things exist 

550
00:46:30,300 --> 00:46:36,000
这样你就不会浪费大量时间去寻找这些文件.
so you don't lose a large amount of time going for these files.

551
00:46:36,000 --> 00:46:45,292
还有,我认为我也安装了一些更类似于你所期望的操作系统拥有的工具,
There are also, I think I have it installed also something more similar to what you would expect your OS to have,

552
00:46:45,292 --> 00:46:48,710
比如Nautilus或者其中一个Mac Finder,
like Nautilus or one of the Mac finders 

553
00:46:48,710 --> 00:46:59,400
它们有一个交互式的输入,你可以使用导航箭头快速浏览.
that have like an interactive input where you can just use your navigation arrows and quickly explore.

554
00:46:59,425 --> 00:47:00,900
这可能有点过度,
It might be overkill 

555
00:47:00,900 --> 00:47:07,800
但你会惊讶地发现,通过浏览某个目录结构,你可以很快地理解它.
but you'll be surprised how quickly you can make sense of some directory structure by just navigating through it.

556
00:47:07,800 --> 00:47:12,925
几乎所有这些工具都会让你编辑、复制文件……
And pretty much all of these tools will let you edit, copy files...

557
00:47:12,925 --> 00:47:16,000
如果你只是寻找它们的选项的话.
if you just look for the options for them.

558
00:47:16,525 --> 00:47:20,700
最后的补充内容有点复杂.
The last addendum is kind of going places.

559
00:47:20,700 --> 00:47:29,000
我们有"cd","cd"很好用,它会让你到达很多地方.
We have "cd", and "cd" is nice, it will get you to a lot of places. 

560
00:47:29,000 --> 00:47:32,775
但是如果你可以快速到达一些地方,那就非常方便了.
But it's pretty handy if you can like quickly go places,

561
00:47:32,847 --> 00:47:33,922
具体地说，就是
you are...

562
00:47:33,922 --> 00:47:38,275
你最近或经常去的地方
either you have been to recently or that you go frequently. 

563
00:47:38,375 --> 00:47:43,200
你可以用很多种方式做到这一点,可能会想到……
And you can do this in many ways there's probably you can start thinking, 

564
00:47:43,200 --> 00:47:45,025
我可以做书签,我可以……
oh I can make bookmarks, I can make... 

565
00:47:45,025 --> 00:47:48,550
我可以在shell中创建别名,我们以后会介绍到这个问题,
I can make aliases in the Shell, that we will cover at some point,

566
00:47:48,550 --> 00:47:50,625
可以创建符号链接……
symlinks... 

567
00:47:51,000 --> 00:47:55,700
但是此时,程序员已经构建了所有这些工具,
But at this point ,programmers have like built all these tools, 

568
00:47:55,700 --> 00:47:59,525
所以程序员已经找到了一个非常好的方法来做到这一点.
so programmers have already figured out a really nice way of doing this.

569
00:47:59,525 --> 00:48:03,700
其中一种方法是使用所谓的"auto jump",
One way of doing this is using what is called "auto jump", 

570
00:48:03,700 --> 00:48:06,050
我想这里没有加载……
which I think is not loaded here...

571
00:48:14,250 --> 00:48:16,925
不过,别担心.
Okay, don't worry. 

572
00:48:16,925 --> 00:48:19,725
我将在命令行环境中介绍它.
I will cover it in the command line environment.

573
00:48:21,750 --> 00:48:25,750
我想这是因为我禁用了"Ctrl+R",
I think it's because I disabled the "Ctrl+R" 

574
00:48:25,750 --> 00:48:29,100
这也影响了脚本的其他部分.
and that also affected other parts of the script. 

575
00:48:29,100 --> 00:48:34,100
如果有任何与此相关的问题,
I think at this point if anyone has any questions that are related to this, 

576
00:48:34,100 --> 00:48:38,075
如果有任何不清楚的地方，我很乐意回答。
I'll be more than happy to answer them,  if anything was left unclear.

577
00:48:38,200 --> 00:48:44,375
否则,我们编写了一堆练习,涉及这些主题,
Otherwise, a there's a bunch of exercises that we wrote, kind of touching on these topics 

578
00:48:44,375 --> 00:48:47,925
我们鼓励你尝试它们,并在办公时间前来,
and we encourage you to try them and come to office hours, 

579
00:48:47,925 --> 00:48:54,825
我们可以帮助你弄清如何做这些事情,或者一些不明确的bash技巧.
where we can help you figure out how to do them, or some bash quirks that are not clear.
