1
00:00:00,800 --> 00:00:02,275
欢迎回来.
So welcome back. 

2
00:00:02,275 --> 00:00:05,000
今天我们讲解程序的调试和分析.
Today we are gonna cover debugging and profiling. 

3
00:00:05,000 --> 00:00:09,975
在我开始之前,我需要再提醒你们填写一下调查问卷.
Before I get into it we're gonna kind of make another reminder to fill in the survey.

4
00:00:09,975 --> 00:00:14,375
我们主要是想收集你们在课程学习的时候的遇到的问题,
Yes, one of the main things we want to get from you is questions, 

5
00:00:14,375 --> 00:00:17,575
在最后一天,我们会回答这些问题,
because the last day is gonna be questions from you guys: 

6
00:00:17,575 --> 00:00:22,275
这些问题可以是我们没有提及的问题或者是你希望我们深入讨论一下的问题.
about things that we haven't covered, or like you want us to kind of talk more in depth.

7
00:00:22,275 --> 00:00:27,375
问的问题越多,这一部分就越有趣,
The more questions we get, the more interesting we can make that section, 

8
00:00:27,375 --> 00:00:29,150
所以再次强调,你们要填写一下调查问卷.
so please go on and fill in the survey.

9
00:00:29,150 --> 00:00:33,200
今天的讲座会讲很多东西.
So today's lecture is gonna be a lot of topics. 

10
00:00:33,200 --> 00:00:36,075
但是所有主题都围绕着一个概念展开:
All the topics revolve around the concept of 

11
00:00:36,075 --> 00:00:39,650
即当你的程序有bug时,你应该怎么做.
what do you do when you have a program that has some bugs. 

12
00:00:39,650 --> 00:00:42,000
编程时,
Which is most of the time, like when you are programming, 

13
00:00:42,000 --> 00:00:44,075
我们会花很多时间都在考虑如何实现某些功能,
you're kind of thinking about how you implement something 

14
00:00:44,075 --> 00:00:49,225
但是修复程序中的bug更要占掉一大半的时间.
and there's like a half life of fixing all the issues that program has. 

15
00:00:49,225 --> 00:00:51,500
即使你的程序按照你的预期运行,
And even if your program behaves like you want, 

16
00:00:51,500 --> 00:00:55,975
它速度可能也会非常慢,或者占用很多资源.
it might be that it's really slow, or like it's taking a lot of resources in the process. 

17
00:00:55,975 --> 00:01:01,450
今天我们将了解许多方法来解决这些问题.
So today we're gonna see a lot of different approaches of dealing with these problems.

18
00:01:01,450 --> 00:01:05,250
首先,第一部分是关于调试的.
So first, the first section is on debugging. 

19
00:01:05,250 --> 00:01:10,550
调试可以有各种各样的方法,比如说:
Debugging can be done in many different ways, there are all kinds of like:

20
00:01:10,550 --> 00:01:15,675
几乎所有计算机专业的学生都使用的最简单的方法就是:
The most simple approach that, pretty much, all CS students will go through, will be just: 

21
00:01:15,675 --> 00:01:18,075
你有一些代码,它的行为不符合你的预期,
you have some code, and it's not behaving like you want, 

22
00:01:18,075 --> 00:01:21,325
所以你通过添加打印语句来调试.
so you probe the code by adding print statements. 

23
00:01:21,325 --> 00:01:24,830
这被称为"printf调试",它有很好的效果.
This is called "printf debugging" and it works pretty well. 

24
00:01:24,830 --> 00:01:29,250
老实说,我经常使用它,
Like, I have to be honest, I use it a lot of the time 

25
00:01:29,250 --> 00:01:33,350
因为简单,反馈快.
because of how kind of simple to set up and how quick the feedback can be.

26
00:01:33,350 --> 00:01:39,386
printf调试的一个问题是你可能会获得大量输出,
One of the issues with printf debugging is that you can get a lot of output 

27
00:01:39,425 --> 00:01:43,575
而你可能并不希望获得这么多输出.
and maybe you don't want to get as much output as you're getting. 

28
00:01:43,575 --> 00:01:49,725
人们除了"printf调试",又想了许多更复杂一些的调试方法,
And there has... people have thought of slightly more complex ways of doing printf debugging 

29
00:01:49,725 --> 00:01:58,750
比如有一个,我们叫它"日志记录".
and one of these ways is what is usually referred to "logging". 

30
00:01:58,750 --> 00:02:05,275
与"printf调试"相比,使用日志的优点在于,
So the advantage of doing logging versus doing printf debugging is that,   

31
00:02:05,275 --> 00:02:10,075
你并不一定仅仅为了修复特定的bug才进行日志的创建,
when you're creating logs, you're not necessarily creating the logs because there's a specific issue you want to fix; 

32
00:02:10,075 --> 00:02:14,350
还有可能是你构建了一个很复杂的软件系统,
it's mostly because you have built a more complex software system 

33
00:02:14,350 --> 00:02:17,225
并且想在某些事件发生时把它们记录下来.
and you want to log when some events happen. 

34
00:02:17,425 --> 00:02:21,450
使用日志的核心优势是你可以定义严重性级别,
One of the core advantages of using a logging library is 

35
00:02:21,450 --> 00:02:27,250
并且可以根据这些级别进行过滤.
that you can can define severity levels, and you can filter based on those.

36
00:02:27,250 --> 00:02:31,800
让我们看一个示例:
Let's see an example of how we can do something like that:

37
00:02:32,175 --> 00:02:34,475
一切都正常.
Yeah, everything fits here. 

38
00:02:34,475 --> 00:02:36,550
这是一个非常简单的例子:
This is a really silly example:

39
00:02:36,550 --> 00:02:41,275
我们将随机抽取一些数字,
We're just gonna sample random numbers,

40
00:02:41,300 --> 00:02:45,175
并根据这些数字的值来决定在日志里记录什么样的错误程度,
And depending on the value of the number, that we can interpret as a kind of "how wrong things are going".

41
00:02:45,175 --> 00:02:51,950
我们把这些值记录下来,运行这个程序看看发生了什么.
We're going to log the value of the number and then we can see what is going on.

42
00:02:51,950 --> 00:02:59,125
我需要禁用这些格式化程序...
I need to disable these formatters...

43
00:02:59,500 --> 00:03:04,175
如果我们执行代码,
And if we were just to execute the code as it is, 

44
00:03:04,600 --> 00:03:08,325
我们只会不断获得输出.
we just get the output and we just keep getting more and more output.

45
00:03:08,325 --> 00:03:13,275
我们需要盯着这个输出还得尝试理解现在正在发生啥.
But you have to kind of stare at it and make sense of what is going on, 

46
00:03:13,275 --> 00:03:16,775
我们不知道每条"printf"语句的时间间隔,
and we don't know what is the relative timing between printfs, 

47
00:03:16,775 --> 00:03:20,375
也不知道这仅仅是一条消息
we don't really know whether this is just an information message

48
00:03:20,375 --> 00:03:23,225
还是有error产生的消息.
or a message of whether something went wrong. 

49
00:03:23,225 --> 00:03:29,550
如果我们进去,(老师的碎碎念...)
And if we just go in, and undo, not that one...

50
00:03:29,750 --> 00:03:37,825
我们可以设置这个格式化程序.
We can set that formatter. 

51
00:03:38,075 --> 00:03:42,150
现在输出是这样的:
Now the output looks something more like this

52
00:03:42,175 --> 00:03:45,382
例如,如果你正在使用多个不同的模块进行编程,
So for example, if you have several different modules that you are programming with, 

53
00:03:45,382 --> 00:03:47,400
你可以使用不同的级别来标识它们.
you can identify them with like different levels.

54
00:03:47,400 --> 00:03:53,350
这里,我们有调试级别,关键信息等等许多不同级别.
Here, we have, we have debug levels, we have critical info... Different levels. 

55
00:03:53,350 --> 00:03:58,375
这很方便,因为说不定我们只关心错误消息.
And it might be handy because here we might only care about the error messages.

56
00:03:58,375 --> 00:03:59,325
比如说,
Like those are , like the... 

57
00:03:59,325 --> 00:04:04,350
我们一直在编写代码,到目前为止一切顺利,突然出现了一些错误.
We have been working on our code, so far so good, and suddenly we get some error.

58
00:04:04,350 --> 00:04:06,925
我们可以记录下来,标识它发生在哪里.
We can log that to identify where it's happening. 

59
00:04:06,925 --> 00:04:09,075
但是也许有很多调试信息的日志,
But maybe there's a lot of information messages, 

60
00:04:09,275 --> 00:04:17,350
但我们可以通过将级别更改为error级别来处理它们.
but we can deal with that by just changing the level to error level. 

61
00:04:17,450 --> 00:04:24,975
现在,如果我们再次运行它,我们只会在输出中得到那些错误,
And now if we were to run this again, we are only going to get those errors in the output, 

62
00:04:24,975 --> 00:04:29,025
我们看输出结果就能知道现在正在发生啥.
and we can just look through those to make sense of what is going on.

63
00:04:29,025 --> 00:04:34,875
当你处理日志时,另一个非常有用的工具是......
Another really useful tool when you're dealing with logs is...

64
00:04:34,875 --> 00:04:38,650
这个日志变得更加可读了,
As you kind of look at this, it has become easier 

65
00:04:38,650 --> 00:04:43,575
因为现在我们有了critical和error级别的标志,可以快速识别.
because now we have this critical and error levels that we can quickly identify.

66
00:04:43,575 --> 00:04:47,500
但由于人类是相当视觉化的生物,
But kind of since humans are fairly visual creatures,

67
00:04:47,500 --> 00:04:55,500
你可以给不同的级别换上不一样的颜色标注.
one thing that you can do is use colors from your terminal to identify these things. 

68
00:04:55,500 --> 00:05:03,025
所以现在,改变格式化程序,我稍微改变了输出的格式.
So now, changing the formatter, what I've done is slightly change how the output is formatted. 

69
00:05:03,025 --> 00:05:09,500
当我这样做时,当我收到一个warning时,它是黄色的;
When I do that, now whenever I get a warning message, it's color coded by yellow;

70
00:05:09,500 --> 00:05:12,200
每当我收到error时,它是淡一些的红色;
whenever I get like an error, faded red; 

71
00:05:12,200 --> 00:05:16,425
当它是critical的时候,它是很明显的红色,表示有错误发生了.
and when it's critical, I have a bold red indicating something went wrong.

72
00:05:16,425 --> 00:05:19,125
在这里,输出非常短,
And here it's a really short output, 

73
00:05:19,125 --> 00:05:23,275
但是当你开始有成千上万行的日志时,
but when you start having thousands and thousands of lines of log,

74
00:05:23,275 --> 00:05:27,125
这不是华而不实,许多应用程序也每天都在做着这样的事儿,
which is not unrealistic and happens every single day in a lot of apps, 

75
00:05:27,125 --> 00:05:35,025
快速浏览并确定error区域的位置可以非常有用.
kind of quickly browsing through them and identifying where the error or the red patches can be really useful. 

76
00:05:35,025 --> 00:05:41,750
一个快速的旁注是,你可能会好奇终端是怎么显示这些颜色的.
A quick aside is, you might be curious about how the terminal is displaying these colors.

77
00:05:41,750 --> 00:05:45,250
归根结底,终端只输出字符.
At the end of the day, the terminal is only outputting characters.

78
00:05:45,250 --> 00:05:52,850
这个程序,还有像"ls"这样的程序,它们都有很多花哨的颜色,
Like, how is this program or how are other programs, like "ls",  that has all these fancy colors.  

79
00:05:52,850 --> 00:05:56,700
那么它们是如何告诉终端使用不同的颜色的呢?
How are they telling the terminal that it should use these different colors?

80
00:05:56,700 --> 00:06:03,725
其实这些工具所做的事情并不是非常复杂,大致上是这样的.
This is nothing extremely fancy, what these tools are doing, is something along these lines.

81
00:06:03,725 --> 00:06:08,600
这里有...我可以清除其余的输出,这样我们就可以专注于这个问题.
Here we have... I can clear the rest of the output, so we can focus on this. 

82
00:06:08,600 --> 00:06:14,650
这里有一些特殊字符,一些转义字符,
There's some special characters, some escape characters here,

83
00:06:14,650 --> 00:06:18,550
然后是一些文本,最后又是一些特殊字符.
then we have some text and then we have some other special characters. 

84
00:06:18,550 --> 00:06:22,625
如果我们执行这行代码,我们就会得到一个红色的"This is red".
And if we execute this line ,we get a red "This is red". 

85
00:06:22,625 --> 00:06:27,600
你可能已经注意到了,我们这里有一个"255;0;0",
And you might have picked up on the fact that we have a "255;0;0" here,

86
00:06:27,600 --> 00:06:31,625
这只是告诉终端我们想要的颜色的RGB值.
this is just telling the RGB values of the color we want in the terminal. 

87
00:06:31,625 --> 00:06:35,525
你几乎可以在你任何的代码中做到这一点,
And you pretty much can do this in any piece of code that you have, 

88
00:06:35,525 --> 00:06:38,225
这样你就可以给输出编码上颜色了.
and like that you can color code the output.

89
00:06:38,225 --> 00:06:42,975
你的终端可以相当花哨,它支持输出许多不同的颜色.
Your terminal is fairly fancy and supports a lot of different colors in the output. 

90
00:06:42,975 --> 00:06:45,575
这还不是全部,只有十六分之一.
This is not even all of them, this is like a sixteenth of them.

91
00:06:45,575 --> 00:06:49,750
我认为了解这个可能非常有用.
And I think it can be fairly useful to know about that.

92
00:06:49,750 --> 00:06:58,900
另一个问题是,也许你不喜欢或者觉得日志不适合你.
Another thing is maybe you don't enjoy or you don't think logs are really fit for you.

93
00:06:58,900 --> 00:07:02,925
但是,许多其他系统都会使用日志.
The thing is a lot of other systems that you might start using will use logs. 

94
00:07:02,925 --> 00:07:07,750
随着你构建越来越大的系统,你可能会有其他依赖项.
As you start building larger and larger systems,you might rely on other dependencies. 

95
00:07:07,750 --> 00:07:12,125
常见的依赖项可能是Web服务器或数据库,这是非常常见的.
Common dependencies might be web servers or databases, it's a really common one.

96
00:07:12,125 --> 00:07:18,075
这些依赖项会在自己的日志中记录它们的错误或异常.
And those will be logging their errors or like exceptions in their own logs.

97
00:07:18,075 --> 00:07:20,600
当然,你会收到一些客户端错误,
Of course, you will get some client-side error, 

98
00:07:20,600 --> 00:07:26,000
但有时候这些错误信息并不足以让你弄清楚发生了什么.
but those sometimes are not informative enough for you to figure out what is going on.

99
00:07:26,000 --> 00:07:34,250
在大多数UNIX系统中,日志通常放在一个名为"/var/log"的文件夹下,
In most UNIX systems, the logs are usually placed under a folder called "/var/log"

100
00:07:34,250 --> 00:07:43,425
如果我们列出它,我们就可以看到许多日志内容.
and if we list it, we can see there's like a bunch of logs in here.

101
00:07:43,425 --> 00:07:48,275
我们有关机日志,一些周日志等等
So we have like the shutdown monitor log, or some weekly logs.

102
00:07:48,275 --> 00:07:53,175
还有比如与Wi-Fi相关的事情.
Things related to the Wi-Fi, for example. 

103
00:07:53,175 --> 00:08:01,425
如果我们查看系统日志,里面有很多系统信息,
And if we output the system log, which contains a lot of information about the system, 

104
00:08:01,425 --> 00:08:04,275
我们就可以知道正在发生的事情.
we can get information about what's going on.

105
00:08:04,275 --> 00:08:10,725
同样,有一些工具可以让你更好地阅读日志.
Similarly, there are kind of tools that will let you more sanely go through this output. 

106
00:08:10,725 --> 00:08:15,650
在这里,我可以查看系统日志,
But here, looking at the system log,I can look at this and say: 

107
00:08:15,650 --> 00:08:23,000
发现:哦,有一些服务以异常代码退出了,
oh there's some service that is kind of exiting with some abnormal code   

108
00:08:23,000 --> 00:08:27,025
基于这些信息,我可以去看看发生了什么错误.
And based on that information, I can go and try to figure out what's going on,like what's going wrong. 

109
00:08:27,025 --> 00:08:32,200
当你使用日志时需要知道的一件事是,
One thing to know when you're working with logs is that

110
00:08:32,200 --> 00:08:36,700
一般来说,每个软件都有自己的日志,
more traditionally, every software had their own log, 

111
00:08:36,700 --> 00:08:42,900
比起过去,现在更流行的是将所有日志都放在系统日志中.
but it has been increasingly more popular to have a unified system log where everything is placed.

112
00:08:42,900 --> 00:08:47,525
几乎任何应用程序都可以记录进系统日志,
And you can, like....Pretty much any application can log into the system log, 

113
00:08:47,525 --> 00:08:49,950
但它们不是以普通文本格式存储,
but instead of being in a plain text format,

114
00:08:49,950 --> 00:08:52,625
而是以某种特殊格式进行压缩.
it will be compressed in some special format. 

115
00:08:52,625 --> 00:08:56,675
我们在数据整理讲座中就讲到过一个例子,
An example of this, it was what we covered in the data wrangling lecture.

116
00:08:56,675 --> 00:09:00,075
就是我们当时使用的 "journalctl",
In the data wrangling lecture we were using the "journalctl", 

117
00:09:00,075 --> 00:09:04,275
它可以访问并输出日志的内容.
which is accessing the log and outputting all that output.

118
00:09:04,275 --> 00:09:10,125
这里在Mac上,现在使用的命令是 `log show`,它会显示大量信息.
Here in Mac, now the command is "log show", which will display a lot of information.

119
00:09:10,125 --> 00:09:16,175
这里我只会让它显示最近的十秒钟的日志,因为日志真的非常长,
I'm gonna just display the last ten seconds, because logs are really, really verbose and

120
00:09:16,175 --> 00:09:23,900
仅仅显示最近10秒钟的日志仍然会输出一大坨.
just displaying the last 10 seconds is still gonna output a fairly large amount of lines.

121
00:09:23,900 --> 00:09:28,425
我们看看正在发生啥事儿,
So if we go back through what's going on, 

122
00:09:28,425 --> 00:09:32,850
我们会发现有很多"...apple.."的进程正在运行,因为这是一台MacBook.
we here see that like a lot of "..apple.." things are going on, since this is a macbook.

123
00:09:32,850 --> 00:09:38,875
我们也许能在这里找到一些error,比如说系统问题.
And maybe we could find errors about like some system issue here.

124
00:09:38,875 --> 00:09:47,025
再强调一遍,它们相当长,所以你得练练你的数据整理技巧了,
Again they're fairly verbose, so you might want to practice your data wrangling techniques here.

125
00:09:47,025 --> 00:09:49,875
例如10秒钟就可能大约有500行日志,
Like 10 seconds equal to like 500 lines of logs, 

126
00:09:49,875 --> 00:09:55,350
你可以对每秒钟有多少日志有个概念.
so you can kind of make an idea of how many lines per second you're getting.

127
00:09:55,350 --> 00:10:03,150
日志不仅可以帮你分析其他程序,
And they're not only useful for figuring out some other programs' output,  

128
00:10:03,150 --> 00:10:06,200
也方便你自己记录程序的输出信息,以便随时排查问题
they're also useful for you, if you want to log there instead of into your own file.

129
00:10:06,200 --> 00:10:12,050
在Linux和Mac操作系统上,可以使用"logger"命令来记录日志。
So using the "logger" command, both like in linux and mac,

130
00:10:12,050 --> 00:10:19,350
比如说,我可以把 "Hello Logs" 记录在系统日志中.
You can say okay I'm gonna log this "Hello Logs" into like this system log.

131
00:10:19,350 --> 00:10:28,300
我们执行这个命令,然后查看一下最近一分钟的日志,
And we execute the command and then we can check by going through the last minute of logs,

132
00:10:28,300 --> 00:10:33,850
因为它就是刚刚才写进去的,然后再用"grep"搜索 "Hello", 就可以找到我们的刚刚的那条日志.
since it's gonna be fairly recent, and grepping for that "Hello" we find our entry. 

133
00:10:33,850 --> 00:10:37,575
我们发现最近创建的条目,显示了 "Hello Logs".
Fairly recent entry, that we just created that said "Hello Logs".

134
00:10:37,575 --> 00:10:43,675
随着你越来越熟悉这些工具,
And as you become more and more familiar with these tools, 

135
00:10:43,675 --> 00:10:51,050
你会发现自己使用日志的频率越来越高,
you will find yourself using the logs more and more often, 

136
00:10:51,050 --> 00:10:54,900
因为即使你有一些不曾察觉的bug,
since even if you have some bug that you haven't detected, 

137
00:10:54,900 --> 00:10:56,975
但是程序已经运行了一段时间,
and the program has been running for a while.

138
00:10:56,975 --> 00:10:59,225
说不定错误信息就会出现在日志中,
Maybe the information is already in the log,

139
00:10:59,225 --> 00:11:02,725
日志可以告诉你许多的信息来帮你排查问题.
it can tell you enough to figure out what is going on.

140
00:11:02,725 --> 00:11:06,725
然而,"printf调试"并不是万能的.
However, printf debugging is not everything. 

141
00:11:06,725 --> 00:11:08,850
现在我要介绍调试器.
So now I'm going to be covering debuggers.

142
00:11:08,850 --> 00:11:11,200
但首先我得问问,你们有啥问题吗?
But first any questions on logs so far? 

143
00:11:11,200 --> 00:11:15,350
那么你可以从日志中了解到什么样的信息?
So what kind of things can you figure out from the logs?

144
00:11:15,350 --> 00:11:19,000
像这个 "Hello Logs" 就表明在那个时间你执行了一些关于Hello的操作吗?
like this "Hello Logs" says that you did something with Hello at that time? 

145
00:11:19,000 --> 00:11:25,225
是的,例如,我可以编写一个Bash脚本来检测... 
Yeah, like say, for example, like I can write a bash script that...

146
00:11:25,225 --> 00:11:29,750
来检查我啥时候连接到了哪个Wi-Fi.
Well, that checks every time what Wi-Fi network I'm connected to. 

147
00:11:29,750 --> 00:11:32,325
每当它检测到连接的网络已更改,
And every time it detects that it has changed,

148
00:11:32,325 --> 00:11:34,450
它就会在日志中创建一个条目,并说:
it makes an entry in the logs and says

149
00:11:34,450 --> 00:11:37,550
"哦,现在我们已经更换了Wi-Fi网络."
"Oh, now it looks like we have changed Wi-Fi networks."

150
00:11:37,550 --> 00:11:41,750
然后你可以回过头来查看日志,比如:
And then you might go back and parse through the logs and take like, 

151
00:11:41,750 --> 00:11:45,175
"好的,我的电脑是何时从一个Wi-Fi网络切换到另一个网络的?"
"okay, when did my computer change from one Wi-Fi network to another? "

152
00:11:45,175 --> 00:11:48,375
这只是一个简单的例子,
And this is just kind of like a simple example.

153
00:11:48,375 --> 00:11:53,875
但实际上有许多许多类型的信息可以被记录到日志里.
But there are many, many ways, many types of information that you could be logging here.

154
00:11:53,875 --> 00:11:59,450
举个更普遍的例子,
More commonly, you will probably want to check like if your computer, for example, is

155
00:11:59,450 --> 00:12:05,150
你可能想要检查你的电脑是否因为某些未知原因进入了睡眠状态,比如它正处于休眠模式.
entering sleep, for example, for some unknown reason. Like it's on hibernation mode.

156
00:12:05,150 --> 00:12:07,625
日志中可能会有一些信息来说明
There's probably some information in the logs about 

157
00:12:07,625 --> 00:12:10,850
谁让它它进入了睡眠状态,或者为啥会进入睡眠状态.
who asked that to happen, or like why it's that happening.

158
00:12:12,075 --> 00:12:15,400
还有其他问题吗?好的.
Any other questions? Okay. 

159
00:12:15,400 --> 00:12:18,150
所以当"printf调试"不够用时,
So when printf debugging is not enough,

160
00:12:18,150 --> 00:12:23,100
最好的替代方法是使用...
the best alternative after that is using...

161
00:12:23,100 --> 00:12:25,675
先退出这个玩意儿.
Exit that.

162
00:12:26,950 --> 00:12:31,300
所以替代方法是用调试器.
So, it's using a debugger. 

163
00:12:31,300 --> 00:12:38,750
调试器是一种工具,它会让你运行你的代码,
So a debugger is kind of a tool that will wrap around your code and will let you run your code,

164
00:12:38,750 --> 00:12:40,400
但它会对程序进行控制以便帮助你找到问题所在.
but it will kind of keep control over it. 

165
00:12:40,400 --> 00:12:47,275
比如说它可以让你设置断点并逐步执行代码.
So it will kind of let you step through the code and execute it and set breakpoints.

166
00:12:47,275 --> 00:12:49,775
如果你曾经使用过IDE,
You probably have seen debuggers in some way, 

167
00:12:49,775 --> 00:12:54,500
你可能已经看到过调试器,因为IDE有这个的功能:
if you have ever used something like an IDE, because IDEs have this kind of fancy: 

168
00:12:54,500 --> 00:12:56,150
在这里设置个断点,然后执行...
set a breakpoint here, execute, ...

169
00:12:56,150 --> 00:12:58,750
但是归根结底,这些工具使用的
But at the end of the day what these tools are using is 

170
00:12:58,750 --> 00:13:00,825
还是命令行调试器,
just these command line debuggers 

171
00:13:00,825 --> 00:13:05,200
只不过IDE里的调试器格式更花哨一些.
and they're just presenting them in a really fancy format.

172
00:13:05,200 --> 00:13:10,275
在这里,我们有一个错误的冒泡排序,一个很简单的排序算法.
Here we have a completely broken bubble sort, a simple sorting algorithm.

173
00:13:10,275 --> 00:13:11,550
不用过于关注算法细节.
Don't worry about the details.

174
00:13:11,550 --> 00:13:15,600
这里,我们只是想要对这个数组进行排序.
But we just want to sort this array that we have here.

175
00:13:15,600 --> 00:13:23,250
我们可以执行`python bubble.py`.
And we can try doing that by just doing "python bubble.py"

176
00:13:23,250 --> 00:13:25,050
当我们这样做时...
And when we do that... 

177
00:13:25,050 --> 00:13:28,525
这里说,索引错误,列表索引超出范围.
Say, Oh there's some index error, list index out of range. 

178
00:13:28,525 --> 00:13:30,725
这里我们可以添加打印语句进行调试,
We could start adding prints

179
00:13:30,725 --> 00:13:34,300
但如果字符串很长,我们可能会得到很多信息.
but if have a really long string, we can get a lot of information. 

180
00:13:34,300 --> 00:13:38,375
那我们该咋回到程序崩溃的那一时刻呢?
So how about we go up to the moment that we crashed?

181
00:13:38,375 --> 00:13:43,375
我们可以回到那个时刻并检查当时程序的状态.
We can go to that moment and examine what the current state of the program was.

182
00:13:43,375 --> 00:13:49,350
所以,为了做到这一点,我将使用Python调试器来运行程序.
So for doing that I'm gonna run the program using the Python debugger.

183
00:13:49,350 --> 00:13:52,050
在这里,我用的是ipython调试器,
Here I'm using technically the ipython debugger, 

184
00:13:52,200 --> 00:13:54,309
因为它有漂亮的高亮颜色,
just because it has nice coloring syntax 

185
00:13:54,309 --> 00:14:01,650
可以让我们更容易理解输出中正在发生的事情.
so it's probably easier for both of us to understand what's going on in the output. 

186
00:14:01,650 --> 00:14:05,500
但调试器基本上都没啥区别.
But they're pretty much identical anyway.

187
00:14:05,500 --> 00:14:09,275
我们执行这个命令,现在我们得到一个提示符,
So we execute this, and now we are given a prompt 

188
00:14:09,275 --> 00:14:14,700
告诉我们我们目前我们处于程序的第一行.
where we're being told that we are here, at the very first line of our program.

189
00:14:14,700 --> 00:14:15,975
我们可以...... 
And we can... 

190
00:14:15,975 --> 00:14:21,000
"l"代表"list",所以和许多调试器一样,
"l" stands for "list", so as with many of these tools

191
00:14:21,000 --> 00:14:24,575
有一种供你调试的操作语言,
there's kind of like a language of operations that you can do, 

192
00:14:24,575 --> 00:14:29,075
它们通常是助记符,就像vim或tmux一样.
and they are often mnemonic, as it was the case with vim or tmux.

193
00:14:29,075 --> 00:14:33,675
所以在这里,"l"是为了"list"代码,我们可以看到整个代码.
So here, "l" is for "listing" the code,  and we can see the entire code.

194
00:14:33,675 --> 00:14:42,775
"s"代表"step",它可以让我们逐行执行代码.
"s" is for "step" and will let us kind of one line at a time, go through the execution.

195
00:14:42,775 --> 00:14:47,500
问题是,我们只会再某个时刻才会触发error.
The thing is we're only triggering the error some time later.

196
00:14:47,500 --> 00:14:55,700
所以这里我们重新启动程序,而不是尝试一行行执行直到走到错误发生的地方,
So we can restart the program and instead of trying to step until we get to the issue,

197
00:14:55,700 --> 00:15:01,250
我们可以只要求程序继续运行,即"c"命令,然后我们就到了问题所在.
we can just ask for the program to continue which is the "c" command and

198
00:15:01,250 --> 00:15:07,750
嘿,我们到这一行的时候,程序就崩溃了,
hey, we reached the issue. We got to this line where everything crashed,

199
00:15:07,750 --> 00:15:11,450
我们得到了这个"list index out of range"错误.
we're getting this "list index out of range". 

200
00:15:11,450 --> 00:15:14,200
现在我们可以说...
And now that we are here we can say...

201
00:15:14,200 --> 00:15:22,000
好的,首先,让我们打印数组的值这.是当前数组的值,
Okay, first, let's print the value of the array. This is the value of the current array

202
00:15:22,000 --> 00:15:25,000
所以这个数组有六个数.好的.
So we have six items. Okay. 

203
00:15:25,000 --> 00:15:27,375
那这里"j"的值是多少?
What is the value of "j" here? 

204
00:15:27,375 --> 00:15:31,625
所以这里我们查看"j"的值".j"在这里是5,它是最后一个元素,
So we look at the value of "j". "j" is 5 here, which will be the last element, 

205
00:15:31,625 --> 00:15:38,200
但"j+1"将是6,所以这里越界了.
but "j" plus 1 is going to be 6, so that's triggering the out of bounds error.

206
00:15:38,200 --> 00:15:44,075
所以我们要做的是,这个"n",不是"n",而是"n-1".
So what we have to do is this "n", instead of "n" has to be "n-1". 

207
00:15:44,075 --> 00:15:47,400
我们已经确定错误出现在这里.
We have identified that the error lies there.

208
00:15:47,400 --> 00:15:51,650
所以我们可以退出,也就是"q".
So we can quit, which is "q". 

209
00:15:51,650 --> 00:15:55,225
因为它是一个后期调试器.
Again, because it's a post-mortem debugger.

210
00:15:55,225 --> 00:16:01,075
我们回到代码并说,(好的)
We go back to the code and say (okay),

211
00:16:02,900 --> 00:16:06,500
我们需要添加这个"n-1".
we need to append this "n-1". 

212
00:16:06,500 --> 00:16:10,075
这将防止列表索引越界,
That will prevent the list index out of range

213
00:16:10,075 --> 00:16:17,049
如果我们不使用调试器,再次运行此代码,好的,现在没有错误了.
And if we run this again without the debugger, okay, no errors now. 

214
00:16:17,049 --> 00:16:19,000
但这不是我们想要的结果.
But this is not our sorted list.

215
00:16:19,000 --> 00:16:21,300
这是排好序的,但不是我们原来的那个列表.
This is sorted, but it's not our list. 

216
00:16:21,300 --> 00:16:23,950
列表中的一些元素没了,
We are missing entries from our list, 

217
00:16:23,950 --> 00:16:27,050
所以我们在这里又遇到了bug.
so there is some behavioral issue that we're reaching here.

218
00:16:27,050 --> 00:16:32,600
我们依然可以使用"printf调试",但现在有一种预感,
Again, we could start using printf debugging, but kind of a hunch now is 

219
00:16:32,600 --> 00:16:37,300
可能我们在冒泡排序程序中交换元素的方法错了.
that probably the way we're swapping entries in the bubble sort program is wrong.

220
00:16:37,300 --> 00:16:40,950
我们可以使用调试器来解决这个问题.
And we can use the debugger for this. 

221
00:16:40,950 --> 00:16:44,825
我们可以运行到交换的位置停下来,
We can go through them to the moment we're doing a swap 

222
00:16:44,825 --> 00:16:48,525
然后看看元素的交换具体是如何执行的.
and check how the swap is being performed. 

223
00:16:48,525 --> 00:16:57,125
我们现在有两层for循环,在最里面的那层循环,
So a quick overview, we have two for loops and in the most nested loop,

224
00:16:57,125 --> 00:17:00,375
我们判断当前元素是否大于后一个元素.
we are checking if the array is larger than the other array. 

225
00:17:00,375 --> 00:17:04,050
问题是,如果我们只试图执行到这一行,
The thing is if we just try to execute until this line,

226
00:17:04,050 --> 00:17:07,050
它只会在我们进行交换时触发.
it's only gonna trigger whenever we make a swap. 

227
00:17:07,050 --> 00:17:12,175
所以我们可以在第六行设置一个断点.
So what we can do is we can set a breakpoint in the sixth line.

228
00:17:12,175 --> 00:17:17,250
我们可以在这一行创建一个断点,
We can create a breakpoint in this line  

229
00:17:17,250 --> 00:17:21,100
程序执行到交换变量时,程序就会停止.
and then the program will execute and the moment we try to swap variables is when the program is going to stop.

230
00:17:21,100 --> 00:17:26,300
所以我们在那里创建一个断点,然后继续执行程序.
So we create a breakpoint there and then we continue the execution of the program. 

231
00:17:26,300 --> 00:17:30,750
程序停止,并说"嘿,我已经执行到这一行了".
The program halts and says hey, I have executed and I have reached this line. 

232
00:17:30,750 --> 00:17:36,950
现在我们可以使用"locals()"函数,
Now I can use "locals()", which is a kind of Python function 

233
00:17:36,950 --> 00:17:41,650
它返回一个包含所有变量值的字典,以便我们快速查看上下文.
that returns a dictionary with all the values to quickly see the entire context. 

234
00:17:41,650 --> 00:17:48,675
字符串和数组都没问题,数组是好的,n是6....不过这只是一个交换的开始.
Say okay. The string, the array is fine and is six... Just the beginning and

235
00:17:48,675 --> 00:17:54,300
我继续执行下一行,哦,我找到了问题:
I step, go to the next line. Oh, and I identify the issue: 

236
00:17:54,300 --> 00:17:57,450
我只交换了一个变量,而不是把两个变量同时交换,
I'm swapping one item at a time, instead of simultaneously,

237
00:17:57,450 --> 00:18:02,250
这就是我们逐渐丢失变量的原因.
so that's what's triggering the fact that we're losing variables as we go through.

238
00:18:02,250 --> 00:18:07,325
这只是一个非常简单的例子,
That's kind of like a very simple example, 

239
00:18:07,350 --> 00:18:09,458
但调试器非常强大.
but debuggers are really powerful.

240
00:18:09,475 --> 00:18:13,500
大多数编程语言都会提供一些调试器,
Most programming languages will give you some sort of debugger, 

241
00:18:13,500 --> 00:18:19,900
当你进行更底层的调试时,你可能会用...
and when you go to more low level debugging you might run into tools like...

242
00:18:19,900 --> 00:18:26,800
你可能想使用类似于GDB这样的工具.
You might want to use something like GDB.

243
00:18:26,800 --> 00:18:38,050
GDB有个特点,它非常适用于C/C++这些类C语言.
And GDB has one nice property is GDB works really well with C/C++ and all these C-like languages.

244
00:18:38,050 --> 00:18:43,050
但是GDB实际上可以调试几乎任何可执行的二进制文件.
But GDB actually lets you work with pretty much any binary that you can execute. 

245
00:18:43,050 --> 00:18:44,550
例如,在这里,我们有一个sleep程序,
So for example here we have sleep, 

246
00:18:44,550 --> 00:18:47,725
它只是一个将休眠20秒的程序.
which is just a program that's going to sleep for 20 seconds.

247
00:18:47,725 --> 00:18:52,350
它被加载,然后我们可以执行`run`,
And It's loaded and then we can do "run", 

248
00:18:52,350 --> 00:18:55,825
然后我们发送个中断信号来中断它.
and then we can interrupt this sending an interrupt signal.

249
00:18:55,825 --> 00:19:02,425
GDB正在为我们展现程序中发生的非常底层的信息.
And GDB is displaying for us, here, very low-level information about what's going on in the program.

250
00:19:02,425 --> 00:19:07,425
因此,我们正在获取堆栈跟踪,我们可以看到我们在这个"nanosleep"函数中,
So we're getting the stack trace, we're seeing we are in this "nanosleep" function,

251
00:19:07,425 --> 00:19:12,100
我们可以看到机器上所有硬件寄存器的值.
we can see the values of all the hardware registers in your machine. 

252
00:19:12,100 --> 00:19:17,975
因此,你可以使用这些工具获取许多底层的详细信息.
So you can get a lot of low-level detail using these tools.

253
00:19:17,975 --> 00:19:26,175
我想这就是我想介绍调试器的所有内容了.你们有相关的问题?
And I think that's all I want to cover for debuggers. Any questions related to that?

254
00:19:33,600 --> 00:19:36,925
调试时另一个有趣的工具是,
Another interesting tool when you're trying to debug is that 

255
00:19:36,925 --> 00:19:42,525
当你的程序是一个黑盒的时候,你想调试它,
sometimes you want to debug as if your program is a black box. 

256
00:19:42,525 --> 00:19:45,125
因此,你可能知道程序的内部,
So you, maybe, know what the internals of the program 

257
00:19:45,125 --> 00:19:52,500
但同时,你的计算机也知道程序会在何时执行什么操作.
but at the same time your computer knows whenever your program is trying to do some operations.

258
00:19:52,500 --> 00:19:58,100
因此,在UNIX系统中,有这样一个概念,即用户级代码和内核级代码.
So this is in UNIX systems, there's this notion of like user level code and kernel level code.

259
00:19:58,100 --> 00:20:03,825
当你尝试执行一些操作,例如读取文件或读取网络连接时,
And when you try to do some operations like reading a file or like reading the network connection

260
00:20:03,825 --> 00:20:05,775
你得执行所谓的系统调用.
you will have to do something called system calls. 

261
00:20:05,775 --> 00:20:11,525
你可以获取一个程序并查看其操作,
And you can get a program and go through those operations 

262
00:20:11,525 --> 00:20:18,775
询问此软件执行了哪些操作?
and ask what operations did this software do? 

263
00:20:18,775 --> 00:20:21,600
例如,如果你有一个函数,
So for example, if you have like a Python function

264
00:20:21,600 --> 00:20:27,000
它本应该只能用来做数学运算,你通过这个程序运行该函数,
that is only supposed to do a mathematical operation and you run it through this program,

265
00:20:27,000 --> 00:20:28,850
却发现它实际上在读取文件,
and it's actually reading files, 

266
00:20:28,850 --> 00:20:30,000
这是为什么?
Why is it reading files? 

267
00:20:30,000 --> 00:20:31,450
它不应该读取文件.
It shouldn't be reading files. 

268
00:20:31,450 --> 00:20:32,950
那么,
So, let's see.

269
00:20:34,225 --> 00:20:37,800
我们可以使用"strace"这个工具.
This is "strace". 

270
00:20:37,800 --> 00:20:39,425
例如,我们可以这样做.
So for example, we can do it something like this. 

271
00:20:39,425 --> 00:20:41,650
我们将运行"ls - l"命令,
So here we're gonna run the "ls - l"

272
00:20:41,650 --> 00:20:45,700
忽略"ls"的输出,
And then we're ignoring the output of "ls", 

273
00:20:45,700 --> 00:20:48,000
但不忽略"strace"的输出.
but we are not ignoring the output of "strace".

274
00:20:48,000 --> 00:20:50,675
如果我们执行这个命令,
So if we execute that... 

275
00:20:52,425 --> 00:20:54,475
我们将得到一大坨输出.
We're gonna get a lot of output.

276
00:20:54,475 --> 00:20:58,375
这是执行这个"ls"所需要的所有的系统调用,
This is all the different system calls that this "ls" has executed. 

277
00:21:03,875 --> 00:21:07,875
你会看到很多"open"调用,你会看到"fstat".
You will see a bunch of "open", you will see "fstat".

278
00:21:07,875 --> 00:21:13,775
例如,因为它必须列出在此文件夹中所有文件的属性,
And for example, since it has to list all the properties of the files that are in this folder, 

279
00:21:13,775 --> 00:21:17,700
我们可以看看"lstat"调用.
we can check for the "lstat" call. 

280
00:21:17,700 --> 00:21:20,625
因此,"lstat"是用来查看文件的属性,
So the "lstat" call will check for the properties of the files 

281
00:21:20,625 --> 00:21:27,025
我们可以看到,实际上所有在此目录中的文件和文件夹
and we can see that, effectively, like all the files and folders that are in this directory

282
00:21:27,025 --> 00:21:32,200
都是通过系统调用(比如"ls")来访问的.
have been accessed through a system call, through "ls".

283
00:21:33,750 --> 00:21:45,400
有趣的是,有时你实际上不需要运行代码
Interestingly, sometimes you actually don't need to run your code to figure out 

284
00:21:45,400 --> 00:21:47,175
就可以找出代码中的问题.
that there is something wrong with your code. 

285
00:21:47,175 --> 00:21:53,275
到目前为止,我们已经看到了足够多的通过运行代码来排查问题的方式,
And like so far we have seen enough ways of identifying issues by running the code,

286
00:21:53,275 --> 00:21:54,450
但如果...
But what if you... 

287
00:21:54,450 --> 00:21:57,175
你可以看一下我现在屏幕上显示的这段代码,
You can look at a piece of code like this, like the one I have shown right now in this screen,

288
00:21:57,175 --> 00:22:00,600
你也可以找到一个问题.
and identify an issue. 

289
00:22:00,600 --> 00:22:04,575
例如,这里我们有一些非常简单的代码.
So for example here, we have some really silly piece of code. 

290
00:22:04,600 --> 00:22:09,120
它定义了一个函数,打印几个变量,乘了一些数,
It defines a function, prints a few variables,multiplies some variables, 

291
00:22:09,120 --> 00:22:12,075
然后等待一段时间,然后我们尝试打印"baz".
it sleeps for a while and then we try to print "baz". 

292
00:22:12,075 --> 00:22:17,100
你可以试着看这个代码,然后说,"baz"从未定义过.
And you could try to look at this and say, hey, "baz" has never been defined anywhere. 

293
00:22:17,100 --> 00:22:18,825
这是一个新的变量.
This is a new variable. 

294
00:22:18,825 --> 00:22:22,650
你可能想说"bar",但你打错了.
You probably meant to say "bar",but you just mistyped it. 

295
00:22:22,650 --> 00:22:26,525
问题是,如果我们尝试运行此程序,
Thing is,  if we try to run this program, 

296
00:22:26,525 --> 00:22:34,650
它将需要60秒,因为我们必须等待"time.sleep(60)"完成.
it's gonna take 60 seconds, because like we have to wait until this "time.sleep" function finishes. 

297
00:22:34,650 --> 00:22:39,125
这里,"sleep"只是为了演示,
Here, "sleep" is just for motivating the example 

298
00:22:39,125 --> 00:22:42,975
实际上你可能比如说会加载一个数据集,
but in general you may be loading a data set that takes really long 

299
00:22:42,975 --> 00:22:44,625
因为将所有数据复制到内存中需要很长时间.
because you have to copy everything into memory.

300
00:22:44,625 --> 00:22:49,475
事实上,有些程序会将源代码作为输入,
And the thing is, there are programs that will take source code as input, 

301
00:22:49,475 --> 00:22:54,450
对其进行处理,并指出代码的哪些部分可能是错误的.
will process it and will say, oh probably this is wrong about this piece of code. 

302
00:22:54,450 --> 00:23:00,825
在一般情况下,这些被称为静态分析工具.
In general, these are called static analysis tools.

303
00:23:00,825 --> 00:23:03,225
在Python中,静态分析工具有例如"pyflakes".
In Python we have for example "pyflakes". 

304
00:23:03,225 --> 00:23:07,175
如果我们将这段代码输入"pyflakes"中,
If we get this piece of code and run it through "pyflakes",

305
00:23:07,175 --> 00:23:11,313
"pyflakes"会给我们指出两个问题第.一个问题是......
"pyflakes" is gonna give us a couple of issues. First one is the one.... 

306
00:23:11,313 --> 00:23:16,075
第二个问题是我们已经指出的:这里有一个未定义的变量名叫做"baz".
The second one is the one we identified: like here's an undefined name called "baz".

307
00:23:16,075 --> 00:23:17,975
你可能需要对此进行处理.
You probably should be doing something about that. 

308
00:23:17,975 --> 00:23:27,925
另一个问题是:你正在重定义第3行中的"foo"变量名.
And the other one is like oh, you're redefining the "foo" variable name in that line. 

309
00:23:27,925 --> 00:23:31,500
所以,这里我们定义了一个"foo"函数,
So here we have a "foo" function and then we are kind of

310
00:23:31,500 --> 00:23:34,975
然后我们有一个循环变量也叫"foo",这会掩盖原来的"foo"函数.
shadowing that function by using a loop variable here. 

311
00:23:34,975 --> 00:23:38,725
现在我们定义的那个"foo"函数已经不可访问了,
So now that "foo" function that we defined is not accessible anymore

312
00:23:38,725 --> 00:23:41,825
如果我们之后尝试调用它,就会出现错误.
and then if we try to call it afterwards, we will get into errors.

313
00:23:43,875 --> 00:23:47,750
还有其他类型的静态分析工具.
There are other types of static analysis tools. 

314
00:23:47,750 --> 00:23:49,325
"mypy"是另一个静态分析python代码的工具.
"mypy" is a different one. 

315
00:23:49,325 --> 00:23:52,625
"mypy"会报告和"pyflakes"相同的两个错误,
"mypy" is gonna report the same two errors, 

316
00:23:52,625 --> 00:23:56,150
但它也会进行类型检查.
but it's also going to complain about type checking. 

317
00:23:56,150 --> 00:24:00,975
它会说,这里你正在将一个整数乘以一个浮点数,
So it's gonna say, oh here you're multiplying an int by a float and

318
00:24:00,975 --> 00:24:07,250
如果你你关注代码中变量的类型,你不应该混淆它们.
if you care about the type checking of your code,  you should not be mixing those up. 

319
00:24:07,250 --> 00:24:10,625
这可能有点不方便,需要运行这个工具,
It can be kind of inconvenient, kind of having to run this, 

320
00:24:10,625 --> 00:24:15,375
查看出错的行,然后回到你的vim或其他编辑器中,
look at the line, going back to your vim or kind of figure out in your editor, 

321
00:24:15,375 --> 00:24:17,600
再解决这些bug.
and figuring out what the error matches to.

322
00:24:17,600 --> 00:24:20,675
不过针对这个问题,已经有解决方案了.
There are already solutions for that. 

323
00:24:20,675 --> 00:24:28,050
一种方法是将大多数编辑器与这些工具集成在一起.
The way is that you can integrate most editors with these tools. 

324
00:24:28,050 --> 00:24:32,000
这里你可以看到bash上有一些红色的高亮,
And here you can see there is like some red highlighting on the bash, 

325
00:24:32,000 --> 00:24:34,700
你可以在底部查看到错误.
and it will read the last line here.

326
00:24:34,700 --> 00:24:36,275
未定义的变量 "baz".
So, undefined named 'baz'. 

327
00:24:36,275 --> 00:24:39,625
所以,当我编辑这段Python代码时,
So as I'm editing this piece of Python code,

328
00:24:39,625 --> 00:24:43,775
我的编辑器会给我反馈,告诉我这里有什么问题.
my editor is gonna give me feedback about what's going wrong with this. 

329
00:24:43,775 --> 00:24:49,650
或者,这里有另外一个问题,说你正在重新定义未使用的"foo".
Or like here have another one saying the redefinition of unused "foo".

330
00:24:49,650 --> 00:24:55,975
甚至,有些错误是关于代码风格的.
And even, there are some stylistic complaints.

331
00:24:55,975 --> 00:24:58,375
例如,这里期望有两个空行.
So, oh, I will expect two empty lines. 

332
00:24:58,375 --> 00:25:04,975
在Python中,函数定义之间应该有两行空行.
So like in Python, you should be having two empty lines between a function definition.

333
00:25:04,975 --> 00:25:06,950
emmm.....
There are... 

334
00:25:06,950 --> 00:25:09,925
在课程笔记中,有一个关于
There is a resource on the lecture notes about 

335
00:25:09,925 --> 00:25:13,575
不同编程语言的静态分析工具的资源.
pretty much static analyzers for a lot of different programming languages.

336
00:25:13,575 --> 00:25:17,700
甚至还有针对英语的静态分析工具.
There are even static analyzers for English.

337
00:25:17,950 --> 00:25:26,625
我有这门课的笔记,
So I have my notes for the class here, 

338
00:25:26,675 --> 00:25:30,800
把它传递给这个英语静态分析工具"writegood",
and if I run it through this static analyzer for English, that is "writegood".

339
00:25:30,800 --> 00:25:33,075
它会指出一些风格上的问题.
It's going to complain about some stylistic properties. 

340
00:25:33,075 --> 00:25:37,450
例如,"very"是一个模糊的词汇,我不应该使用它,
So like, oh, I'm using "very", which is a weasel word and I shouldn't be using it.

341
00:25:37,450 --> 00:25:39,425
"quickly"也会削弱含义.
Or "quickly" can weaken meaning, 

342
00:25:39,425 --> 00:25:48,750
你可以用它来检查拼写错误或进行很多不同类型的风格分析.
and you can have this for spell checking, or for a lot of different types of stylistic analysis.

343
00:25:48,750 --> 00:25:51,850
目前有什么问题吗?
Any questions so far?

344
00:25:58,650 --> 00:26:01,750
哦,我忘了提到......
Oh, I forgot to mention... 

345
00:26:01,750 --> 00:26:07,525
根据你正在执行的任务不同,将有不同类型的调试器可用.
Depending on the task that you're performing, there will be different types of debuggers.

346
00:26:07,525 --> 00:26:09,925
例如,如果你在进行Web开发,
For example, if you're doing web development, 

347
00:26:09,925 --> 00:26:20,975
比如说,Firefox和Chrome都有非常好的用于调试web的工具集.
Pretty much like both Firefox and Chrome have a really really good set of tools for doing debugging for websites.

348
00:26:20,975 --> 00:26:25,850
例如,我们在这里进行元素检查,我们可以得到......
So here we go and say inspect element, we can get the... 

349
00:26:25,850 --> 00:26:26,975
你有谁知道如何让这个大一点儿吗.....
Do you know how to make this larger a little bit? 

350
00:26:27,875 --> 00:26:33,200
我们得到了这门课网页的源代码.
We're getting like the entire source code for the web page for the class.

351
00:26:33,200 --> 00:26:38,225
哦,是的,我来给它放大一些
Oh, yeah, here we go. 

352
00:26:38,225 --> 00:26:39,825
这个好些了吗?
Is that better?

353
00:26:39,825 --> 00:26:45,500
现在我们可以实际上更改有关课程的属性.
And we can actually go and like change properties about the course. 

354
00:26:45,500 --> 00:26:47,850
我们可以编辑标题.
So we can say... we can edit the title.

355
00:26:47,850 --> 00:26:51,550
例如说,"Not Debugging and Profiling".
Say, this is not a class on debugging and profiling. 

356
00:26:51,550 --> 00:26:54,525
现在网站的代码已经改变了.
And now the code for the website has changed.

357
00:26:54,525 --> 00:26:58,775
这就是为什么你永远不能相信任何网页截图,
This is one of the reasons why you should never trust any screenshots of websites, 

358
00:26:58,775 --> 00:27:00,850
因为它们可以被随意修改.
because they can be completely modified.

359
00:27:00,850 --> 00:27:03,800
你还可以修改这个样式.
And you can also modify this style. 

360
00:27:03,800 --> 00:27:12,075
例如,这里我首选了深色主题,我们可以改变它.
Like, here I have things using the dark mode preference, but we can alter that. 

361
00:27:12,075 --> 00:27:16,900
因为无论如何,最终都是浏览器把这个内容呈现给我们.
Because at the end of the day, the browser is rendering this for us.

362
00:27:16,900 --> 00:27:22,450
我们可以检查cookie,但有很多不同的操作.
And we can check the cookies, but there's like a lot of different operations.

363
00:27:22,450 --> 00:27:28,525
JavaScript还有一个内置的调试器,因此你可以逐步调试JavaScript代码.
There's also a built-in debugger for JavaScript, so you can like step through JavaScript code.

364
00:27:28,525 --> 00:27:31,275
因此,总结一下,根据你所需要完成的任务,
So kind of the takeaway is, depending on what you are doing, 

365
00:27:31,275 --> 00:27:37,375
你可能需要搜索一些程序员为程序员自己开发的工具.
you will probably want to search for what tools programmers have built for them.

366
00:27:43,150 --> 00:27:50,200
现在让我们进入新的主题,不再谈论调试,
Now I'm gonna switch gears and stop talking about debugging, which is kind of finding issues with the code, kind of more about the behavior.

367
00:27:53,523 --> 00:27:57,075
而是开始讲如何进行性能分析.
and then start talking about like how you can use profiling.

368
00:27:57,075 --> 00:28:00,725
性能分析可以帮助你优化代码,
And profiling is how to optimize the code. 

369
00:28:00,725 --> 00:28:06,600
比如你想优化CPU,内存,网络等方面的性能.
And it might be because you want to optimize the CPU, the memory, the network, ...

370
00:28:06,600 --> 00:28:10,125
有许多不同的方面你想要进行优化.
There are many different reasons that you want to be optimizing it. 

371
00:28:10,125 --> 00:28:14,525
就像调试一样,
As it was the case with debugging, the kind of first-order approach

372
00:28:14,525 --> 00:28:16,950
很多人用的第一种方法是使用
that a lot of people have experience with already is 

373
00:28:16,950 --> 00:28:22,875
printf进行性能分析,例如...
oh, let's use just printf profiling, so to say, like we can just take...

374
00:28:22,875 --> 00:28:25,025
我先把这个放大点
Let me make this larger. 

375
00:28:25,025 --> 00:28:28,325
我们可以记录当前时间,
We can take the current time here,

376
00:28:28,325 --> 00:28:32,425
然后执行一些操作,
then we can check, we can do some execution 

377
00:28:32,475 --> 00:28:37,400
再记录一下时间,计算一下时间差.
and then we can take the time again and subtract it from the original time. 

378
00:28:37,400 --> 00:28:40,625
这样你就可以缩小范围,
And by doing this you can kind of narrow down 

379
00:28:40,625 --> 00:28:42,125
把代码的不同部分隔离开,
and fence some different parts of your code 

380
00:28:42,125 --> 00:28:46,450
分析不同模块之间的时间差.
and try to figure out what is the time taken between those two parts.

381
00:28:46,450 --> 00:28:50,900
这很好.但有时结果可能会有点意外.
And that's good. But sometimes it can be interesting, the results. 

382
00:28:50,900 --> 00:28:57,000
例如,这里我们sleep了0.5秒,输出结果显示是
So here, we're sleeping for 0.5 seconds and the output is saying, 

383
00:28:57,000 --> 00:29:01,875
0.5加上一些额外的时间,这很有趣.
oh it's 0.5 plus some extra time,which is kind of interesting. 

384
00:29:01,875 --> 00:29:06,400
如果我们继续运行它,我们会发现一些小的误差.
And if we keep running it, we see there's like some small error and 

385
00:29:06,400 --> 00:29:12,075
事实上,我们正在测量的是所谓的"实际时间".
the thing is here, what we're actually measuring is what is usually referred to as the "real time".

386
00:29:12,075 --> 00:29:16,875
实际时间就像你拿着一只钟表,
Real time is as if you get like a clock, 

387
00:29:16,875 --> 00:29:18,575
在程序开始时启动计时,
and you start it when your program starts, 

388
00:29:18,575 --> 00:29:19,700
程序结束时停止计时.
and you stop it when your program ends.

389
00:29:19,700 --> 00:29:23,775
但问题是,在你的计算机中,不仅仅只有你的那个程序在运行.
But the thing is, in your computer it is not only your program that is running.

390
00:29:23,775 --> 00:29:26,525
还有许多其他程序同时也在运行,
There are many other programs running at the same time 

391
00:29:26,525 --> 00:29:31,800
它们可能同样会占用CPU的资源.
and those might be the ones that are taking the CPU. 

392
00:29:31,800 --> 00:29:35,350
因此,为了理解这一点,
So, to try to make sense of that,

393
00:29:35,350 --> 00:29:37,775
emmm...
A lot of... 

394
00:29:37,775 --> 00:29:47,125
你会发现很多程序使用实际时间,用户时间和系统时间等术语.
You'll see a lot of programs using the terminology that is real time, user time and system time. 

395
00:29:47,125 --> 00:29:51,800
实际时间就是刚刚演示的,是指从程序开始运行到结束运行的总时间.
Real time is what I explained, which is kind of the entire length of time from start to finish.

396
00:29:51,800 --> 00:30:00,425
然后用户时间是指CPU执行用户级别的代码所用的时间.
Then there is the user time, which is the amount of time your program \N spent on the CPU doing user level cycles.

397
00:30:00,425 --> 00:30:02,425
正如我先前说的,在UNIX中,
So as I was mentioning, in UNIX, 

398
00:30:02,425 --> 00:30:06,225
你可以运行用户级代码或内核代码.
you can be running user level code or kernel level code.

399
00:30:06,225 --> 00:30:10,400
系统时间则是相反的,它是你的程序在CPU上
And system is kind of the opposite, it's the amount of CPU, 

400
00:30:10,400 --> 00:30:16,175
执行内核级别的指令所花费的时间.
like the amount of time that your program spent on the CPU executing kernel mode instructions. 

401
00:30:16,175 --> 00:30:18,925
让我来演示一下.
So let's show this with an example.

402
00:30:18,925 --> 00:30:22,525
这里我要使用一个名为"time"的命令,
Here I'm going to "time", which is a command,

403
00:30:22,525 --> 00:30:27,275
它计算接下来那个命令的这三个指标,
a shell command that's gonna get these three metrics for the following command, 

404
00:30:27,275 --> 00:30:32,971
然后下面那个命令我是在向一个西班牙的网站请求数据,获取响应.
and then I'm just grabbing a URL from a website that is hosted in Spain. 

405
00:30:32,975 --> 00:30:37,375
因此,信息的往返需要一些时间.
So that's gonna take some extra time to go over there and then go back.

406
00:30:37,375 --> 00:30:38,525
如果我们看到,这里,如果...
And if we see, here, if we were to just... 

407
00:30:40,100 --> 00:30:44,000
如果我们在程序的开头和结尾加上两个打印语句.
We have like two prints, between the beginning and the end of the program.

408
00:30:44,000 --> 00:30:48,400
我们可能会认为这个程序的执行需要大约600毫秒,
We could think that this program is taking like 600 milliseconds to execute, 

409
00:30:48,400 --> 00:30:57,175
但实际上大部分时间都花在等待网络响应上,
but actually most of that time was spent just waiting for the response on the other side of the network 

410
00:30:57,175 --> 00:31:01,600
而我们实际上只花了16毫秒的用户级别和9秒的系统时间,
and we actually only spent 16 milliseconds at the user level and like 9 seconds (at the sys level),

411
00:31:01,600 --> 00:31:07,146
实际上执行这个"curl"命令的时间总共只有25毫秒,
in total 25 milliseconds, actually executing "curl" code. 

412
00:31:07,146 --> 00:31:08,775
其他的时间都花了在等待上面.
Everything else was just waiting.

413
00:31:12,225 --> 00:31:15,175
有关于计时的问题吗?
Any questions related to timing?

414
00:31:19,775 --> 00:31:27,675
好的,所以计时可能会变得棘手,这是一种黑盒的分析方案.
Ok, so timing can become tricky, it's also kind of a black box solution. 

415
00:31:27,675 --> 00:31:29,425
如果你添加打印语句进行性能分析,
Or if you start adding print statements,

416
00:31:29,425 --> 00:31:34,025
那么关于时间的打印语句到处都是,这可能会使代码变得混乱且难以维护.
it's kind of hard to add print statements, with time everywhere. 

417
00:31:34,050 --> 00:31:36,500
程序员已经找到了更好的工具.
So programmers have figured out better tools.

418
00:31:36,500 --> 00:31:39,800
这些通常称为"分析器".
These are usually referred to as "profilers". 

419
00:31:39,800 --> 00:31:44,625
我要提醒一下的是,
One quick note that I'm gonna make, is that

420
00:31:44,625 --> 00:31:50,300
人们一般说的分析器通常是指CPU分析器,
profilers, like usually when people refer to profilers they usually talk about CPU profilers 

421
00:31:50,300 --> 00:31:55,725
因为它们最常用于记录程序在 CPU 上的运行情况.
because they are the most common, at identifying where like time is being spent on the CPU.

422
00:31:55,725 --> 00:32:00,125
分析器通常有两种类型:
And profilers usually come in kind of two flavors: 

423
00:32:00,125 --> 00:32:02,650
跟踪分析器和采样分析器.
there's like tracing profilers and sampling profilers.

424
00:32:02,650 --> 00:32:06,750
我们最好知道一下它们的区别,因为它们对应的输出会有所不同.
And it's kind of good to know the difference because the output might be different.

425
00:32:06,750 --> 00:32:11,000
跟踪分析器会在你的代码中插入一些东西.
And tracing profilers are kind of instrument your code. 

426
00:32:11,000 --> 00:32:16,350
它们会与你的代码一起执行,
So they kind of execute with your code and every time your code enters a function call,

427
00:32:16,350 --> 00:32:17,550
在程序进入函数调用时记录相关信息.
they kind of take a note of it. 

428
00:32:17,550 --> 00:32:20,950
就像这个时刻我们正在进入这个函数调用,
It's like, oh we're entering this function call at this moment in time 

429
00:32:20,950 --> 00:32:25,825
然后继续前进,一旦完成,它们可以告诉你
and they keep going and, once they finish, they can report  

430
00:32:25,825 --> 00:32:31,000
你在这个函数中执行了多少时间,在另一个函数中执行了多少时间,
oh, you spent this much time executing in this function and this much time in this other function. 

431
00:32:31,000 --> 00:32:34,675
以此类推,这就是我们等会会看到的例子.
So on, so forth, which is the example that we're gonna see now.

432
00:32:34,675 --> 00:32:38,650
另一种的工具是采样分析器.
Another type of tools are tracing, sorry, sampling profilers. 

433
00:32:38,650 --> 00:32:41,675
跟踪分析器的问题在于它们会给我们程序增加很多开销.
The issue with tracing profilers is they add a lot of overhead. 

434
00:32:41,675 --> 00:32:45,550
就像你可能正在运行你的代码,
Like you might be running your code and having these kind of

435
00:32:45,550 --> 00:32:51,780
并且它会在运行的时候进行这些统计分析,这将影响到程序的性能,
profiling next to you making all these counts, will hinder the performance of your program, 

436
00:32:51,780 --> 00:32:54,150
所以你可能会得到稍微偏差的数据.
so you might get counts that are slightly off.

437
00:32:54,150 --> 00:32:59,050
采样分析器会执行你的程序,
So a sampling profiler, what it's gonna do is gonna execute your program 

438
00:32:59,050 --> 00:33:03,375
并在每100毫秒,10毫秒或其他时间段内停止程序.
and every 100 milliseconds, 10 milliseconds, like some defined period, it's gonna stop your program, it's gonna halt it.

439
00:33:05,800 --> 00:33:12,425
它会查看堆栈的情况,并告诉你当前的位置
It's gonna look at the stack trace and say, oh, you're right now in this point in the hierarchy, 

440
00:33:12,425 --> 00:33:15,875
哪个函数正在执行等等信息.
and identify which function is gonna be executing at that point. 

441
00:33:15,875 --> 00:33:20,250
这个想法的核心是,在足够长的时间内执行程序并收集性能数据,
The idea is that as long as you execute this for long enough,

442
00:33:20,250 --> 00:33:25,275
我们就可以了解程序中开销最多的部分.
you're gonna get enough statistics to know where most of the time is being spent.

443
00:33:25,275 --> 00:33:28,975
接下来让我们看一个跟踪分析的例子.
So, let's see an example of a tracing profiling. 

444
00:33:28,975 --> 00:33:32,775
这里有一段Python代码,
So here we have a piece of code,

445
00:33:32,775 --> 00:33:38,025
它是对 "grep" 的一个简单的重新实现.
that is just like a really simple re-implementation of "grep" done in Python. 

446
00:33:38,025 --> 00:33:41,450
我们想要检查程序的瓶颈在哪里.
And what we want to check is what is the bottleneck of this program? 

447
00:33:41,450 --> 00:33:46,850
我们只是打开了一堆文件,试图匹配这个模式,
Like we're just opening a bunch of files,trying to match this pattern, 

448
00:33:46,850 --> 00:33:49,575
然后在找到匹配项时把它们打印出来.
and then printing whenever we find a match. 

449
00:33:49,575 --> 00:33:52,675
可能是正则表达式,也可能是打印操作,
And maybe it's the regex, maybe it's the print...

450
00:33:52,675 --> 00:33:54,125
我们不确定.
We don't really know. 

451
00:33:54,125 --> 00:34:00,275
为了在 Python 中进行跟踪性能分析,我们使用 "cProfile".
So to do this in Python, we have the "cProfile".

452
00:34:00,300 --> 00:34:03,775
我调用这个"cProfile"模块,
And here I'm just calling this module 

453
00:34:03,775 --> 00:34:06,950
说我想按总时间排序,
and saying I want to sort this by the total amount of time, 

454
00:34:06,950 --> 00:34:08,800
我们很快会看到结果.
that we're gonna see briefly. 

455
00:34:08,800 --> 00:34:14,000
我调用刚才那个python程序.
I'm calling the program we just saw in the editor.

456
00:34:14,000 --> 00:34:16,050
我要执行这个程序一千次,
I'm gonna execute this a thousand times 

457
00:34:16,050 --> 00:34:20,300
然后将 grep 的参数在这里,
and then I want to match the grep arguments here

458
00:34:20,300 --> 00:34:25,476
我想对所有 Python 文件进行这个正则表达式的匹配查找.
is I want to match these regex to all the Python files in here. 

459
00:34:28,400 --> 00:34:34,100
这将产生一些输出,然后我们来看看.
And this is gonna output some...This is gonna produce some output, then we're gonna look at it. 

460
00:34:34,100 --> 00:34:38,385
首先是"grep.py"的输出,
First, is all the output from the greps,  

461
00:34:38,385 --> 00:34:41,800
在最后,我们看到了分析器的输出.
but at the very end, we're getting output from the profiler itself. 

462
00:34:41,800 --> 00:34:51,322
如果我们向上滚动,我们可以看到,通过排序,我们可以看到总调用次数.
And if we go up,we can see that, hey, by sorting we can see that the total number of calls. 

463
00:34:51,322 --> 00:34:57,375
因为我们执行了这个程序一千次,所以我们执行了8000次调用,
So we did 8000 calls, because we executed this 1000 times and

464
00:34:57,375 --> 00:35:02,500
这是我们在这个函数中花费的总时间(累计时间).
this is the total amount of time we spent in this function (cumulative time). 

465
00:35:02,500 --> 00:35:06,425
这样我们就可以找到程序的主要开销在哪,
And here we can start to identify where the bottleneck is. 

466
00:35:06,425 --> 00:35:09,850
这个内置方法 "io.open" 表示
So here, this built-in method "io.open", is saying that 

467
00:35:09,850 --> 00:35:14,700
我们花费了大量时间等待从磁盘读取数据.
we're spending a lot of the time just waiting for reading from the disk ... 

468
00:35:14,700 --> 00:35:20,075
或者在这里,我们可以看到,匹配正则表达式也花了大量时间,
Or there, we can check, hey, a lot of time is also being spent trying to match the regex.

469
00:35:20,075 --> 00:35:22,400
这是你可能已经预料到的,
which is something that you will expect. 

470
00:35:22,400 --> 00:35:28,125
使用此追踪分析器的一个不好是,
One of the caveats of using this tracing profiler is that, 

471
00:35:28,125 --> 00:35:31,475
正如我们所看到的,我们看到了我们的函数,
as you can see, here we're seeing our function 

472
00:35:31,475 --> 00:35:35,850
但也看到了很多对应的内置函数.
but we're also seeing a lot of functions that correspond to built-ins.

473
00:35:35,850 --> 00:35:39,375
比如来自其他库的第三方函数之类的.
So like, functions that are third party functions from the libraries. 

474
00:35:39,375 --> 00:35:42,275
随着你构建的代码越来越复杂,
And as you start building more and more complex code,

475
00:35:42,275 --> 00:35:44,125
可读性就会变得非常差.
This is gonna be much harder. 

476
00:35:44,125 --> 00:35:52,575
这里是另一段Python代码,你们不需要阅读它,
So here is another piece of Python code that, don't read through it.

477
00:35:52,575 --> 00:35:58,525
它只是获取课程网站,
What it's doing is just grabbing the course website and then it's printing all the...

478
00:35:58,525 --> 00:36:01,975
然后解析它,再打印出所有的超链接.
It's parsing it, and then it's printing all the hyperlinks that it has found. 

479
00:36:01,975 --> 00:36:04,050
因此有这两个操作:
So there are like these two operations:

480
00:36:04,050 --> 00:36:07,875
前往该网站,获取并解析它,然后打印链接.
going there, grabbing a website, and then parsing it, printing the links. 

481
00:36:07,875 --> 00:36:09,800
我们可能想要了解
And we might want to get a sense of

482
00:36:09,800 --> 00:36:12,875
这两个操作之间的比较.
how those two operations compare to each other. 

483
00:36:12,875 --> 00:36:20,775
如果我们尝试执行cProfiler.
If we just try to execute the cProfiler here. 

484
00:36:20,775 --> 00:36:22,650
我们将执行相同的操作,这不会打印任何内容.
And we're gonna do the same, this is not gonna print anything.

485
00:36:22,650 --> 00:36:26,275
这里用了一个之前我们没有见过的一个工具,但我认为它很好用.
I'm using a tool we haven't seen so far,but I think it's pretty nice. 

486
00:36:26,275 --> 00:36:28,400
它是"tac",是"cat"的反向,
It's "tac", which is the opposite of "cat", 

487
00:36:28,400 --> 00:36:33,725
它会反向打印输出,因此我等会不必向上翻找.
and it is going to reverse the output so I don't have to go up and look.

488
00:36:33,725 --> 00:36:36,225
我们执行这个命令,
So we do this and... 

489
00:36:36,225 --> 00:36:39,650
嘿,我们得到了一些有趣的输出.
Hey, we get some interesting output.

490
00:36:39,650 --> 00:36:44,925
我们在内置方法"_socket_getaddrinfo","_imp_create_dynamic",
we're spending a bunch of time in this built-in method "_socket_getaddrinfo" and like in "_imp_create_dynamic"

491
00:36:44,925 --> 00:36:49,125
"method 'connect'"中花费了大量的时间,还有"posix.stat"...,
and "method 'connect'" and "posix.stat"... 

492
00:36:49,200 --> 00:36:53,500
我的代码中没有直接调用这些函数,
Nothing in my code is directly calling these functions  

493
00:36:53,500 --> 00:36:58,700
因此我不太清楚在进行网络请求和解析请求结果之间的操作分割线在哪里
so I don't really know what is the split between the operation of making a web request and parsing the output of that web request. 

494
00:37:01,600 --> 00:37:04,850
为此,我们可以使用一个不同类型的分析器,即基于行的性能分析器.
So, for that, we can use a different type of profiler which is a line profiler. 

495
00:37:11,925 --> 00:37:14,575
基于行的性能分析器只会以更可读的方式呈现相同的结果,
And the line profiler is just going to present the same results but in a more human-readable way, 

496
00:37:16,825 --> 00:37:21,175
对于这行代码,这是要花相当的时间的.
which is just for this line of code, this is the amount of time things took.

497
00:37:21,175 --> 00:37:32,325
我们必须向Python函数添加一个装饰器来完成这项工作.
So it knows it has to do that, we have to add like a decorator to the Python function, we do that.

498
00:37:34,675 --> 00:37:40,025
当我们这样做之后,现在我们得到了略微裁剪过的输出,
And as we do that, we now get slightly cropped output, 

499
00:37:40,025 --> 00:37:43,125
更主要的是,是我们现在可以查看时间百分比,
but the main idea, we can look at the percentage of time 

500
00:37:43,125 --> 00:37:45,500
并且我们可以看到进行此请求,获取页面所花费的时间占总时间的88%,
and we can see that making this request, get operation, took 88% of the time,

501
00:37:45,500 --> 00:37:53,175
而解析响应所花费的时间仅占10.9%.
whereas parsing the response took only 10.9% of the time.

502
00:37:53,175 --> 00:37:56,131
它可以提供非常有意义的信息,
And this can be really informative 

503
00:37:56,131 --> 00:38:01,956
许多不同的编程语言都将支持这种基于行的性能分析.
and a lot of different programming languages will support this type of a line profiling.

504
00:38:04,350 --> 00:38:07,875
有时你可能不关心 CPU 的性能,
Sometimes, you might not care about CPU. 

505
00:38:07,875 --> 00:38:11,475
也许你关心内存或其他资源.
Maybe you care about the memory or like some other resource. 

506
00:38:11,475 --> 00:38:15,550
同样地,也有内存分析器:
Similarly, there are memory profilers: 

507
00:38:15,550 --> 00:38:18,825
在 Python 中有 "memory_profiler",在 C 中有 "Valgrind".
in Python there is "memory_profiler", for C you will have "Valgrind". 

508
00:38:18,825 --> 00:38:22,150
这里是一个相当简单的例子,
So here is a fairly simple example,

509
00:38:22,150 --> 00:38:25,475
我们只是创建了一个包含一百万个元素的列表.
we just create this list with a million elements. 

510
00:38:25,475 --> 00:38:29,650
这将占用大约几MB的空间,
That's going to consume like megabytes of space and

511
00:38:29,650 --> 00:38:33,175
我们再创建另一个包含两千万个元素的列表.
we do the same, creating another one with 20 million elements.

512
00:38:33,175 --> 00:38:38,725
为了检查内存分配是怎么样的?
And to check, what will be the memory allocation? 

513
00:38:38,725 --> 00:38:42,625
会发生什么,消耗多少内存?
How it's gonna happen, what's the consumption? 

514
00:38:42,625 --> 00:38:46,500
我们可以使用一个内存分析器来执行这个程序,
We can go through one memory profiler and we execute it, 

515
00:38:46,500 --> 00:38:51,350
内存分析器会告诉我们总内存使用量和增量.
and it's telling us the total memory usage and the increments.

516
00:38:51,350 --> 00:38:54,225
我们可以看到一些开销,
And we can see that we have some overhead, 

517
00:38:54,225 --> 00:39:01,475
因为这是一种解释性语言,当我们创建一个包含一百万条条目的列表时,
because this is an interpreted language and then when we create this list with a million entries,

518
00:39:01,475 --> 00:39:07,950
我们将需要这么多MB的信息.
we're gonna need this many megabytes of information. 

519
00:39:07,950 --> 00:39:11,200
然后我们又得到了另外 150 MB.
Then we were getting another 150 megabytes. 

520
00:39:11,200 --> 00:39:15,825
接下来,我们释放了这个条目,总量就减少了.
Then, we're freeing this entry and that's decreasing the total amount.

521
00:39:15,825 --> 00:39:19,775
我们没有得到负的增量,可能是分析器本身有 bug.
We are not getting a negative increment because of a bug probably in the profiler. 

522
00:39:19,775 --> 00:39:23,425
但是,如果你知道你的程序占用了大量内存,
But if you know that your program is taking a huge amount of memory 

523
00:39:23,425 --> 00:39:27,050
而你不知道为什么,
and you don't know why,  

524
00:39:27,050 --> 00:39:29,875
经常出现的一个原因可能是因为你在复制对象,而不是在原地进行操作,
maybe because kind of you're copying objects where you should be doing things in place, 

525
00:39:29,875 --> 00:39:33,550
那么这时候使用内存分析器就可以非常有用.
then using a memory profiler can be really useful.

526
00:39:33,550 --> 00:39:37,325
实际上,有一个练习可以带你实操一下,
And in fact there's an exercise that will kind of work you through that, 

527
00:39:37,325 --> 00:39:41,350
比较快速排序的原地版本和非原地版本之间的内存差异,
comparing an in-place version of quicksort with like a non-inplace, 

528
00:39:41,350 --> 00:39:42,750
后者会不断制作新的副本.
that keeps making new and new copies. 

529
00:39:42,750 --> 00:39:44,500
如果你使用内存分析器,
And if you using the memory profiler 

530
00:39:44,500 --> 00:39:48,925
你可以很好地比较两者之间地差异.
you can get a really good comparison between the two of them

531
00:39:51,050 --> 00:39:54,275
到现在为止,有没有关于性能分析的问题?
Any questions so far, with profiling? 

532
00:39:54,275 --> 00:39:58,300
内存分析工具是以运行程序来获取内存占用情况的吗?
Is the memory profiler running the program in order to get that?

533
00:39:58,300 --> 00:40:03,850
是的...对于简单代码(至少对于这个代码而言)来说,你可能只需要阅读代码就能了解其内存占用情况.
Yeah... you might be able to figure out like just looking at the code.

534
00:40:03,850 --> 00:40:06,375
但对于更复杂的代码,进行内存分析则有助于更全面地了解其内存使用情况..
But as you get more and more complex for this code at least.

535
00:40:06,375 --> 00:40:11,000
随着程序的越来越复杂,内存分析工具会在每个代码行执行时
But you get more and more complex programs what this is doing is running through the program

536
00:40:11,000 --> 00:40:16,475
检查堆中的内存占用情况,然后说,
and for every line, at the very beginning, it's looking at the kind of heap and saying

537
00:40:16,475 --> 00:40:19,225
"我现在分配了哪些对象?"
"What are the objects that I have allocated now?"

538
00:40:19,275 --> 00:40:21,900
"我有7MB的对象",
"Oh, I have kind of seven megabytes of objects", 

539
00:40:21,900 --> 00:40:24,150
然后再到下一行,再次查看,
and then goes to the next line,looks again, 

540
00:40:24,150 --> 00:40:28,175
"噢,现在我有 50 MB,所以我现在增加了 43 MB的内存占用".
"Oh now I have 50, so I have now added 43 there".

541
00:40:28,175 --> 00:40:35,025
你当然可以手动在代码中添加一些操作,记录每一行代码的内存占用情况,
And again, you could do this yourself by asking for those operations in your code, every single line.

542
00:40:35,025 --> 00:40:37,675
但这样做效率太低了,
But that's not how you should be doing things  

543
00:40:37,675 --> 00:40:40,425
别人已经为你编写了这些工具.
since people have already kind of written these tools for you to use.

544
00:40:42,600 --> 00:40:46,525
正如...
As it was the case with...

545
00:40:46,525 --> 00:40:58,500
正如之前strace一样,你可以在性能分析中做类似的事情.
So as in the case with strace, you can kind of do something similar in profiling.

546
00:40:58,500 --> 00:41:03,600
也许你不关心具体的代码行的内存占用情况,
Like you might not care about the specific lines of code that you have,

547
00:41:03,600 --> 00:41:06,850
但是你想检查程序产生的外部事件.
but maybe you want to check for outside events. 

548
00:41:06,850 --> 00:41:12,575
你可能想知道程序使用了多少CPU周期,
Like, you maybe want to check how many CPU cycles your computer program is using, 

549
00:41:12,575 --> 00:41:14,650
或者它创建了多少页面错误(page fault).
or how many page faults it's creating.

550
00:41:14,650 --> 00:41:19,675
程序的性能问题可能与缓存局部性(cache locality)有关,并导致一些特定的表现.
Maybe you have like bad cache locality and that's being manifested somehow. 

551
00:41:19,675 --> 00:41:22,775
为此,有一个"perf"命令.
So for that, there is the "perf" command.

552
00:41:22,775 --> 00:41:26,675
"perf"命令会运行你的程序,
The "perf" command is gonna do this, where it is gonna run your program 

553
00:41:26,675 --> 00:41:32,125
并跟踪所有这些统计数据,并将它们反馈给你.
and it's gonna kind of keep track of all these statistics and report them back to you. 

554
00:41:32,125 --> 00:41:35,850
如果你在底层工作,这将非常有帮助.
And this can be really helpful if you are working at a lower level. 

555
00:41:35,850 --> 00:41:44,075
我们执行此命令,我将简要解释它在做什么.
So we execute this command, I'm gonna explain briefly what it's doing.

556
00:41:48,975 --> 00:41:54,175
"stress"程序只是在CPU中运行,
And this "stress" program is just running in the CPU, 

557
00:41:54,175 --> 00:41:58,350
它是一个对CPU的压力测试程序.
and it's just a program to just hog one CPU and like test that you can hog the CPU. 

558
00:41:58,350 --> 00:42:07,475
现在,如果我们"Ctrl-C",我们可以终止程序并获取到页面错误的数量
And now if we "Ctrl-C",we can go back and we get some information about the number of page faults that we have 

559
00:42:07,475 --> 00:42:11,825
或程序使用的CPU周期数的一些信息.
or the number of CPU cycles that we utilize, 

560
00:42:11,825 --> 00:42:16,575
或是其它的有效信息
and other useful metrics from our code. 

561
00:42:16,575 --> 00:42:26,950
对于某些程序,它可以查看正在使用的函数是什么.
And for some programs it can look at what the functions that were being used were. 

562
00:42:26,950 --> 00:42:31,200
因此,我们可以记录此程序正在执行的操作,
So we can record what this program is doing,

563
00:42:31,200 --> 00:42:35,325
我们不知道这个程序会执行什么操作,因为这是其他人编写的程序.
which we don't know about because it's a program someone else has written. 

564
00:42:35,325 --> 00:42:42,850
我们可以通过查看堆栈跟踪来查看它执行过的操作,然后发现,
And we can report what it was doing by looking at the stack trace and we can say  

565
00:42:42,850 --> 00:42:48,175
哦,它在这个"__random_r"标准库函数上花费了大量时间.
Oh, It's spending a bunch of time in this "__random_r" standard library function. 

566
00:42:48,175 --> 00:42:50,700
这主要是因为这个程序占用CPU的方法是通过
And it's mainly because the way of hogging a CPU is by 

567
00:42:50,700 --> 00:42:53,350
创建越来越多的伪随机数.
just creating more and more pseudo-random numbers.

568
00:42:53,350 --> 00:42:58,000
在"perf"命令中有一些未映射的其他功能,
And there are some other functions that have not been mapped, 

569
00:42:58,000 --> 00:43:00,000
因为它们属于程序的一部分,
because they belong to the program, 

570
00:43:00,000 --> 00:43:02,100
但如果你了解你的程序,
but if you know about your program

571
00:43:02,100 --> 00:43:04,925
可以使用更多的标志来显示关于性能的信息.
you can display this information using more flags, about perf. 

572
00:43:04,925 --> 00:43:09,200
这个工具在网上有许多非常好的在线教程.
There are really good tutorials online about how to use this tool.

573
00:43:14,100 --> 00:43:17,900
还有一个关于分析器的问题,
Oh One one more thing regarding profilers is, 

574
00:43:17,900 --> 00:43:22,650
到目前为止,我们已经知道了这些分析器很擅长聚合这些信息,
so far, we have seen that these profilers are really good at aggregating all this information 

575
00:43:22,650 --> 00:43:25,800
还会为你提供大量数字.
and like giving you a lot of these numbers.

576
00:43:25,800 --> 00:43:29,625
这样你就可以优化你的代码或者你可以理解正在发生的事情,
So you can optimize your code or you can reason about what is happening, 

577
00:43:29,625 --> 00:43:35,625
但是人类不擅长处理大量数字,
but the thing is humans are not really good at making sense of lots of numbers 

578
00:43:35,625 --> 00:43:38,250
而且由于人类更擅长视觉方面的信息处理,
and since humans are more visual creatures, 

579
00:43:38,250 --> 00:43:43,025
因此使用可视化工具会更容易理解.
it's pretty much easier to kind of have some sort of visualization. 

580
00:43:43,025 --> 00:43:49,100
当然,程序员们已经想到了解决方法.
Again, programmers have already thought about this and have come up with solutions.

581
00:43:49,100 --> 00:43:53,325
一些流行的可视化工具比如 Flame Graph.
A couple of popular ones, is a Flame Graph. 

582
00:43:53,325 --> 00:43:58,325
Flame Graph 是一种采样分析器,
A Flame Graph is a way of sampling profiler. 

583
00:43:58,325 --> 00:44:01,250
通过运行代码并采样来收集数据.
So this is just running your code and taking samples 

584
00:44:01,250 --> 00:44:03,700
在 y 轴上,
And then on the y-axis here

585
00:44:03,700 --> 00:44:10,225
它代表了堆栈的深度,因此我们知道 bash 函数调用了另一个函数,
we have the depth of the stack so we know that the bash function called this other function, 

586
00:44:10,225 --> 00:44:11,625
然后调用了另一个函数,
and this called this other function,

587
00:44:11,625 --> 00:44:13,000
以此类推.
so on, so forth. 

588
00:44:13,000 --> 00:44:17,775
在 x 轴上,横坐标不是时间戳,
And on the x-axis it's not time, it's not like the timestamps.

589
00:44:17,775 --> 00:44:21,825
也不代表函数调用的先后顺序,而是函数执行所消耗的时间.
Like it's not this function run before, but it's just time taken. 

590
00:44:21,850 --> 00:44:23,800
因为这是采样分析器,
Because, again, this is a sampling profiler:

591
00:44:23,800 --> 00:44:27,600
它用的是采样统计的方式.
we're just getting small glimpses of what was it going on in the program. 

592
00:44:27,600 --> 00:44:29,350
但我们知道
But we know that, for example,

593
00:44:29,350 --> 00:44:35,375
例如这个主程序需要最长的时间,因为x方向的长度可以直观地显示函数的执行时间.
this main program took the most time because the x-axis is proportional to that.

594
00:44:35,375 --> 00:44:43,475
它们是交互式的,可以帮助我们快速定位程序的热点区域.
And they are interactive and they can be really useful to identify the hot spots in your program.

595
00:44:43,475 --> 00:44:47,175
还有一种展示程序性能信息的方式是使用调用图,
And another way of displaying information, 

596
00:44:47,175 --> 00:44:51,025
也有使用这种工具的练习.
and there is also an exercise on how to do this, is using a call graph.

597
00:44:51,025 --> 00:44:53,600
调用图将可视化程序信息,
So a call graph is going to be displaying information, 

598
00:44:53,600 --> 00:44:58,600
它可以图形化展示程序各个函数之间调用关系.
and it's gonna create a graph of which function called which other function.

599
00:44:58,600 --> 00:45:01,250
然后,你可以获得有关信息,
And then you get information about,  

600
00:45:01,250 --> 00:45:08,225
例如我们知道 "__main__" 调用了这个 "Person.add_banana" 函数十次并且它花费了这么多时间.
like, oh, we know that "__main__" called this "Person.add_banana" function ten times and it took this much time. 

601
00:45:08,225 --> 00:45:10,525
随着程序越来越大,
And as you have larger and larger programs, 

602
00:45:10,525 --> 00:45:14,125
查看其中一个调用图可以帮助确定
looking at one of these call graphs can be useful to identify

603
00:45:14,125 --> 00:45:20,600
你的代码的哪个部分进行了非常多的 IO 操作.
like what piece of your code is calling this really expensive IO operation, for example.

604
00:45:24,575 --> 00:45:28,483
最后,我想说的是
With that I'm gonna cover the last part of the lecture, 

605
00:45:28,525 --> 00:45:36,825
有时你甚至可能不知道程序中哪个资源受限.
which is that sometimes, you might not even know that like what exact resource is constrained in your program.

606
00:45:36,825 --> 00:45:41,323
例如,如何知道我的程序使用了多少 CPU,
Like how do I know how much CPU my program is using by us, 

607
00:45:41,323 --> 00:45:43,925
我可以马上在那里看到,或者说使用了多少内存
and I can quickly look in there, or how much memory.

608
00:45:43,925 --> 00:45:51,725
因此,有许多非常智能的工具可以做到这一点,其中之一是"htop".
So there are a bunch of really nifty tools for doing that one of them is "htop". 

609
00:45:51,725 --> 00:45:55,975
"htop" 是一个交互式的命令行工具,
So "htop" is an interactive command-line tool 

610
00:45:55,975 --> 00:46:01,000
它显示此机器具有的所有 CPU,即 12 个.
and here it's displaying all the CPUs this machine has,which is 12. 

611
00:46:01,000 --> 00:46:03,550
它还显示内存,
It's displaying the amount of memory, 

612
00:46:03,575 --> 00:46:08,259
并展示了我使用了 32GB 内存中的 1GB.
it says I'm consuming almost a gigabyte of the 32 gigabytes my machine has.

613
00:46:08,259 --> 00:46:12,000
然后我得到了所有不同的进程.
And then I'm getting all the different processes. 

614
00:46:12,000 --> 00:46:17,475
例如我们有zsh,mysql和在这台机器上运行的其他进程,
So for example we have zsh, mysql and other processes that are running in this machine.

615
00:46:17,475 --> 00:46:20,825
我可以通过它们消耗的CPU数量
And I can sort through the amount of CPU

616
00:46:20,825 --> 00:46:25,200
或它们运行的优先级进行排序.
they're consuming or through the priority they're running at.

617
00:46:25,225 --> 00:46:28,100
我们可以通过运行"stress"命令来检查.
We can check this, for example. 

618
00:46:28,100 --> 00:46:31,550
在这里,我们再次运行"stress"命令以占用四个CPU,
Here we have the "stress" command again and we're gonna run it to take over four CPUs

619
00:46:31,550 --> 00:46:37,425
并检查我们是否可以在"htop"中看到它们.
and check that we can see that in "htop".

620
00:46:37,425 --> 00:46:41,900
我们确实发现了这四个CPU任务,
So we did spot those four CPU jobs, and now I have seen that

621
00:46:41,900 --> 00:46:47,550
现在我发现除了之前我们看到的,
besides the ones we had before,

622
00:46:50,175 --> 00:46:56,200
还有四个"stress -c"命令在运行并占用了我们大量的CPU.
Now I have like this four "stress -c" command running and taking a bunch of our CPU.

623
00:46:56,200 --> 00:47:00,125
尽管你可以使用分析器来获取类似于此的信息,
And even though you could use a profiler to get similar information to this, 

624
00:47:00,125 --> 00:47:04,300
但是"htop"以实时交互的方式显示此类信息,
the way "htop" displays this kind of in a live interactive fashion 

625
00:47:04,300 --> 00:47:07,500
可能更快速和更易于解析.
can be much quicker  and much easier to parse. 

626
00:47:07,500 --> 00:47:14,750
在笔记中,有一个非常长的列表,列出了用于评估系统不同部分的各种工具.
In the notes, there's kind of a really long list of different tools for evaluating different parts of your system.

627
00:47:14,750 --> 00:47:18,825
比如说用于分析网络性能的工具,
So that might be tools for analyzing the network performance, 

628
00:47:18,825 --> 00:47:22,550
或者查看IO操作的数量,
about looking the number of IO operations, 

629
00:47:22,550 --> 00:47:28,175
以便你知道你的磁盘读取量是否已经达到了饱和状态,
so you know whether you're saturating like the reads from your disks, 

630
00:47:28,175 --> 00:47:32,275
你还可以查看空间使用情况.
you can also look at what is the space usage.

631
00:47:32,275 --> 00:47:35,425
(老师的碎碎念)...
Which, I think, here like blabla...

632
00:47:38,725 --> 00:47:45,300
"ncdu"...有一个名为"du"的工具,它代表"disk usage".
So "ncdu"... There's a tool called "du" which stands for "disk usage".

633
00:47:45,300 --> 00:47:49,825
我们有"-h"标志用于"人类可读的输出".
And we have the "-h" flag for "human readable output".

634
00:47:49,825 --> 00:48:00,825
我们可以进行视频,然后获得有关此文件夹中所有文件大小的输出.
And we can do videos and we can get output about the size of all the files in this folder.

635
00:48:01,925 --> 00:48:05,175
(又是一些碎碎念...)
Yeah, blabla... 

636
00:48:10,900 --> 00:48:15,675
"du"还有互动版本,像"htop"就是一个互动版本.
There are also interactive versions, like "htop" was an interactive version.

637
00:48:15,675 --> 00:48:17,586
因此,"ncdu"是"du"的一个互动版本,
So "ncdu" is an interactive version 

638
00:48:17,586 --> 00:48:21,733
让我可以浏览文件夹,我可以看到,
that will let me navigate through the folders and I can see quickly that(oh, like we have...)

639
00:48:22,175 --> 00:48:25,350
这是视频讲座之一的文件夹,
This is one of the folders for the video lectures,

640
00:48:25,350 --> 00:48:32,900
我们可以看到有这四个文件,每个文件大小都接近9 GB,
and we can see there are these four files that have like almost 9 GB each 

641
00:48:32,900 --> 00:48:36,950
我可以通过此界面快速删除它们.
and I could quickly delete them through this interface.

642
00:48:37,900 --> 00:48:44,225
另一个很棒的工具是"lsof",它代表"list of open files"(打开文件列表).
Another neat tool is "lsof" which stands for kind of "list of open files".

643
00:48:44,225 --> 00:48:49,950
你可能遇到的一种情况是,你知道某个进程正在使用文件,
Another pattern that you may encounter is you know some process is using a file, 

644
00:48:49,950 --> 00:48:52,675
但你不知道确切是哪个进程在使用该文件.
but you don't know exactly which process is using that file.

645
00:48:52,675 --> 00:48:56,875
或者,类似地,某个进程正在侦听端口,
Or, similarly, some process is listening in a port, 

646
00:48:56,875 --> 00:48:59,300
但是,你又如何找出它是哪个进程呢?
but again, how do you find out which one it is? 

647
00:48:59,300 --> 00:49:01,375
那么让我们来举个例子.
So to set an example.

648
00:49:01,375 --> 00:49:06,575
我们在444端口上运行一个Python HTTP服务器.
We just run a Python HTTP server on port 444 ,running there. 

649
00:49:06,600 --> 00:49:10,025
假设我们不知道它正在运行,
Maybe we don't know that that's running, 

650
00:49:10,025 --> 00:49:11,825
但是我们可以使用...
but then we can use

651
00:49:11,825 --> 00:49:19,600
我们可以使用"lsof".
We can use "lsof".

652
00:49:22,850 --> 00:49:25,850
是的,我们可以使用"lsof",
Yeah, we can use "lsof", 

653
00:49:25,850 --> 00:49:30,250
而"lsof"将打印大量信息.
and the thing is "lsof" is gonna print a lot of information.

654
00:49:30,250 --> 00:49:39,746
你需要管理员权限,因为这个操作会查询一些项目的所属者信息.
You need "sudo" permissions because this is kind of gonna ask for who has all these items.

655
00:49:39,746 --> 00:49:48,025
由于我们只关心在此444端口上监听的进程,因此我们可以使用grep查询.
And since we only care about the one who is listening in this 444 port we can ask grep for that. 

656
00:49:48,375 --> 00:49:53,600
然后我们可以看到,有一个Python进程,带着这个标识符,
And we can see, oh, there's like this Python process, with this identifier, 

657
00:49:53,600 --> 00:49:58,125
正在使用该端口,然后我们可以kill它,
that is using the port and then we can kill it, 

658
00:49:58,875 --> 00:50:01,150
从而终止该进程.
and that terminates that process.

659
00:50:01,150 --> 00:50:05,350
同样,有许多不同的工具可供使用.
And again, there's a lot of different tools. 

660
00:50:05,350 --> 00:50:10,875
甚至有用于进行所谓基准测试的工具.
There's even tools for doing what is called benchmarking. 

661
00:50:10,875 --> 00:50:14,625
因此,在Shell工具和脚本讲座中,
So in the shell tools and scripting lecture, 

662
00:50:14,625 --> 00:50:19,350
我说过对于某些任务,"fd"比"find"快得多.
I said like for some tasks like "fd" is much faster than "find"

663
00:50:19,350 --> 00:50:21,925
但是,如何检查呢?
But like how will you check that? 

664
00:50:21,925 --> 00:50:26,875
我可以使用"hyperfine"来测试它,这里有两个命令:
Or like I can test that with "hyperfine" and I have here two commands: 

665
00:50:26,875 --> 00:50:34,325
一个使用"fd"仅搜索JPEG文件,另一个使用"find"执行相同的操作.
one with "fd" that is just searching for JPEG files and the same one with "find".

666
00:50:34,325 --> 00:50:39,325
如果我执行它们,它会对这些脚本进行基准测试,
If I execute them, it's gonna benchmark these scripts 

667
00:50:39,325 --> 00:50:46,975
并向我告诉我"fd"比"find"快多少相关的一些信息.
and give me some output about how much faster "fd" is compared to "find".

668
00:50:47,750 --> 00:50:53,075
嗯,"fd"将近快"find"23倍
yeah, like 23 times for this task.

669
00:50:53,075 --> 00:50:56,375
这就是这节课大概的内容.
So that kind of concludes the whole overview. 

670
00:50:56,375 --> 00:50:59,813
我知道有很多不同的主题
I know that there's like a lot of different topics 

671
00:50:59,813 --> 00:51:02,113
和不同的视角来处理这些事情,
and there's like a lot of perspectives on doing these things, 

672
00:51:02,113 --> 00:51:05,375
但是我想再次强调的是,
but kind of again I want to reinforce the idea 

673
00:51:05,375 --> 00:51:09,025
你不需要成为所有这些主题的专家,
that you don't need to be a master of all these topics but more...

674
00:51:09,025 --> 00:51:11,500
但是你需要意识到所有这些东西的存在.
To be aware that all these things exist. 

675
00:51:11,500 --> 00:51:14,475
因此,如果你遇到这些问题,你不需要重新造轮子,
So if you run into these issues you don't reinvent the wheel, 

676
00:51:14,475 --> 00:51:17,850
而是可以利用其他程序员已经做好了的工作.
and you kind of like reuse all that other programmers have done.

677
00:51:18,000 --> 00:51:24,425
鉴于此,我很乐意回答讲座中的任何问题.
Given that, I'm happy to take any questions related to this last section or anything in the lecture.

678
00:51:25,800 --> 00:51:30,550
有没有什么办法来大概估算程序需要多长时间?
Is there any way to sort of think about how long a program should take? 

679
00:51:30,550 --> 00:51:32,281
如果它运行时间较长,你是否应该担心还是视情况而定?
You know, if it's taking a while to run you know, should you be worried or depending on your process? 

680
00:51:37,046 --> 00:51:43,200
你应该再等十分钟再开始检查它运行时间这么长的原因?
Let me wait another ten minutes before I start looking at why it's taking so long.

681
00:51:43,200 --> 00:51:45,725
好的,
Okay, so the... 

682
00:51:45,725 --> 00:51:51,900
了解一个程序需要运行多长时间的任务是非常难以确定的,
The task of knowing how long a program should run is pretty infeasible to figure out. 

683
00:51:51,900 --> 00:51:54,525
这将取决于程序的类型.
It will depend on the type of program.

684
00:51:54,525 --> 00:51:59,050
这取决于你是在进行HTTP请求还是在读取数据......
It depends on whether like you're making HTTP requests or you're reading data... 

685
00:51:59,050 --> 00:52:03,425
你可以做的一件事是,
One thing that you can do is if you have like for example, 

686
00:52:03,425 --> 00:52:08,050
如果你知道你需要从磁盘中读取2GB的数据,
if you know you have to read two gigabytes from disk, 

687
00:52:08,050 --> 00:52:13,225
并将其加载到内存中,你可以进行快速的计算.
and load that into memory, you can kind of make back-of-the-envelope calculation. 

688
00:52:13,225 --> 00:52:15,950
操作应该不会超过 X 秒,
So like that shouldn't take longer than like X seconds 

689
00:52:15,950 --> 00:52:19,450
因为系统的设置就是这样的.
because this is how things are set up. 

690
00:52:19,525 --> 00:52:23,075
或者,如果你打算从网络读取某些文件,
Or if you are reading some files from the network 

691
00:52:23,075 --> 00:52:25,400
并且知道网络链接是什么,
and you know kind of what the network link is 

692
00:52:25,450 --> 00:52:27,909
但是它们花费的时间比你预期的要长五倍,
and they are taking say five times longer

693
00:52:27,909 --> 00:52:31,259
则可以尝试这样做.
than what you would expect then you could try to do that. 

694
00:52:31,259 --> 00:52:33,400
否则,如果你不是很确定.
Otherwise, if you don't really know. 

695
00:52:33,400 --> 00:52:37,000
例如,如果你在代码中尝试进行某些数学运算,
Like say you're trying to do some mathematical operation in your code 

696
00:52:37,000 --> 00:52:39,700
并且不确定需要多长时间,
and you're not really sure about how long that will take 

697
00:52:39,700 --> 00:52:42,225
你可以使用类似于日志记录的方式,
you can use something like logging 

698
00:52:42,225 --> 00:52:48,018
尝试打印中间阶段的信息,
and try to kind of print intermediate like stages to get a sense of like, 

699
00:52:48,018 --> 00:52:55,475
以有个大致概念,比如我需要执行多少次操作或者了解到10秒能进行三次迭代这样的信息.
oh I need to do a thousand operations of this and three iterations took ten seconds.

700
00:52:55,475 --> 00:53:01,275
那么这将需要更长时间才能完成我的那种情况.
Then this is gonna take much longer than I can handle in my case.

701
00:53:01,275 --> 00:53:05,275
所以,我认为有很多方法可以解决这个问题,虽然选取什么工具将取决于任务是什么,
So I think there are ways, it will again like depend on the task, 

702
00:53:05,275 --> 00:53:09,625
但是,鉴于我们目前了解的工具,
but definitely, given all the tools we've seen really have, 

703
00:53:09,625 --> 00:53:14,150
我们可能有几种不错的方式来着手解决这个问题.
like we probably have like a couple of really good ways to start tackling that.

704
00:53:14,800 --> 00:53:16,825
还有其他问题吗?
Any other questions? 

705
00:53:16,875 --> 00:53:21,800
你还可以运行"htop"来查看是否有任何正在运行的东西.
You can also do things like run "htop" and see if anything is running.

706
00:53:21,800 --> 00:53:25,675
如果你的CPU使用率为0％,那么就很可能出了问题.
Like if your CPU is at 0%, something is probably wrong.

707
00:53:32,125 --> 00:53:38,850
好的.今天的课程有很多练习,
Okay. There's a lot of exercises for all the topics that we have covered in today's class,

708
00:53:38,850 --> 00:53:41,825
所以请随意选择你感兴趣的主题进行练习.
so feel free to do the ones that are more interesting. 

709
00:53:41,825 --> 00:53:44,975
我们今天还有办公时间,
We're gonna be holding office hours again today.

710
00:53:44,975 --> 00:53:46,950
只是提醒一下,办公时间.
Just a reminder, office hours. 

711
00:53:46,950 --> 00:53:49,350
你可以来问任何问题.
You can come and ask questions about any lecture. 

712
00:53:49,350 --> 00:53:53,775
我们不会期望你在几分钟内完成练习.
Like we're not gonna expect you to kind of do the exercises in a couple of minutes.

713
00:53:53,775 --> 00:53:57,025
他们需要很长时间才能完成,
They take kind of a really long while to get through them, 

714
00:53:57,025 --> 00:54:01,225
但是我们在那里也可以回答关于以前课程的任何问题,
but we're gonna be there to answer any questions from previous classes, 

715
00:54:01,225 --> 00:54:02,567
甚至与练习无关的问题.
or even not related to exercises. 

716
00:54:02,700 --> 00:54:04,125
例如,如果你想了解
Like if you want to know more about 

717
00:54:04,125 --> 00:54:08,875
如何使用tmux以快速在pane之间切换,
how you would use tmux in a way to kind of quickly switch between panes, 

718
00:54:08,875 --> 00:54:11,075
以及任何你灵光乍现想到的问题.
anything that comes to your mind.

