1
00:00:00,275 --> 00:00:05,700
我们先介绍一下今天这节课,
I guess we should do an intro to this as well, 

2
00:00:05,700 --> 00:00:14,075
这是一节自由问答的课,你们俩可以问问题,
so this is just sort of a free-form Q&A lecture where you as in the two people sitting here, 

3
00:00:14,075 --> 00:00:19,225
当然没来现场上课的所有人也可以提问.
but also everyone at home who did not come here in person, get to ask questions. 

4
00:00:19,225 --> 00:00:21,850
我们之前收集了一些问题,
And we have a bunch of questions people asked in advance, 

5
00:00:21,850 --> 00:00:24,075
当然你们也可以在上课期间提出其他问题.
but you can also ask additional questions during, 

6
00:00:24,075 --> 00:00:26,103
对于在场的两位,
for the two of you who are here, 

7
00:00:26,103 --> 00:00:30,275
你们可以举手提问,或者匿名在论坛上提问,
you can do it either by raising your hand or you can submit it on the forum and be anonymous. 

8
00:00:30,325 --> 00:00:31,700
随你们便.
It's up to you. 

9
00:00:32,725 --> 00:00:36,275
对于已经被问到的问题,我们将会逐一回答,
Regardless though, what we're gonna do is just go through some of the questions that have been asked 

10
00:00:36,275 --> 00:00:42,800
我们会尽可能给出正确的答案,虽然我们之前没有做过任何准备.
and try to give as helpful answers as we can, although they are unprepared on our side.  

11
00:00:42,800 --> 00:00:44,575
好的,这就是今天的安排.
And yeah, that's the plan. 

12
00:00:44,575 --> 00:00:48,050
我们将按照问题的受欢迎程度来回答.
I guess we go from popular to least popular. 

13
00:00:48,050 --> 00:00:49,425
让我们开始吧!
Fire away!

14
00:00:49,425 --> 00:00:51,329
第一个问题是:
Alright, so for our first question, 

15
00:00:51,329 --> 00:00:55,027
学习操作系统相关主题的时候,
any recommendations on learning operating system related topics like 

16
00:00:55,027 --> 00:00:59,350
比如进程,虚拟内存,中断,内存管理等的建议?
processes, virtual memory, interrupts, memory management, etc.? 

17
00:00:59,350 --> 00:01:03,350
这是一个有趣的问题,
So I think, this is an interesting question because 

18
00:01:03,350 --> 00:01:08,000
这些都是非常底层的概念,
these are really low-level concepts that often do not matter 

19
00:01:08,000 --> 00:01:11,300
通常情况下这些东西并不重要,除非你必须在某些情况下处理这些问题,对吧?
unless you have to deal with this in some capacity, right? 

20
00:01:11,300 --> 00:01:15,199
比如你正在编写非常底层的代码,
So one instance where this matters is 

21
00:01:15,199 --> 00:01:19,550
比如实现内核
if you're writing really low-level code like you're implementing a kernel or something like that, 

22
00:01:19,550 --> 00:01:21,650
或者想要对Linux内核进行修改之类的.
or you want to just hack on the Linux kernel. 

23
00:01:21,650 --> 00:01:27,075
否则,你很少需要自己处理这些东西,尤其是像虚拟内存和中断这样的问题.
It's rare otherwise that you need to work with, especially like virtual memory and interrupts and stuff yourself. 

24
00:01:27,075 --> 00:01:32,750
进程是一个更一般的概念,我们在这门课程中也稍微谈到了一些,
Processes, I think, are a more general concept that we've talked a little bit about in this class as well, 

25
00:01:32,750 --> 00:01:37,350
并且工具如"htop","pgrep","kill",信号等也与进程这个概念有所关联.
and tools like "htop", "pgrep", "kill", and signals and that sort of stuff.

26
00:01:37,350 --> 00:01:45,450
至于如何学习,我想也许比较好的方法是试着参加这个课程的入门课程.
In terms of learning it, maybe one of the best ways is to try to take either an introductory class on the topic. 

27
00:01:45,450 --> 00:01:49,150
例如,麻省理工学院有一个称为6.828的课程,
So for example, MIT has a class called 6.828, 

28
00:01:49,150 --> 00:01:53,618
你可以根据给定的代码框架
which is where you essentially build and develop your own operating system 

29
00:01:53,618 --> 00:01:55,775
构建和开发自己的操作系统,
based on some code that you're given, 

30
00:01:55,775 --> 00:02:00,200
所有实验和课程资源都是公开的.
and all of those labs are publicly available and all the resources for the class are publicly available, 

31
00:02:00,200 --> 00:02:03,525
通过实践学习,是学习的好方法.
and so that is a good way to really learn them is by doing them yourself. 

32
00:02:03,525 --> 00:02:11,550
此外,还有各种在线教程,可以指导你从零开始编写内核.
There are also various tutorials online that basically guide you through how do you write a kernel from scratch. 

33
00:02:11,550 --> 00:02:17,050
这些教程指导编写的不一定是一个非常精细的内核,也许不能运行任何真正的软件,
Not necessarily a very elaborate one, not one you would want to run any real software on, 

34
00:02:17,050 --> 00:02:18,500
但它可以教你基本知识.
but just to teach you the basics. 

35
00:02:19,225 --> 00:02:24,675
你可以搜索如何使用你喜欢的编程语言编写内核,
And so that would be another thing to look up, like how do I write a kernel in and then your language of choice. 

36
00:02:24,675 --> 00:02:27,500
但是你可能找不到用Python编写内核的教程,
You will probably not find one that lets you do it in Python, 

37
00:02:27,500 --> 00:02:32,625
但是在C,C++,Rust等语言中,有许多这样的教程.
but in like C, C++, Rust, there are a bunch of topics like this.

38
00:02:33,275 --> 00:02:36,400
关于操作系统的一个补充,
One other note on operating systems, 

39
00:02:36,400 --> 00:02:39,400
正如Jon提到的,麻省理工学院有一个6.828的课程,
so like Jon mentioned, MIT has a 6.828 class, 

40
00:02:39,400 --> 00:02:41,733
但如果你想了解更高层次的概述,
but if you're looking for a more high-level overview, 

41
00:02:41,733 --> 00:02:43,850
不一定是关于编程或操作系统,
not necessarily programming or an operating system, 

42
00:02:43,850 --> 00:02:44,950
而是学习概念的话,
but just learning about the concepts, 

43
00:02:44,950 --> 00:02:46,228
有一本不错的书是
another good resource is 

44
00:02:46,228 --> 00:02:49,650
Andrew Tanenbaum写的{\rcode}Modern Operating Systems{\r}(现代操作系统)
a book called Modern Operating Systems by Andrew Tanenbaum. 

45
00:02:50,750 --> 00:02:57,825
还有一本名为{\rcode}The FreeBSD Operating System{\r}(FreeBSD操作系统)的书也非常好.
There's also actually a book called "The FreeBSD Operating System" which is really good. 

46
00:02:57,825 --> 00:02:59,325
它并没有涉及Linux,
It doesn't go through Linux, 

47
00:02:59,325 --> 00:03:00,550
而是介绍了FreeBSD,
but it goes through FreeBSD, 

48
00:03:00,550 --> 00:03:06,375
BSD内核可能比Linux内核更加有组织,文档也更加详细,
and the BSD kernel is arguably better organized than the Linux one and better documented, 

49
00:03:06,375 --> 00:03:11,075
因此相对于Linux内核,BSD内核可能提供了一个更加友好的入门方式.
and so it might be a gentler introduction to some of those topics than trying to understand Linux.

50
00:03:12,586 --> 00:03:14,421
你看看解决了这个问题吗?
Do you want to check it as an answered?

51
00:03:14,421 --> 00:03:16,950
Nice!解决了.
Yes!Nice!Answered.

52
00:03:16,950 --> 00:03:21,942
下一个问题,你觉得刚开始时哪些工具应该优先学习?
For our next question, what are some of the tools you'd prioritize learning first? 

53
00:03:21,942 --> 00:03:26,450
也许我们可以都分享一下?没错.
Maybe we can all go through and give our opinion on this? Yeah.

54
00:03:26,475 --> 00:03:32,875
首先优先学习哪些工具?我认为熟练使用编辑器,
Tools to prioritize learning first? I think learning your editor well, 

55
00:03:32,875 --> 00:03:35,947
可以在各个方面为你提供帮助,
just serves you in all capacities 

56
00:03:35,947 --> 00:03:38,757
例如高效地编辑文件,
like being efficient at editing files, 

57
00:03:38,757 --> 00:03:41,701
这基本上将是你会花费大部分时间做的事情.
is just like a majority of what you're going to spend your time doing. 

58
00:03:41,701 --> 00:03:46,300
而且总体来说,尽量使用键盘而不是鼠标,
And in general, just using your keyboard more and your mouse less. 

59
00:03:46,300 --> 00:03:52,325
这意味着你可以花更多时间做有用的事情,而不是浪费时间在键鼠切换上.
It means that you get to spend more of your time doing useful things and less of your time moving. 

60
00:03:52,325 --> 00:03:56,125
我认为这应该是我的首要任务,
I think that would be my top priority, 

61
00:04:03,525 --> 00:04:09,750
所以我想,优先学习哪些工具取决于你正在做什么.
so I would say that for what tool to prioritize will depend on what exactly you're doing. 

62
00:04:09,750 --> 00:04:17,675
核心思想是要找到你正在反复在做的任务,
I think the core idea is you should try to find the types of tasks that you are doing repetitively and, 

63
00:04:17,675 --> 00:04:23,740
例如,如果你正在做某种机器学习,
so if you are doing some sort of like machine learning workload 

64
00:04:23,740 --> 00:04:27,300
并且发现自己经常使用我们昨天介绍的Jupyter笔记本,
and you find yourself using Jupyter notebooks, like the one we presented yesterday, a lot. 

65
00:04:27,300 --> 00:04:33,148
那么使用鼠标可能不是最好的选择,
Then again, using a mouse for that might not be the best idea 

66
00:04:33,148 --> 00:04:35,825
你需要熟悉键盘快捷键.
and you want to familiarize with the keyboard shortcuts. 

67
00:04:35,825 --> 00:04:41,450
几乎任何事情都是如此,你会发现有一些重复的任务,
And pretty much with anything, you will end up figuring out that there are some repetitive tasks, 

68
00:04:41,450 --> 00:04:43,425
你正在运行一台计算机,
and you're running a computer, 

69
00:04:43,425 --> 00:04:50,350
然后应该试着"哦,可能有更好的方法来做这件事",无论是终端还是编辑器.
and just trying to figure out, "oh, there's probably a better way to do this," be it a terminal, be it an editor. 

70
00:04:50,350 --> 00:04:56,850
学习使用我们讲过的一些工具可能非常有趣,
And it might be really interesting to learn to use some of the topics that we have covered, 

71
00:04:56,850 --> 00:05:04,750
但如果它们在日常工作中不是非常有用,那么就不值得优先考虑它们.
but if they're not extremely useful on an everyday basis, then it might not be worth prioritizing them.

72
00:05:06,150 --> 00:05:09,175
在我看来,本课程所涵盖的主题中,
Out of the topics covered in this class, 

73
00:05:09,175 --> 00:05:12,950
我认为最有用的两个是版本控制和文本编辑器.
in my opinion, two of the most useful things are version control and text editors. 

74
00:05:13,050 --> 00:05:16,275
我认为它俩也有些区别,
And I think they're a little bit different from each other, in the sense that

75
00:05:16,275 --> 00:05:18,750
因为文本编辑器非常有用,
text editors I think are really useful to learn well, 

76
00:05:18,750 --> 00:05:21,225
但在我们开始使用Vim
but it was probably the case that before we started using Vim 

77
00:05:21,225 --> 00:05:22,575
和学会它所有fancy的操作之前,
and all its fancy keyboard shortcuts, 

78
00:05:22,575 --> 00:05:25,209
你可能使用的是其他文本编辑器,
you had some other text editor you were using before

79
00:05:25,209 --> 00:05:28,350
并且可以很好地编辑文本,只是可能有点低效.
and you could edit text just fine, maybe a little bit inefficiently. 

80
00:05:28,350 --> 00:05:31,475
而我认为版本控制是另一个非常有用的技能,
Whereas I think version control is another really useful skill, 

81
00:05:31,475 --> 00:05:34,575
如果你不真正了解该工具,
and that's one where if you don't really know the tool properly, 

82
00:05:34,575 --> 00:05:38,925
它实际上可能会导致一些问题,例如数据丢失或与人无法有效合作.
it can actually lead to some problems like loss of data or just inability to collaborate properly with people. 

83
00:05:38,925 --> 00:05:42,750
因此,我认为版本控制是值得好好学习的第一件事.
So I think version control is one of the first things that's worth learning well.

84
00:05:42,750 --> 00:05:44,100
是的,我同意这一点.
Yeah, I agree with that. 

85
00:05:44,100 --> 00:05:48,700
我认为学习像Git这样的工具可以让你以后少走很多弯路.
I think learning a tool like Git is just gonna save you so much heartache down the line. 

86
00:05:48,700 --> 00:05:53,925
此外,它还有助于你与他人合作.
It also, to add on to that, really helps you collaborate with others, 

87
00:05:53,925 --> 00:05:58,000
Anish在上一堂课中提到了GitHub,
and Anish touched a little bit on GitHub in the last lecture, 

88
00:05:58,000 --> 00:06:01,438
学会使用这个工具可以帮助你在大型软件项目中进行协同工作,
and just learning to use that tool well in order to 

89
00:06:01,438 --> 00:06:06,275
这是一项非常宝贵的技能.
work on larger software projects that other people are working on is an invaluable skill.

90
00:06:09,475 --> 00:06:14,600
接下来是"何时使用Python, 何时使用Bash脚本或其他编程语言"这个问题.
For our next question, "When do I use Python versus a Bash script versus some other language?" 

91
00:06:15,400 --> 00:06:21,450
这很难回答,因为正如Jose之前所说的,
This is tough because I think this comes down to what Jose was saying earlier too, 

92
00:06:21,450 --> 00:06:23,818
这取决于你要做什么.
that it really depends on what you're trying to do. 

93
00:06:23,818 --> 00:06:27,018
对于我来说,特别是对于Bash脚本来说,
For me, I think for Bash scripts in particular, 

94
00:06:27,018 --> 00:06:31,242
它是用于自动运行一堆命令的.
Bash scripts are for automating running a bunch of commands. 

95
00:06:31,242 --> 00:06:35,300
你不想在Bash脚本中编写其他的业务逻辑.
You don't want to write any other, like, business logic in Bash. 

96
00:06:35,300 --> 00:06:40,125
比如说,"我想按序运行这些命令...也许带一些参数." 
Like, it is just for, "I want to run these commands, in this order... maybe with arguments." 

97
00:06:42,182 --> 00:06:46,975
但是,即使这样,一旦你需要处理参数,你也不能确定是否需要一个Bash脚本.
But, like, even that, it's unclear that you want a Bash script once you start taking arguments. 

98
00:06:46,975 --> 00:06:52,102
同样的,一旦你需要做一下比如说文本处理
Similarly, like, once you start doing any kind of, like, text processing,

99
00:06:52,102 --> 00:06:56,198
或文件配置等等,
or configuration, all that,  

100
00:06:56,250 --> 00:07:00,375
就要使用比Bash更专业的编程语言.
reach for a language that is a more serious programming language than Bash is. 

101
00:07:00,375 --> 00:07:03,703
Bash只适用于短小精悍的一次性脚本,
Bash is really for short, one-off scripts,

102
00:07:03,703 --> 00:07:08,475
或者那些具有非常明确的使用场景,
or ones that have a very well-defined use case, 

103
00:07:08,475 --> 00:07:11,525
通常在终端或Shell中运行. 
on the terminal, in the shell, probably.

104
00:07:11,950 --> 00:07:15,067
对于稍微具体的选择方案,可以说,
For a slightly more concrete guideline, you might say, 

105
00:07:15,067 --> 00:07:18,139
"如果代码行数不到一百行,可以编写一个Bash脚本",
"Write a Bash script if it's less than a hundred lines of code or so", 

106
00:07:18,175 --> 00:07:20,825
但一旦超过这个点,Bash就变得不灵活,
but once it gets beyond that point, Bash is kind of unwieldy, 

107
00:07:20,825 --> 00:07:24,025
并且转向一个更为专业的编程语言可能更值得,比如Python.
and it's probably worth switching to a more serious programming language, like Python. 

108
00:07:24,025 --> 00:07:29,400
此外,我想补充的是,有时候我发现
And, to add to that, I would say, like, I found myself writing, 

109
00:07:29,400 --> 00:07:30,998
自己在Python中编写脚本,
sometimes, scripts in Python, 

110
00:07:30,998 --> 00:07:36,700
如果我已经在Python中解决了部分问题的子问题,
because if I have already solved some subproblem that covers part of the problem in Python, 

111
00:07:36,700 --> 00:07:41,121
我发现将之前在Python中找到的解决方案组合起来
I find it much easier to compose the previous solution that I found out in Python than 

112
00:07:41,121 --> 00:07:45,750
要比尝试重用Bash代码更容易,而我认为Bash不如Python具有可复用性.
just try to reuse Bash code, that I don't find as reusable as Python.

113
00:07:45,825 --> 00:07:49,407
同样的,很多人写了Python库或Ruby库这样的东西
And in the same way it's kind of nice that a lot of people have written something like

114
00:07:49,407 --> 00:07:53,887
来实现这些功能,这也是一个优点.
Python libraries or like Ruby libraries to do a lot of these things,  

115
00:07:53,887 --> 00:07:56,050
而在Bash中,很难进行代码重用.
whereas, in Bash, it's kind of hard to have, like, code reuse. 

116
00:07:58,275 --> 00:08:03,103
事实上,
And, in fact, I think to add to that, 

117
00:08:03,103 --> 00:08:07,775
如果你在某种语言中可以找到能帮助你完成任务的库,
usually, if you find a library, in some language that 

118
00:08:07,775 --> 00:08:11,487
通常就可以选择使用该语言来处理这项任务.
helps with the task you're trying to do, use that language for the job. 

119
00:08:11,487 --> 00:08:13,625
在Bash中,没有所谓的库,
And in Bash, there are no libraries. 

120
00:08:13,625 --> 00:08:15,275
只有计算机上的其他命令行程序或脚本可以复用.
There are only the programs on your computer.

121
00:08:15,275 --> 00:08:19,925
因此,除非可以调用已有的程序或命令行工具来执行特定操作,一般不用bash
So you don't use it unless like there's a programme you can just invoke

122
00:08:19,925 --> 00:08:23,850
还有一件事儿,Bash很难写对.
I do think other thing worth,remembering that bash is really hard to get right. 

123
00:08:26,150 --> 00:08:29,925
编写特定用例的脚本相对容易写对,
It's very easy to get it right for the particular use case you're trying to solve right now, 

124
00:08:29,925 --> 00:08:35,624
但是类似于"如果文件名中有空格会怎样?"这样的问题也需要考虑.
but, like, things like, "What if one of the filenames has a space in it?"

125
00:08:35,624 --> 00:08:38,200
这种问题在Bash脚本中
It has caused so many bugs, 

126
00:08:38,200 --> 00:08:39,900
会导致很多问题.
and so many problems in Bash scripts. 

127
00:08:39,900 --> 00:08:44,800
如果使用真正的编程语言,那么这些问题就会消失.
And, if you use a real programming language, then those problems just go away. 

128
00:08:48,875 --> 00:08:50,025
是的!这个问题回答了.
Yes! Checked it.

129
00:08:50,025 --> 00:08:54,153
我们来回答下一个问题:
For our next question:

130
00:08:54,200 --> 00:08:55,575
"source"脚本和执行脚本有什么区别?
what is the difference between sourcing a script,and executing that script? 

131
00:08:56,400 --> 00:09:01,911
这个问题我们在一段时间前的办公时间也曾有人提到过,
Ooh~So, this, actually, we got in office hours a while back, as well, which is, 

132
00:09:01,911 --> 00:09:06,583
就是"它们不是一样的吗?它们不都只是运行Bash脚本吗?"
"Aren't they the same? Like, aren't they both just running the Bash script?"

133
00:09:06,583 --> 00:09:12,000
的确,这两者都会执行脚本中的代码.
And, it is true both of these will end up executing the lines of code that are in the script.

134
00:09:12,000 --> 00:09:14,250
它们之间的区别在于,
The ways in which they differ is that 

135
00:09:14,250 --> 00:09:20,825
"source"脚本是指示当前Bash脚本或会话执行该程序,
sourcing a script is telling your current Bash script, your current Bash session, 

136
00:09:20,825 --> 00:09:26,250
而另一种方式是"启动一个新的Bash实例，并在其中运行该程序".
to execute that program, whereas the other one is, "Start up a new instance of Bash, and run the program there, instead."

137
00:09:26,250 --> 00:09:31,000
这对于像......
And, this matters for things like... 

138
00:09:31,000 --> 00:09:34,150
假设"script.sh"试图切换目录.
Imagine that "script.sh" tries to change directories. 

139
00:09:34,150 --> 00:09:40,354
如果你`./script.sh`这样运行脚本,
If you are running the script, as in the second invocation,  "./script.sh",  

140
00:09:40,354 --> 00:09:43,225
那么新的进程将更改目录.
then the new process is going to change directories. 

141
00:09:43,225 --> 00:09:45,225
但是,当脚本退出
But, by the time that script exits, 

142
00:09:45,225 --> 00:09:48,925
并返回到你的shell之前,你的shell仍保持在原地.
and returns to your shell, your shell still remains in the same place. 

143
00:09:48,925 --> 00:09:51,765
然而,如果你在脚本中使用"cd"命令，并"source"它,
However, if you do "cd" in a script, and you "source" it,

144
00:09:51,765 --> 00:09:54,900
你当前的Bash实例将运行它,
your current instance of Bash is the one that ends up running it, 

145
00:09:54,900 --> 00:09:57,800
因此它会在你当前的目录中进行"cd".
and so, it ends up "cd"-ing where you are.

146
00:09:57,800 --> 00:10:00,950
这也是为什么,如果你定义函数,
This is also why, if you define functions, 

147
00:10:00,950 --> 00:10:04,214
例如,你可能想在你的shell会话中执行它们,
for example, that you may want to execute in your shell session, 

148
00:10:04,300 --> 00:10:06,617
你需要"source"脚本而不是运行它,
you need to source the script, not run it, 

149
00:10:06,617 --> 00:10:11,737
因为如果你运行它,那个函数将仅仅被定义在
because if you run it, that function will be defined in the instance of Bash,

150
00:10:11,737 --> 00:10:14,041
当前启动的Bash进程中,
in the Bash process that gets launched, 

151
00:10:14,041 --> 00:10:16,625
但它将不会在你当前的shell中被定义.
but it will not be defined in your current shell. 

152
00:10:17,300 --> 00:10:20,825
我认为这是它们之间最大的两个区别.
I think those are two of the biggest differences between the two.

153
00:10:28,425 --> 00:10:29,725
下一个问题是... 
Next question... 

154
00:10:29,725 --> 00:10:33,056
"各种软件包和工具存储的位置在哪里,
"What are the places where various packages and tools are stored 

155
00:10:33,056 --> 00:10:35,040
引用它们的方式是怎样的?
and how does referencing them work?

156
00:10:35,040 --> 00:10:37,625
/bin或/lib到底是什么?"
What even is /bin or /lib?" 

157
00:10:39,275 --> 00:10:44,775
我们在第一次讲座中提到过,有一个名为"PATH"的环境变量,
So, as we covered in the first lecture, there is this "PATH" environment variable, 

158
00:10:44,775 --> 00:10:49,493
它是一个以分号分隔的字符串,
which is like a semicolon-separated- string of all the places 

159
00:10:49,493 --> 00:10:52,250
你的Shell会到这个字符串里的位置查找二进制文件.
where your shell is gonna look for binaries.

160
00:10:52,250 --> 00:10:56,341
如果你只是执行`echo $PATH`,
And, if you just do something like "echo $PATH", 

161
00:10:56,341 --> 00:11:01,325
你将获得此路径列表,表示查找可执行文件时要依次搜索的位置.
you're gonna get this list, all these places are gonna be consulted, in order. 

162
00:11:01,325 --> 00:11:02,975
它将遍历所有位置,
It's gonna go through all of them, 

163
00:11:02,975 --> 00:11:04,275
并且实际上,我们已经...
and, in fact, there is already... 

164
00:11:04,275 --> 00:11:06,725
我们介绍过"which"了吧?是的.
Did we cover "which"? Yeah.

165
00:11:06,725 --> 00:11:08,600
因此,如果你运行"which "
So, if you run "which", 

166
00:11:08,600 --> 00:11:13,500
Shell会告诉你此命令()在哪里.
and a specific command, the shell is actually gonna tell you where it's finding this (command). 

167
00:11:13,500 --> 00:11:20,200
除此之外,还有一些约定俗成的东西,比如许多程序会将二进制文件安装在
Beyond that, there is like some conventions where a lot of programs will install their binaries 

168
00:11:20,200 --> 00:11:25,575
在"/usr/bin"(或者至少包含符号链接)中,以便你可以找到它们.
and they're like "/usr/bin" (or at least they will include symlinks) in "/usr/bin" so you can find them.

169
00:11:25,575 --> 00:11:27,575
还有一个"/usr/local/bin".
There's also a "/usr/local/bin". 

170
00:11:27,575 --> 00:11:30,125
还有一些特殊的目录,
There are special directories. 

171
00:11:30,125 --> 00:11:33,635
例如,"/usr/sbin"仅用于sudo用户,
For example, "/usr/sbin" it's only for sudo user 

172
00:11:33,635 --> 00:11:37,875
一些这些规矩在不同的发行版之间略有不同.
and some of these conventions are slightly different between different distros. 

173
00:11:37,875 --> 00:11:45,150
比如我知道有些发行版在"/opt"下安装用户库.
So I know like some distros, for example, install the user libraries under "/opt" for example.

174
00:11:50,800 --> 00:11:55,897
好的,我可以再详细介绍一下 "/bin".
Yeah, I think one thing just to talk a little bit of more about "/bin" 

175
00:11:55,897 --> 00:11:59,100
待会儿 Anish 可以再介绍一下其他文件夹.
and then Anish maybe you can do the other folders. 

176
00:11:59,100 --> 00:12:03,600
关于 "/bin",有一些惯例,
So when it comes to "/bin", the convention: there are conventions, 

177
00:12:03,600 --> 00:12:09,850
通常 "/bin" 用于存放一些基本的系统工具,
and the conventions are usually "/bin" are for essential system utilities,

178
00:12:09,850 --> 00:12:12,346
"/usr/bin" 用于存放用户程序,
"/usr/bin" are for user programs, 

179
00:12:12,346 --> 00:12:16,250
"/usr/local/bin" 用于用户编译的程序,
and "/usr/local/bin" are for user compiled programs.

180
00:12:16,250 --> 00:12:21,050
所以那些你想让用户运行的程序都应该放在 "/usr/bin" 中,
Sort of so things that you installed that you intend the user to run, are in "/usr/bin".

181
00:12:21,050 --> 00:12:23,610
用户自己编译并安装在系统中的程序
Things that a user has compiled themselves 

182
00:12:23,610 --> 00:12:26,243
通常会放在 "/usr/local/bin",
and stuck on your system, probably goes in "/usr/local/bin",

183
00:12:26,243 --> 00:12:29,675
但是这也因机器和发行版而异.
but again, this varies a lot from machine to machine,  and distro to distro. 

184
00:12:29,700 --> 00:12:33,775
例如,在 Arch Linux 上,"/bin" 是指向 "/usr/bin" 的符号链接.
On Arch Linux, for example, "/bin" is a symlink to "/usr/bin",

185
00:12:33,775 --> 00:12:34,800
它们是一样的,
they're the same.

186
00:12:34,800 --> 00:12:41,350
Jose刚刚也有提到,"/sbin" 专门为需要以 root 权限运行的程序准备,
and as Jose mentioned, there's also "/sbin" which is for programs that are intended to only be run as root, 

187
00:12:41,350 --> 00:12:45,100
这也因发行版而异,有些发行版甚至没有这个目录,
that also varies from distro to distro whether you even have that directory, 

188
00:12:45,100 --> 00:12:48,492
在许多系统上,"/usr/local/bin" 可能不在你的 PATH 中,
and on many systems like "/usr/local/bin" might not even be in your PATH, 

189
00:12:48,492 --> 00:12:50,348
甚至不存在于你的系统中.
or might not even exist on your system.

190
00:12:50,348 --> 00:12:55,125
另一方面,在BSD中,"/usr/local/bin"通常使用得更加频繁.
On BSD on the other hand "/usr/local/bin" is often used a lot more heavily, yeah. 

191
00:12:56,225 --> 00:12:58,900
我们到目前为止所讨论的
So what we were talking about so far, 

192
00:12:58,900 --> 00:13:01,775
都是Linux中文件和文件夹的组织方式.
these are all ways that files and folders are organized on Linux. 

193
00:13:01,775 --> 00:13:06,900
Linux,BSD与macOS等平台之间都存在一些差异.
Things or Linux or BSD things vary a little bit between that and macOS or other platforms.

194
00:13:06,900 --> 00:13:11,025
如果你想要确切地知道某个位置的用途,可以查阅相关资料.
I think for the specific locations, if you want to know exactly what it's used for, you can look it up. 

195
00:13:11,025 --> 00:13:13,132
但有一些通用的规矩可以记住,
But some general patterns to keep in mind

196
00:13:13,132 --> 00:13:16,780
带有"/bin"的文件夹一般包含可执行的二进制程序,
or anything with "/bin" in it has binary executable programs in it, 

197
00:13:16,780 --> 00:13:21,450
带有"/lib"的文件夹中包含库文件,可供程序链接使用.
anything with "/lib" in it,  has libraries in it so things that programs can link against,  

198
00:13:21,450 --> 00:13:27,110
还有一些其他的信息,例如,许多系统都有一个"/etc"文件夹,
and then some other things that are useful to know are there's a "/etc" on many systems, 

199
00:13:27,110 --> 00:13:29,094
其中包含配置文件;
which has configuration files in it, 

200
00:13:29,100 --> 00:13:30,716
"/home"目录下的
and then there's "/home", 

201
00:13:30,716 --> 00:13:34,172
每个子目录都是每个一个用户的家目录.
which underneath that directory contains each user's home directory.

202
00:13:34,172 --> 00:13:36,348
比如在Linux上,我的用户名...
So like on a Linux box my username...

203
00:13:36,400 --> 00:13:41,025
或者比如说Anish的家目录将与"/home/anish"相对应.
or if it's Anish will correspond to a home directory "/home/anish".

204
00:13:41,925 --> 00:13:46,919
还有一些其他的文件夹,例如"/tmp"通常是一个临时目录,
Yeah, I guess there are a couple of others like "/tmp" is usually a temporary directory 

205
00:13:46,919 --> 00:13:50,119
在重启时会被清空,
that gets erased when you reboot not always but sometimes, 

206
00:13:50,119 --> 00:13:51,275
但并非总是如此,需要在系统上检查
you should check on your system. 

207
00:13:51,275 --> 00:13:58,767
"/var"通常保存着随时间而变化的文件,
There's a "/var" which often holds like files the change over time 

208
00:13:58,767 --> 00:14:06,025
通常会是像软件包管理器的锁文件,日志文件
so these these are usually going to be things like lock files for package managers 

209
00:14:06,025 --> 00:14:11,950
以及用于跟踪进程ID的文件;
they're gonna be things like log files files to keep track of process IDs 

210
00:14:11,950 --> 00:14:15,919
"/dev"文件夹中包含着系统的设备,
then there's "/dev" which shows devices 

211
00:14:15,919 --> 00:14:19,759
通常是对应于系统设备的特殊文件.
so usually so these are special files that correspond to devices on your system 

212
00:14:19,759 --> 00:14:25,900
我们之前讲过了"/sys",Anish讲了"/etc".
we talked about "/sys", Anish mentioned "/etc". 

213
00:14:25,900 --> 00:14:31,791
ehhhh...还有一个,"/opt"是常见的第三方软件文件夹,
ehhhh..."/opt" is a common one for just like 

214
00:14:31,791 --> 00:14:38,255
一般用于公司将其第三方软件移植到Linux上,
third-party software that basically it's usually for companies ported their software to Linux 

215
00:14:38,425 --> 00:14:42,675
但他们并不真正了解在Linux上运行软件的情况,
but they don't actually understand what running software on Linux is like, 

216
00:14:42,675 --> 00:14:46,579
因此他们只是将所有东西放在一个目录中,
and so they just have a directory with all their stuff in it

217
00:14:46,579 --> 00:14:49,950
当这些软件被安装时,它们通常被安装在"/opt"目录中.
and when those get installed they usually get installed into "/opt".

218
00:14:51,375 --> 00:14:56,625
我想这些是我能想到的所有文件夹了.
I think those are the ones off the top of my head, yeah. 

219
00:14:57,100 --> 00:15:01,400
我们会在本次课后,制作课程笔记,里面会列出这些文件夹.
And we will list these in our lecture notes, which will produce after this lecture.

220
00:15:02,625 --> 00:15:09,375
下一个问题:我应该使用 "apt-get" 安装 Python 包还是使用 "pip" 安装?
Next question: Should I "apt-get" install a Python whatever package or "pip" install that package? 

221
00:15:10,500 --> 00:15:14,975
这是一个很好的问题,我认为从更高的层面来看,这个问题问的是
So, this is a good question that I think at a higher level, this question is asking

222
00:15:14,975 --> 00:15:18,650
应该使用系统的软件包管理器来安装东西,
should I use my system's package manager to install things 

223
00:15:18,650 --> 00:15:20,010
还是应该使用一些其他的软件包管理器?
or should I use some other package manager? 

224
00:15:20,010 --> 00:15:23,125
这个问题就更特定于某个编程语言的软件包管理器.
Like in this case, one that's more specific to a particular language. 

225
00:15:23,125 --> 00:15:25,775
答案也有点因情况而异.
And the answer here is also kind of, it depends. 

226
00:15:25,775 --> 00:15:28,664
有时使用系统的软件包管理器来管理东西很方便,
Sometimes it's nice to manage things using a system package manager 

227
00:15:28,664 --> 00:15:31,325
因为所有的东西都可以在一个地方安装和升级,
so everything can be installed and upgraded in a single place, 

228
00:15:31,325 --> 00:15:34,300
但我认为通常系统库中提供的东西,
but I think oftentimes whatever is available in the system repositories, 

229
00:15:34,300 --> 00:15:37,535
比如通过 "apt-get" 或类似工具获得的东西,
the things you can get via a tool like "apt-get" or something similar

230
00:15:37,535 --> 00:15:41,225
有时候可能会稍微过时一些.
might be slightly out of date compared to the more language-specific repository.

231
00:15:41,225 --> 00:15:45,950
例如,我使用的很多 Python 包,我就想要最新的版本,
So, for example, a lot of the Python packages I use, I really want the most up-to-date version, 

232
00:15:45,950 --> 00:15:47,300
因此我使用 "pip" 来安装它们.
and so I use "pip" to install them. 

233
00:15:48,000 --> 00:15:50,600
进一步说,
Then, to extend on that, 

234
00:15:50,600 --> 00:15:56,023
有时候系统软件包
sometimes the case, the system packages 

235
00:15:56,023 --> 00:16:00,425
有时候系统软件包可能需要一些其他依赖项,而你可能没有意识到这一点
might require some other dependencies that you might not have realized about, 

236
00:16:00,425 --> 00:16:06,275
而且对于某些系统,像 Alpine Linux 这样的
and it might also be the case, for some systems, at least for like Alpine Linux, 

237
00:16:06,275 --> 00:16:09,859
它们不为许多Python软件包提供预编译的二进制包,
they don't have wheels for like a lot of the Python packages, 

238
00:16:09,859 --> 00:16:12,800
所以编译这些软件包将需要更长的时间.
so it will just take longer to compile them. 

239
00:16:12,800 --> 00:16:15,850
它们需要从头开始编译,所以需要更多的空间.
It will take more space because they have to compile them from scratch. 

240
00:16:15,850 --> 00:16:22,750
而如果你只是使用 "pip","pip" 有许多不同平台的二进制文件,那可能会更好用.
Whereas if you just go to "pip", "pip" has binaries for a lot of different platforms and that will probably work.

241
00:16:22,750 --> 00:16:28,850
另外你也应该知道,"pip" 在不同的电脑上的行为也不完全相同.
You should also be aware that "pip" might not do the exact same thing in different computers. 

242
00:16:28,850 --> 00:16:32,415
比如,如果你用的是 x86 或 x86_64 的笔记本电脑或台式机上,
So, for example, if you are in a kind of laptop or like a desktop 

243
00:16:32,415 --> 00:16:37,663
你可能有二进制文件.
that is running like x86 or x86_64, you probably have binaries.

244
00:16:37,675 --> 00:16:42,207
但如果你在运行 Raspberry Pi 或其他嵌入式设备上,
But if you're running something like Raspberry Pi or some other kind of embedded device, 

245
00:16:42,207 --> 00:16:44,975
这些设备运行在不同的硬件架构上,
these are running on a different kind of hardware architecture 

246
00:16:44,975 --> 00:16:46,775
你可能就没有二进制文件.
and you might not have binaries. 

247
00:16:46,775 --> 00:16:49,350
我认为这也值得考虑.
I think that's also good to take into account. 

248
00:16:49,350 --> 00:16:53,950
在这种情况下,使用系统包可能是更加值得的,
In that case, it might be worthwhile to use the system packages 

249
00:16:53,950 --> 00:16:57,995
因为使用系统包需要的时间比
just because they will take much shorter to get them than 

250
00:16:57,995 --> 00:17:01,200
从头开始编译整个 Python 安装要短得多.
to just to compile from scratch the entire Python installation. 

251
00:17:01,200 --> 00:17:04,049
除此之外,我想不出任何率先选取系统包的情况,
Apart from that, I don't think I can think of any exceptions where I would actually use the system packages instead of the Python provided ones.

252
00:17:18,375 --> 00:17:20,943
另外要记住的一件事是,
So, one other thing to keep in mind is that 

253
00:17:20,943 --> 00:17:25,350
有时你的电脑上会有多个程序,
sometimes you will have more than one program on your computer 

254
00:17:25,350 --> 00:17:27,900
你可能正在开发多个程序,
and you might be developing more than one program on your computer, 

255
00:17:27,900 --> 00:17:32,875
但由于某种原因,不是所有的程序都需要使用最新的版本的东西来构建,
and for some reason, not all programs are always built with the latest version of things, 

256
00:17:32,875 --> 00:17:35,175
有时它们会滞后一些.
sometimes they are a little bit behind, 

257
00:17:35,175 --> 00:17:39,552
当你在为系统安装某些东西时,
and when you install something system-wide you can only... 

258
00:17:39,552 --> 00:17:41,975
(这取决于你具体是什么系统),
(depends on your exact system), 

259
00:17:41,975 --> 00:17:43,900
但通常只会安装一个版本.
but often you just have one version. 

260
00:17:43,900 --> 00:17:49,175
"pip" 可以让你做的,尤其是与 Python 的虚拟环境类似工具结合使用时,
What "pip" lets you do, especially combined with something like python's virtualenv, 

261
00:17:49,175 --> 00:17:52,543
其他语言也有类似的虚拟环境的概念,
and similar concepts exist for other languages, 

262
00:17:52,543 --> 00:17:55,167
你可以说我想....
where you can sort of say I want to 

263
00:17:55,167 --> 00:17:59,007
(例如，NPM 在其 node 模块中也实现了类似的虚拟环境功能)
(NPM does the same thing as well with its node modules, for example) 

264
00:17:59,007 --> 00:18:03,871
可以在一个子目录下编译该包的依赖项及其所需的所有版本
where I'm gonna compile the dependencies of this package in sort of a subdirectory of its own, and all of the versions that it requires are going to be built in there 

265
00:18:10,335 --> 00:18:12,895
并可以为不同的项目单独执行此操作,
and you can do this separately for separate projects 

266
00:18:12,895 --> 00:18:16,735
以便它们具有不同的依赖关系或相同依赖关系的不同版本,从而保持独立.
so there they have different dependencies or the same dependencies with different versions they still sort of kept separate. 

267
00:18:18,825 --> 00:18:21,725
这是使用系统包难以实现的一件事.
And that is one thing that's hard to achieve with system packages.

268
00:18:26,350 --> 00:18:32,575
下一个问题是:用于提高代码性能的最简单和最好的性能分析工具是什么?
Next question: What's the easiest and best profiling tools to use to improve performance of my code?

269
00:18:33,625 --> 00:18:37,275
这是一个我们可以讨论很长时间的问题.
This is a topic we could talk about for a very long time. 

270
00:18:37,275 --> 00:18:42,725
简单方便的方法就是对时间进行打印输出.
The easiest and best is to print stuff using time. 

271
00:18:42,725 --> 00:18:48,350
我不是在开玩笑,很多时候最简单的方法就是再你的代码里添加时间输出语句.
Like, I'm not joking, very often the easiest thing is in your code. 

272
00:18:48,350 --> 00:18:52,150
在代码的顶部,你确定当前时间,
At the top, you figure out what the current time is, 

273
00:18:52,150 --> 00:18:55,538
然后在你的程序中进行二分查找,
and then you do sort of a binary search over your program of 

274
00:18:55,538 --> 00:19:00,146
添加一个打印语句,打印自程序启动以来经过了多长时间,
add a print statement that prints how much time has elapsed since the start of your program, 

275
00:19:00,146 --> 00:19:05,000
然后一直重复这样的步骤,直到找到花费时间最长的代码段.
and then you do that until you find the segment of code that took the longest. 

276
00:19:05,000 --> 00:19:07,775
然后进入那个函数,再次执行同样的操作,一直重复,
And then you go into that function and then you do the same thing again, 

277
00:19:07,775 --> 00:19:10,825
直到找到大概的时间花费位置.
and you keep doing this until you find roughly where the time was spent. 

278
00:19:10,825 --> 00:19:12,450
但这并不是百分之百可靠的,
It's not foolproof, 

279
00:19:12,450 --> 00:19:16,100
但它非常简单,可以很快地为你提供有用的信息.
but it is really easy and it gives you good information quickly. 

280
00:19:16,100 --> 00:19:19,426
如果你需要更高级的信息,
If you do need more advanced information, 

281
00:19:19,426 --> 00:19:27,200
Valgrind有一个叫做"cache-grind"还是"call-grind"来着?二者里选一个.
Valgrind has a tool called "cache-grind"."call-grind"?"cache-grind". One of the two. 

282
00:19:29,150 --> 00:19:33,058
这个工具可以让你运行你的程序
And this tool lets you run your program 

283
00:19:33,058 --> 00:19:36,082
并给出所有的调用堆栈,
and measure how long everything takes 

284
00:19:36,082 --> 00:19:40,075
比如哪个函数调用了哪个函数,
and all of the call stacks, like which function called which function, 

285
00:19:40,075 --> 00:19:44,466
最终你的程序源代码还会有非常漂亮的注释,
and what you end up with is a really neat annotation of your entire program source 

286
00:19:44,466 --> 00:19:48,242
显示了每行花费的时间.
with the heat of every line, basically how much time was spent there. 

287
00:19:48,242 --> 00:19:52,466
但是这会让你的程序变得慢十倍甚至更多,
It does slow down your program by like an order of magnitude or more, 

288
00:19:52,466 --> 00:19:54,625
而且它并不支持多线程,
and it doesn't really support threads, 

289
00:19:54,625 --> 00:19:57,125
不过如果你能恰当地使用它,它可以非常有用.
but it is really useful if you can use it. 

290
00:19:57,125 --> 00:19:59,817
如果你不能使用这些工具,那么像"perf"或其他编程语言的类似工具
If you can't, then tools like "perf" 

291
00:19:59,817 --> 00:20:04,800
它们通常会执行一定类型的抽样分析,
or similar tools for other languages that do usually some kind of sampling profiling 

292
00:20:04,800 --> 00:20:09,344
可以快速地为你提供非常有用的数据,就像我们在性能分析课程中讨论的那样
like we talked about in the profiler lecture can give you pretty useful data quickly, 

293
00:20:09,344 --> 00:20:13,525
尽管它们提供了大量的数据,
but it's a lot of data around this, 

294
00:20:13,525 --> 00:20:18,275
但它们可能会存在一些偏见,并且通常会突出显示一些问题,
but they're a little bit biased and what kind of things they usually highlight as a problem, 

295
00:20:18,275 --> 00:20:20,391
有时很难从这些数据中提取有关
and it can sometimes be hard to extract 

296
00:20:20,391 --> 00:20:24,575
需要更改哪些方面的有意义的信息.
meaningful information about what should I change in response to them. 

297
00:20:24,600 --> 00:20:30,887
相比之下,使用打印输出的方法可以很快地让你知道哪些部分是糟糕,缓慢的.
Whereas the sort of print approach very quickly gives you like this section of code is bad or slow, 

298
00:20:30,887 --> 00:20:34,600
我想这就是我的答案.
I think would be my answer. 

299
00:20:34,600 --> 00:20:40,225
Flamegraphs也很好用,可以用来可视化一些信息.
Flamegraphs are great, they're a good way to visualize some of this information. 

300
00:20:41,025 --> 00:20:42,918
好的,我只有一件事要补充,
Yeah, I just have one thing to add, 

301
00:20:42,918 --> 00:20:47,800
通常编程语言都有专门的工具用于性能分析,
oftentimes programming languages have language-specific tools for profiling, 

302
00:20:47,800 --> 00:20:49,925
所以要找出适合你的语言的正确工具,
so to figure out what's the right tool to use for your language, 

303
00:20:49,925 --> 00:20:51,909
比如如果你在Web浏览器中使用JavaScript,
like if you're doing JavaScript in the web browser, 

304
00:20:51,909 --> 00:20:55,325
你应该使用Web浏览器里的那个非常好用的分析工具.
the web browser has a really nice tool for doing profiling, you should just use that. 

305
00:20:55,325 --> 00:21:00,575
或者如果你正在使用Go,你应该Go内置的一个好用的性能分析工具.
Or if you are using go, for example, go has a built-in profiler that is really good, you should just use that. 

306
00:21:01,175 --> 00:21:03,875
最后要补充的是,
A last thing to add to that, 

307
00:21:03,875 --> 00:21:11,875
有时你可能会发现对时间进行二分查找时,你知道了时间被消耗在哪儿,
sometimes you might find that doing this binary search over time that you're kind of finding where the time is going, 

308
00:21:11,875 --> 00:21:16,900
但这些时间可能是为了等待网络或等待某些文件而消耗掉的,
but this time is sometimes happening because you're waiting on the network, or you're waiting for some file, 

309
00:21:16,900 --> 00:21:21,579
这时你要确保所用时间是实际必需等待的最少时间.
and in that case, you want to make sure that the time that is, 

310
00:21:21,579 --> 00:21:27,250
比如如果我想要写一个1GB的文件或读取一个1GB的文件并将其存入内存,
if I want to write like 1 gigabyte file or like read 1 gigabyte file and put it into memory, 

311
00:21:27,250 --> 00:21:33,175
则要确保所用的实际时间是最小的.
you want to check that the actual time there is the minimum amount of time you actually have to wait. 

312
00:21:33,175 --> 00:21:36,450
如果时间是十倍长,你应该尝试使用
If it's ten times longer, you should try to use some other tools 

313
00:21:36,450 --> 00:21:38,815
我们在调试和性能分析部分中介绍的其他工具,
that we covered in the debugging and profiling section

314
00:21:38,815 --> 00:21:42,500
以查看为什么你没有利用所有的资源,
to see why you're not utilizing all your resources because 

315
00:21:50,525 --> 00:21:54,614
这可能有很多原因,
that might be a lot of what's happening thing, like for example, 

316
00:21:54,614 --> 00:21:58,550
例如机器学习实验中,大部分时间都是用来加载数据的,
in my research in machine learning workloads, a lot of time is loading data, 

317
00:21:58,550 --> 00:22:00,034
你必须确保
and you have to make sure well like 

318
00:22:00,034 --> 00:22:03,101
加载数据的时间实际上是
the time it takes to load data is actually the minimum amount of time

319
00:22:03,101 --> 00:22:06,225
你想要的最短时间.
you want to have that happening. 

320
00:22:08,750 --> 00:22:14,700
并且在此基础上,实际上有分析等待时间的专门的工具.
And to build on that, there are actually specialized tools for doing things like analyzing wait times. 

321
00:22:14,700 --> 00:22:19,200
很多时候,当你在等待某些东西时,实际上是你正在发出系统调用,
Very often when you're waiting for something, what's really happening is you're issuing your system call, 

322
00:22:19,200 --> 00:22:21,700
这个系统调用需要一些时间来响应.
and that system call takes some amount of time to respond. 

323
00:22:21,700 --> 00:22:24,975
如果你需要进行大量的写入或读取操作,或者需要进行多个此类操作,
Like you do a really large write, or a really large read or you do many of them, 

324
00:22:24,975 --> 00:22:28,751
那么尝试从内核中获取关于程序花费时间的信息是非常方便的.
and one thing that can be really handy here is to try toget information out of the kernel about where your program is spending its time. 

325
00:22:32,450 --> 00:22:35,500
现在有一个
And so there's (it's not new), 

326
00:22:35,500 --> 00:22:40,625
相对较新的可用工具,叫做 BPF 或 eBPF,
but there's a relatively newly available thing called BPF or eBPF. 

327
00:22:40,625 --> 00:22:45,225
它是内核跟踪工具,可以进行一些非常酷的操作,
Which is essentially kernel tracing and you can do some really cool things with it, 

328
00:22:45,225 --> 00:22:47,475
包括跟踪用户程序.
and that includes tracing user programs. 

329
00:22:47,500 --> 00:22:50,800
虽然它可能有点难上手,
It can be a little bit awkward to get started with, 

330
00:22:50,800 --> 00:22:54,768
但是如果你需要进行这种底层性能调试,
there's a tool called BPF trace that I would recommend you looking to, 

331
00:22:54,825 --> 00:22:58,225
我建议可以看看一个叫做 BPF trace 的工具.
if you need to do like this kind of low-level performance debugging. 

332
00:22:58,225 --> 00:23:00,525
对于这种工作来说,它已经算是非常好用了,
But it is really good for this kind of stuff. 

333
00:23:00,525 --> 00:23:05,800
你可以得到关于系统调用消耗时间的直方图等.
You can get things like histograms over how much time was spent in particular system calls. 

334
00:23:05,800 --> 00:23:07,800
这是一个非常好的工具.
It's a great tool.

335
00:23:12,475 --> 00:23:14,525
你使用哪些浏览器插件?
What browser plugins do you use? 

336
00:23:14,525 --> 00:23:19,389
我尽量少使用插件,
I try to use as few as I can get away with using 

337
00:23:19,389 --> 00:23:22,781
因为我不喜欢我的浏览器中有太多东西,
because I don't like things being in my browser, 

338
00:23:22,781 --> 00:23:28,100
但是有一些是比较常用的.
but there are a couple of ones that are sort of staples. 

339
00:23:28,100 --> 00:23:30,100
第一个是 uBlock Origin.
The first one is uBlock Origin. 

340
00:23:30,100 --> 00:23:36,125
uBlock Origin 是众多广告拦截插件之一,但它不仅仅是一个广告拦截器.
So uBlock Origin is one of many ad blockers but it's a little bit more than an ad blocker. 

341
00:23:36,125 --> 00:23:44,975
它更可以说是一个网络过滤工具,可以做比拦截广告更多的事情.
It is (a what do they call it?) a network filtering tool so it lets you do more things than just block ads. 

342
00:23:44,975 --> 00:23:48,025
比如它还可以阻止某些域名的连接,
It also lets you like block connections to certain domains, 

343
00:23:48,025 --> 00:23:51,025
阻止某些类型的资源的连接.
block connections for certain types of resources. 

344
00:23:51,075 --> 00:23:54,888
我把它设置成了高级模式,
So I have mine set up in what they call the Advanced Mode,

345
00:23:54,888 --> 00:23:59,825
基本上就可以禁用所有的网络请求.
where basically you can disable basically all network requests. 

346
00:23:59,850 --> 00:24:02,829
但也不仅仅是网络请求,
But it's not just Network requests, It's also like

347
00:24:02,829 --> 00:24:06,375
我也禁用了每个页面上的所有内嵌脚本,
I have disabled all inline scripts on every page

348
00:24:06,375 --> 00:24:09,400
所有第三方图像和资源,
and all third-party images and resources, 

349
00:24:09,475 --> 00:24:12,209
然后你可以为每个页面创建一个白名单,
and then you can sort of create a whitelist for every page 

350
00:24:12,209 --> 00:24:15,473
它会提供一些提高浏览安全性的底层工具.
so it gives you really low-level tools around how to how to improve the security of your browsing. 

351
00:24:18,025 --> 00:24:20,575
当然你也可以将其设置为非高级模式,
But you can also set it in not the advanced mode, 

352
00:24:20,575 --> 00:24:24,031
然后它会做很多与普通广告拦截器类似的事情,
and then it does much of the same as a regular ad blocker would do, 

353
00:24:24,031 --> 00:24:27,850
如果你在寻找广告拦截器,
although in a fairly efficient way if you're looking at an ad blocker 

354
00:24:27,850 --> 00:24:30,600
它可能是你想要的,并且它适配几乎所有的浏览器.
it's probably the one to use and it works on like every browser. 

355
00:24:30,600 --> 00:24:34,500
这是我的首选插件.
That would be my top pick I think.

356
00:24:38,475 --> 00:24:45,725
我觉得我最常使用的插件可能是一个叫做Stylus的插件.
I think probably the one I use like the most actively is one called Stylus. 

357
00:24:45,725 --> 00:24:51,725
它让你修改网页的CSS或样式表.
It lets you modify like the CSS or like the stylesheets that webpages have. 

358
00:24:51,725 --> 00:24:55,600
这非常方便,因为有时你在浏览一个网站时,
And it's pretty neat, because sometimes like you're looking at a website 

359
00:24:55,600 --> 00:24:59,100
想要隐藏一些你不关心的部分,
and you want to like hide some part of the website you don't care about. 

360
00:24:59,100 --> 00:25:03,800
比如广告或者某个侧边栏.
Like maybe an ad, maybe some sidebar you're not finding useful. 

361
00:25:03,800 --> 00:25:07,275
但是你不想要的部分最终都会在你的浏览器中显示,
The thing is, at the end of the day these things are displaying in your browser, 

362
00:25:07,275 --> 00:25:09,950
而你可以使用这个插件控制哪些代码执行.
and you have control of what code is executing.

363
00:25:09,950 --> 00:25:14,218
就像Jon所说的那样,你可以进行自定义网页,
Like similar to what Jon was saying, like you can customize this to no end, 

364
00:25:14,218 --> 00:25:17,825
比如我已经为很多网页设定了隐藏这一部分,
and what I have for a lot of web pages like hide this part, 

365
00:25:17,825 --> 00:25:21,275
或者尝试为它们制作深色模式,
or also trying to make like dark modes for them

366
00:25:21,275 --> 00:25:24,750
你可以为每个网站更改颜色.
like you can change pretty much the color for every single website. 

367
00:25:24,750 --> 00:25:28,819
还有一个非常方便的地方儿,有一个在线仓库,
And what is actually pretty neat is that there's like a repository online of people

368
00:25:28,819 --> 00:25:32,400
里面有很多人为网站编写的CSS样式表.
that have contributed CSS stylesheets for like the websites. 

369
00:25:32,400 --> 00:25:34,925
有人可能已经为GitHub制作好了相应的样式,
So someone probably has (done) one for GitHub. 

370
00:25:34,925 --> 00:25:36,355
例如我想要深色界面的GitHub
Like I want dark GitHub 

371
00:25:36,355 --> 00:25:41,500
有人可能已经制作好了,你可以直接拿来用,这使得浏览更加愉悦.
and someone has already contributed one that makes that much more pleasing to browse.

372
00:25:41,500 --> 00:25:44,775
除此之外,还有一个不是很花哨,
Apart from that, one that it's not really fancy, 

373
00:25:44,775 --> 00:25:50,275
但我发现非常有用的插件,它可以对整个网站进行截图.
but I have found incredibly helpful is one that just takes a screenshot an entire website. 

374
00:25:50,275 --> 00:25:55,267
它会自动滚动并制作出整个网站的长图,
And It will kind of scroll for you and make kind of compound image of the entire website

375
00:25:55,267 --> 00:25:59,261
这对于打印一个网站非常有用.
and that's really great for when you're trying to print a website and is just terrible because they have.... 

376
00:26:00,525 --> 00:26:01,875
哦,有趣!
Oh interesting! 

377
00:26:01,875 --> 00:26:04,435
既然你提到了Firefox内置的插件,
Oh now that you mention built into Firefox,

378
00:26:04,435 --> 00:26:09,425
我还有一个非常喜欢的东西,是Firefox的多账户容器.
another one that I really like about Firefox is the multi-account containers. 

379
00:26:09,775 --> 00:26:11,949
Oh,是的,我知道那个玩意儿.
Oh,yes!I know.

380
00:26:11,949 --> 00:26:15,597
默认情况下,许多网页浏览器,比如Chrome,
Like by default, a lot of web browsers, like for example Chrome,

381
00:26:15,597 --> 00:26:19,050
都有这么一个概念,
have this kind of notion of like  

382
00:26:19,050 --> 00:26:20,653
在你的浏览器session(会话),他保存了所有的cookie,
there's session that you have, where you have all your cookies.

383
00:26:20,653 --> 00:26:24,557
如果您不断打开新标签页,
And they are kind of all shared from the different websites in the sense of like,

384
00:26:24,557 --> 00:26:26,797
这些Cookie信息在某种意义上是从不同的网站共享的.[*]
you keep opening new tabs 
[*也就是每个新打开的标签页都可以访问同一组Cookie]

385
00:26:26,797 --> 00:26:30,425
除非你进入无痕模式,否则你使用的都是同一组cookie.
And unless you go into incognito you kind of have the same profile. 

386
00:26:30,425 --> 00:26:33,575
而这组cookie是适用于所有网站的,
And that profile is the same for all websites, there is like this.... 

387
00:26:33,575 --> 00:26:35,657
这是通过扩展实现的还是内置的呢?
Is it an extension or is it built in? 

388
00:26:35,657 --> 00:26:35,675
是混合的, 很复杂.
Is it an extension or is it built in? 

389
00:26:35,675 --> 00:26:39,950
是混合的, 很复杂.
It's a mix,  it's complicated

390
00:26:39,950 --> 00:26:44,175
好吧  我想你实际上需要说出你想要安装它或启用它, 
Okay   So I think you actually have to say you want to install it or enable it,  

391
00:26:44,175 --> 00:26:47,250
而这个名字叫做"多帐户容器",
and again the name is Multi Account Containers, 

392
00:26:47,250 --> 00:26:51,575
它可以让Firefox单独地把会话隔离开来.
and these let you tell Firefox to have kind of separate isolated sessions. 

393
00:26:51,575 --> 00:26:55,659
比如说,你想对每次访问Google
So for example, you want to say I have a separate sessions for 

394
00:26:55,659 --> 00:26:58,825
或每次访问Amazon建立独立的会话,
whenever I visit to Google or whenever I visit Amazon, 

395
00:26:58,900 --> 00:27:02,025
这样你就可以
and that can be pretty neat, because then you can. 

396
00:27:02,025 --> 00:27:07,755
在浏览器这个级别上,确保它们之间信息没有共享.
At a browser level, it's ensuring that no information sharing is happening between the two of them. 

397
00:27:07,775 --> 00:27:12,107
这比打开无痕窗口更方便,
And it's much more convenient than having to open an incognito window 

398
00:27:12,107 --> 00:27:13,771
因为后者每次都会清除所有东西.
where it's gonna clean all the time the stuff. 

399
00:27:13,875 --> 00:27:16,983
提醒一下,Stylus与Stylish之间的区别.
One thing to mention is Stylus vs Stylish

400
00:27:16,983 --> 00:27:19,175
哦,对对对,我忘了这一点.
Oh yeah,yeah. I forgot about that. 

401
00:27:19,175 --> 00:27:27,950
有一件重要的事情是浏览器扩展程序可以加载CSS样式表,它叫做Stylus,
One important thing is the browser extension for side loading CSS Stylesheets, it's called Stylus, 

402
00:27:27,950 --> 00:27:32,942
不同于旧版的Stylish,
and that's different from the older one that was called Stylish

403
00:27:32,942 --> 00:27:39,675
因为Stylish曾经被某个不怎么靠谱的公司收购,
 because that one got bought at some point by some shady company that started abusing 

404
00:27:39,675 --> 00:27:44,846
他们不仅使用这个功能,还读取了你的整个浏览器历史记录
it not only to have that functionality but also to read your entire browser history 

405
00:27:44,846 --> 00:27:48,000
并将其发送回他们的服务器,以便进行数据挖掘.
and send that back to their servers so they could data mine it. 

406
00:27:48,000 --> 00:27:52,675
于是人们就开发了这个开源的替代品,叫做Stylus,
So then people just built this open-source alternative that is called Stylus, 

407
00:27:52,675 --> 00:27:54,425
这是我们推荐的.
and that's the one we recommend. 

408
00:27:54,425 --> 00:28:00,225
话虽如此,我认为两个工具的样式库是相同的,
Said that, I think the repository for styles is the same for the two of them, 

409
00:28:00,225 --> 00:28:02,500
但我不是很确定.
but I would have to double-check that.

410
00:28:03,825 --> 00:28:05,875
"Anish,你有使用任何浏览器插件吗?"
Do you have any browser plugins, Anish?

411
00:28:05,875 --> 00:28:08,750
是的,我也有一些浏览器插件的推荐.
Yes, so I also have some recommendations for browser plugins. 

412
00:28:08,750 --> 00:28:10,975
我也使用uBlock Origin
I also use uBlock Origin, 

413
00:28:10,975 --> 00:28:13,475
和Stylus,
and I also use Stylus, 

414
00:28:13,675 --> 00:28:18,075
但我还要推荐一款密码管理器.
but one other one that I'd recommend is integration with a password manager. 

415
00:28:18,075 --> 00:28:21,850
我们在安全那堂课的讲义中有涉及到这个,
So this is a topic that we have in the lecture notes for the security lecture, 

416
00:28:21,850 --> 00:28:23,325
但我们没有详细讨论.
but we didn't really get to talk about in detail. 

417
00:28:23,325 --> 00:28:26,852
基本上,用密码管理器处理在线账户,
But basically, password managers do a really good job of increasing your security 

418
00:28:26,852 --> 00:28:28,634
可以大大提高你的安全性,
when working with online accounts, 

419
00:28:28,634 --> 00:28:32,700
与浏览器集成可以节省你很多时间.
and having browser integration with your password manager can save you a lot of time. 

420
00:28:32,700 --> 00:28:35,760
你可以打开一个网站,然后它可以自动填充你的登录信息,
Like you can open up a website then it can autofill your login information for you, 

421
00:28:35,760 --> 00:28:38,000
你不需要再在程序之间
instead of you having to go and copy and paste it back and forth 

422
00:28:38,000 --> 00:28:40,775
来回复制和粘贴.
between a separate program if it's not integrated with your web browser. 

423
00:28:40,775 --> 00:28:43,527
而且,这种集成可以避免某些攻击,
And it can also, this integration, can save you from certain attacks

424
00:28:43,527 --> 00:28:47,303
否则如果你进行手动复制和粘贴,则可能会受到攻击,
that would otherwise be possible if you were doing this manual copy-pasting. 

425
00:28:47,303 --> 00:28:48,925
例如钓鱼攻击.
For example, phishing attacks. 

426
00:28:48,925 --> 00:28:53,775
因此,如果你找到一个看起来非常像Facebook的网站,并使用相应的账号密码进行登录,
So you find a website that looks very similar to Facebook and you go to log in with your Facebook login credentials, 

427
00:28:53,775 --> 00:28:57,325
然后将正确的密码被复制粘贴到那个钓鱼网站,
and you go to your password manager and copy-paste the correct credentials into this funny website, 

428
00:28:57,325 --> 00:28:59,025
那么现在它就有了你的密码.
and now all of a sudden it has your password. 

429
00:28:59,025 --> 00:29:02,900
但如果你有浏览器集成,则扩展程序可以自动检查,例如:
But if you have browser integration, then the extension can automatically check like. 

430
00:29:02,900 --> 00:29:07,525
我是在facebook.com上还是在其他看起来相似的域名上,
Am I on facebook.com or is it some other domain that maybe looks similar, 

431
00:29:07,525 --> 00:29:10,300
并且如果是错误的域名,则不会输入登录信息.
and it will not enter the login information if it's the wrong domain. 

432
00:29:10,300 --> 00:29:14,050
所以,密码管理的浏览器插件很好用.
So browser extension for password managing is good. 

433
00:29:14,450 --> 00:29:16,225
是的,我同意.
Yeah, I agree.

434
00:29:18,975 --> 00:29:23,075
下一个问题是,还有哪些有用的数据整理工具?
Next question, what are other useful data wrangling tools?

435
00:29:25,275 --> 00:29:28,550
昨天的讲座中,我提到了"curl".
So in yesterday's lecture, I mentioned "curl". 

436
00:29:28,550 --> 00:29:34,025
"curl"是一个非常好用的工具,可以直接在终端中进行网页请求并将其转存到你的电脑上.
"curl" is a fantastic tool for just making web requests and dumping them to your terminal. 

437
00:29:34,025 --> 00:29:39,025
你还可以使用它来上传文件,非常方便.
You can also use it for things like uploading files, which is really handy.

438
00:29:39,025 --> 00:29:42,796
在那个讲座的练习中,
In the exercises of that lecture, 

439
00:29:42,796 --> 00:29:45,740
我们还谈到了"jq"和"pup",
we also talked about "jq" and "pup", 

440
00:29:45,740 --> 00:29:51,036
他们是命令行工具,
which are command line tools that let you basically write queries over

441
00:29:51,036 --> 00:29:55,496
可以让你在JSON和HTML文档上编写查询,非常方便.
JSON and HTML documents respectively that can be really handy. 

442
00:29:57,125 --> 00:30:01,225
还有什么数据整理工具呢?啊,"perl".
Other data wrangling tools? Ah, "perl". 

443
00:30:01,225 --> 00:30:06,652
Perl编程语言通常被称为只能写不能读的编程语言,
The Perl programming language is often referred to as a write-only programming language 

444
00:30:06,652 --> 00:30:09,375
即使你自己写的,你过段实践也很可能看不懂.
because it's impossible to read, even if you wrote it. 

445
00:30:09,450 --> 00:30:17,850
但是,它非常擅长于处理纯文本,没有什么工具能超越它.
But it is fantastic at doing just like straight-up text processing, like nothing beats it there. 

446
00:30:18,425 --> 00:30:24,075
因此,也许值得学习一些非常基础的Perl知识,以编写一些脚本.
So, maybe worth learning some very rudimentary Perl just to write some of those scripts. 

447
00:30:24,075 --> 00:30:29,000
这通常比编写一些"grep","awk"和"sed"的组合要容易得多,
It's easier often than writing some like hacked-up combination of "grep" and "awk" and "sed", 

448
00:30:29,000 --> 00:30:35,375
而且写perl比写例如Python也要快得多.
and it will be much faster to just tack something up than writing it up in Python, for example. 

449
00:30:35,375 --> 00:30:46,850
但是除此之外,还有没有其他的数据整理工具呢?我想不到了.
But apart from that, other data wrangling? No, not off the top of my head. Really,

450
00:30:46,850 --> 00:30:49,000
"column -t".
"column -t". 

451
00:30:49,825 --> 00:30:55,575
如果你将任何以空格为分隔符的输入导入"column -t",
If you pipe any whitespace-separated input into column -t, 

452
00:30:55,575 --> 00:31:00,925
它会使列的所有空格对齐,从而使你得到漂亮的对齐列.
it will align all the whitespace of the columns so that you get nicely aligned columns. 

453
00:31:01,975 --> 00:31:07,525
这是一种非常实用的工具,还有"head"和"tail",但我们已经谈论过这些了.
That's,  and head and tail,  but we talked about those.  

454
00:31:08,425 --> 00:31:15,325
我认为还有几个我经常使用的工具需要补充:一个是Vim.
I think a couple of additions to that, that I find myself using commonly: one is Vim. 

455
00:31:15,325 --> 00:31:19,500
Vim在数据整理中非常有用.
Vim can be pretty useful for like data wrangling on itself. 

456
00:31:19,500 --> 00:31:23,567
有时候你可能会发现要完成的操作
Sometimes you might find that the operation that you're trying to do is hard to 

457
00:31:23,567 --> 00:31:26,500
很难用管道来表达.
put down in terms of piping different operators. 

458
00:31:26,500 --> 00:31:30,749
但是,如果你可以打开文件,
But if you can just open the file and just record

459
00:31:30,749 --> 00:31:35,687
只需用Vim的宏来执行相应的操作,
a couple of quick Vim macros to do what you want it to do, 

460
00:31:35,687 --> 00:31:38,150
这可能会很方便.
it might be like much, much easier. 

461
00:31:38,200 --> 00:31:42,536
这是其中一个工具,另一个是如果你正在处理表格数据,
That's one, and then the other one, if you're dealing with tabular data

462
00:31:42,536 --> 00:31:46,184
并且想要执行更复杂的操作,例如按一列排序,
and you want to do more complex operations like sorting by one column, 

463
00:31:46,184 --> 00:31:49,384
然后分组并计算某种统计数据,
then grouping and then computing some sort of statistic,

464
00:31:49,384 --> 00:31:53,480
我认为这种工作的大多都可以使用Python和pandas来完成,
I think a lot of that workload I ended up just using Python and pandas

465
00:31:53,480 --> 00:31:55,625
因为它就是为此而生的.
because it's built for that. 

466
00:31:55,625 --> 00:31:57,941
我还发现
And one of the pretty neat features 

467
00:31:57,941 --> 00:32:02,248
自己经常使用的一个相当不错的功能是它可以导出许多不同的格式.
that I find myself also using is that it will export to many different formats. 

468
00:32:02,248 --> 00:32:07,800
因此,这个中间状态拥有一个Pandas数据框对象,
So this intermediate state has its own kind of pandas dataframe object, 

469
00:32:07,800 --> 00:32:12,825
但它可以导出到HTML,LaTeX等许多不同的表格格式.
but it can export to HTML, LaTeX, a lot of different like table formats. 

470
00:32:12,825 --> 00:32:16,568
如果你的最终产品是某种摘要表格,
So if your end product is some sort of summary table, 

471
00:32:16,568 --> 00:32:18,950
那么我认为Pandas是一个非常好的选择.
then pandas I think it's a fantastic choice for that. 

472
00:32:20,550 --> 00:32:23,675
我也同意使用Vim和Python.
I would second the Vim and also Python. 

473
00:32:23,750 --> 00:32:26,275
我认为这两个工具是我最常用的数据处理工具之一.
I think those are two of my most used data wrangling tools. 

474
00:32:26,275 --> 00:32:30,075
关于Vim,去年我们在系列课程的讲义中进行了演示,
For the Vim one, last year we had a demo in the series in the lecture notes, 

475
00:32:30,075 --> 00:32:31,125
但是我们没有在课堂上介绍它.
but we didn't cover it in class. 

476
00:32:31,125 --> 00:32:37,625
我们进行了一个演示,将一个XML文件转换为JSON版本,只使用了Vim宏.
We had a demo of turning an XML file into a JSON version of that same data using only Vim macros. 

477
00:32:37,700 --> 00:32:40,075
我认为这实际上是我实践中会用的方式.
And I think that's actually the way I would do it in practice. 

478
00:32:40,075 --> 00:32:41,700
我不想去找一个工具来做这个转换.
I don't want to go find a tool that does this conversion. 

479
00:32:41,700 --> 00:32:44,975
将这个操作编码成Vim宏实际上很简单,然后我就这样做了.
It is actually simple to encode as a Vim macro, then I just do it that way. 

480
00:32:44,975 --> 00:32:48,900
此外,特别是在像Jupyter笔记本这样的交互式工具中,
And then also Python, especially in an interactive tool like a Jupyter notebook,

481
00:32:48,900 --> 00:32:50,756
用Python是进行数据处理的一种非常好的方式.
is a really great way of doing data wrangling. 

482
00:32:50,775 --> 00:32:52,574
我还想提到第三个工具,
A third tool I'd mention which I don't remember 

483
00:32:52,574 --> 00:32:56,325
我不记得我们是否介绍过,那就是一个叫做"pandoc"的工具,
if we covered in the data wrangling lecture or elsewhere is a tool called "pandoc", 

484
00:32:56,325 --> 00:32:59,425
它可以在不同的文本文档格式之间进行转换.
which can do transformations between different text document formats. 

485
00:32:59,425 --> 00:33:02,831
因此,你可以将纯文本转换为HTML或HTML转换为Markdown
So you can convert from plaintext to HTML or HTML to markdown 

486
00:33:02,831 --> 00:33:06,078
或LaTeX转换为HTML或许多其他格式.
or LaTeX to HTML or many other formats. 

487
00:33:06,078 --> 00:33:09,750
它实际上支持大量的输入格式和输出格式.
It actually supports a large list of input formats and a large list of output formats. 

488
00:33:10,300 --> 00:33:15,695
我想最后还有一个,我在数据处理讲座中简要提到过,
I think there's one last one which I mentioned briefly in the lecture on data wrangling,

489
00:33:15,695 --> 00:33:17,425
那就是R语言.
which is the R programming language. 

490
00:33:17,425 --> 00:33:21,650
它是一个非常糟糕的(我认为是非常糟糕的)编程语言,
It's an awful (I think it's an awful) language to program in, 

491
00:33:21,650 --> 00:33:25,500
我不会在数据处理的中途使用它.
and I would never use it in the middle of a data wrangling pipeline. 

492
00:33:25,500 --> 00:33:30,800
但是,在最后阶段,为了生成漂亮的图表和统计数据,R是非常好的.
But at the end, in order to like produce pretty plots and statistics, R is great. 

493
00:33:30,800 --> 00:33:33,525
因为 R 是为统计和绘图而生的,
Because R is built for doing statistics and plotting,

494
00:33:33,525 --> 00:33:40,500
有一个叫做 "ggplot" 的库,非常棒.
there's a library called "ggplot" which is just amazing. 

495
00:33:40,500 --> 00:33:45,025
"ggplot2" 从技术上讲很棒,非常棒
"ggplot2", I guess technically, it's great. 

496
00:33:45,025 --> 00:33:47,285
它可以产生非常好的可视化效果,
It produces very nice visualizations 

497
00:33:47,285 --> 00:33:55,675
让你可以很容易地处理包含多个方面的数据集,
and it lets you do very easily do things like if you have a data set that has like multiple facets, 

498
00:33:55,675 --> 00:34:01,425
不仅仅是X和Y轴,还包括X,Y,Z和其他变量.
like it's not just X and Y, it's like X Y Z and some other variable.

499
00:34:01,425 --> 00:34:03,733
如果您想将吞吐量按照所有这些参数分组,
And then you want to plot like the throughput 

500
00:34:03,733 --> 00:34:08,250
并同时生成可视化效果.
grouped by all of those parameters at the same time and produce a visualization. 

501
00:34:08,250 --> 00:34:09,800
R 语言可以让你非常容易地做到这一点,
R very easily lets you do this, 

502
00:34:09,800 --> 00:34:13,950
我还没有看到其他工具能像 R 那样容易地做到这一点.
and I haven't seen anywhere that lets you do that as easily.

503
00:34:15,925 --> 00:34:20,437
下一个问题,Docker 和虚拟机的区别是什么?
Next question, what's the difference between Docker and a virtual machine?

504
00:34:22,612 --> 00:34:26,325
该怎么解释呢?
What's the easiest way to explain this? 

505
00:34:26,400 --> 00:34:29,325
Docker 启动一些叫做"容器"的东西,
So, Docker starts something called containers, 

506
00:34:29,325 --> 00:34:31,825
Docker 并不是唯一启动容器的程序.
and Docker is not the only program that starts containers. 

507
00:34:31,825 --> 00:34:33,325
还有许多其他的程序,
There are many others, 

508
00:34:33,325 --> 00:34:37,500
通常它们依赖于底层内核的某些特性.
and usually they rely on some feature of the underlying kernel. 

509
00:34:37,500 --> 00:34:42,100
对于 Docker ,它们使用了一些叫做 LXC 的东西,这是 Linux 容器.
In the case of Docker, they use something called LXC, which are Linux containers. 

510
00:34:42,100 --> 00:34:45,717
基本前提是,
The basic premise there is

511
00:34:45,717 --> 00:34:49,557
如果你想启动一个看起来像虚拟机的东西,
if you want to start what looks like a virtual machine 

512
00:34:49,557 --> 00:34:55,573
并且它正在运行与您电脑上大致相同的操作系统,
that is running roughly the same operating system as you are already running on your computer, 

513
00:34:55,573 --> 00:35:00,600
那么你不需要运行另一个内核实例.
then you don't really need to run another instance of the kernel. 

514
00:35:00,600 --> 00:35:05,100
实际上,那个虚拟机可以共享内核,
Really, that other virtual machine can share a kernel, 

515
00:35:05,100 --> 00:35:09,196
你可以使用内核内置的隔离机制来启动一个程序,
and you can just use the kernel's built-in isolation mechanisms 

516
00:35:09,196 --> 00:35:13,036
这个程序会认为它正在自己的硬件上运行,
to spin up a program that thinks it's running on its hardware, 

517
00:35:13,036 --> 00:35:15,125
但实际上,它是在共享内核.
but in reality, it's sharing the kernel. 

518
00:35:15,125 --> 00:35:19,463
这意味着容器通常可以
And so this means that containers can often run with much lower overhead

519
00:35:19,463 --> 00:35:21,900
使用比完整虚拟机更低的开销运行程序.
than a full virtual machine will do. 

520
00:35:21,900 --> 00:35:23,707
但是你应该记住,
But you should keep in mind that it also has 

521
00:35:23,707 --> 00:35:27,700
它的隔离性也比较弱,因为你在两个容器之间共享内核.
somewhat weaker isolation because you are sharing a kernel between the two. 

522
00:35:27,700 --> 00:35:29,568
如果你启动了一个虚拟机,
If you spin up a virtual machine,

523
00:35:29,568 --> 00:35:35,071
唯一共享的是硬件和某种程度上共享的 hypervisor,
the only thing that's shared is sort of the hardware and to some extent, the hypervisor, 

524
00:35:35,071 --> 00:35:38,450
而 Docker 容器则共享整个内核,
whereas with a Docker container, you're sharing the full kernel, 

525
00:35:38,450 --> 00:35:43,250
这是两个不同的模型,你可能需要注意这一点.
and that is a different threat model that you might have to keep in mind.

526
00:35:47,450 --> 00:35:51,675
正如Jon指出的那样,要使用例如Docker这样的容器,
One another small note there as Jon pointed out, to use containers, something like Docker,

527
00:35:51,675 --> 00:35:55,579
你需要底层操作系统
you need the underlying operating system to be roughly the same

528
00:35:55,579 --> 00:35:59,227
与运行在容器顶部的程序所期望的操作系统大致相同.
as whatever the program that's running on top of the container expects. 

529
00:35:59,227 --> 00:36:01,659
如果你使用的是macOS,
And so if you're using macOS, for example, 

530
00:36:01,659 --> 00:36:04,795
那么你需要在虚拟机中运行Linux,
the way you use Docker is you run Linux inside a virtual machine, 

531
00:36:04,800 --> 00:36:06,875
然后在Linux上运行Docker.
and then you can run Docker on top of Linux. 

532
00:36:06,875 --> 00:36:09,787
因此,如果你使用容器来提高性能,
So maybe if you're going for containers 

533
00:36:09,787 --> 00:36:12,900
那么你就是在为性能而牺牲隔离性.
in order to get better performance, you're trading isolation for performance. 

534
00:36:12,900 --> 00:36:16,275
如果你在macOS上运行,则可能会出现与预期不完全相符的情况.
If you're running on macOS, that may not work out exactly as expected. 

535
00:36:17,025 --> 00:36:21,275
最后需要注意的是,Docker和容器有一个细微的区别.
And one last note is that there is a slight difference. 

536
00:36:21,275 --> 00:36:26,250
使用容器需要注意的问题是,
So with Docker and containers, one of the gotchas you have to be familiar with is that 

537
00:36:26,250 --> 00:36:30,715
容器更类似于虚拟机,
containers are more similar to virtual machines in the sense that 

538
00:36:30,715 --> 00:36:32,975
因为它们会持久化存储所有内容,
they will persist all the storage that you have,

539
00:36:32,975 --> 00:36:35,407
而默认情况下,Docker并不会这样做.
whereas Docker by default won't have that. 

540
00:36:35,475 --> 00:36:38,000
Docker的主要理念是
Like Docker is supposed to be running, 

541
00:36:38,000 --> 00:36:41,250
"我想运行一些软件,
so the main idea is like I want to run some software, 

542
00:36:41,250 --> 00:36:43,075
我获取了镜像,然后它运行起来了",
and I get the image,  and it runs,  

543
00:36:43,075 --> 00:36:48,275
如果你想要把东西持久性存储在本地主机上,
and if you want to have any kind of persistent storage that links to the host system, 

544
00:36:48,275 --> 00:36:50,594
你必须手动指定,
you have to kind of manually specify that,

545
00:36:50,594 --> 00:36:56,250
而虚拟机则使用提供的虚拟磁盘.
whereas a virtual machine is using some virtual disk that is being provided.

546
00:37:01,075 --> 00:37:05,050
下一个问题是,每个操作系统的优点是什么,
Next question, what are the advantages of each operating system, 

547
00:37:05,050 --> 00:37:06,650
我们如何在它们之间进行选择?
and how can we choose between them? 

548
00:37:06,650 --> 00:37:10,175
例如,怎么选择最适合我们需求的Linux发行版?
For example, choosing the best Linux distribution for our purposes. 

549
00:37:13,675 --> 00:37:16,225
我想说的是,对于很多任务来说,
I will say that for many, many tasks, 

550
00:37:16,225 --> 00:37:19,975
你所运行的具体的Linux发行版并不是那么重要的.
The specific Linux distribution that you're running is not that important. 

551
00:37:19,975 --> 00:37:25,633
重要的是了解不同类型
The thing is, it's just what kind of knowing that there are different types 

552
00:37:25,633 --> 00:37:27,425
或者分组的发行版.
or like groups of distributions. 

553
00:37:27,425 --> 00:37:32,033
例如,有一些发行版有着很频繁的更新,
So, for example, there are some distributions that have really frequent updates, 

554
00:37:32,033 --> 00:37:34,250
但是它们更容易出问题.
but they kind of break more easily. 

555
00:37:34,250 --> 00:37:40,500
例如,Arch Linux通过滚动更新的方式来推送更新,
So, for example, Arch Linux has a rolling update way of pushing updates, 

556
00:37:40,500 --> 00:37:44,050
可能会出现一些问题,不过他们觉得这样好.
where things might break but they're fine with the things being that way. 

557
00:37:44,050 --> 00:37:48,184
但是,如果你有一些非常重要的Web服务器来
Where maybe where you have some really important web server that 

558
00:37:48,184 --> 00:37:50,225
托管你所有的业务分析,
is hosting all your business analytics, 

559
00:37:50,225 --> 00:37:53,825
你肯定希望它更新的方式更加稳定.
you want that thing to have like a much more steady way of updates. 

560
00:37:53,825 --> 00:37:55,286
这就是为什么
So that's, for example, 

561
00:37:55,286 --> 00:37:59,625
你会看到像Debian这样的发行版在他们推送更新时更加保守,
why you will see distributions like Debian being much more conservative about what they push, 

562
00:37:59,625 --> 00:38:02,646
或者比如Ubuntu区分长期支持版本(LTS)和更定期的版本,
or even for example Ubuntu makes a difference 

563
00:38:02,646 --> 00:38:07,700
LTS版本每两年更新一次,
between the Long Term Releases that they are only updated every two years 

564
00:38:07,700 --> 00:38:14,650
而其他版本则更加频繁 - 例如Ubuntu每年会推出两个版本.
and the more periodic releases of one there is - it's like two a year that they make. 

565
00:38:14,650 --> 00:38:18,100
所以,了解到这种差别很重要.
So, kind of knowing that there's the difference.  

566
00:38:18,100 --> 00:38:21,671
此外,一些发行版在提供二进制文件
Apart from that, some distributions have different ways of providing the binaries to you 

567
00:38:21,671 --> 00:38:28,450
以及仓库的方式也有所不同.
and the way they have the repositories. 

568
00:38:28,450 --> 00:38:32,084
例如,我认为很多Red Hat Linux不想在官方仓库中提供非自由驱动程序,
So, I think a lot of Red Hat Linux don't want non-free 

569
00:38:32,084 --> 00:38:37,725
但Ubuntu则对其中的一些驱动程序没有问题.
drivers in their official repositories where I think Ubuntu is fine with some of them. 

570
00:38:38,075 --> 00:38:45,375
除此之外,我认为大多数Linux发行版的核心是共享的,
Apart from that, I think like just a lot of what is core to most Linux distros is kind of shared between them, 

571
00:38:45,375 --> 00:38:48,025
在共同点上有很多学习的内容.
and there's a lot of learning in the common ground. 

572
00:38:48,025 --> 00:38:50,800
所以,你不必担心具体的细节.
So, you don't have to worry about the specifics.

573
00:38:51,700 --> 00:38:54,875
这可能有些主观,但是如果您首次使用Linux,
Keeping with the theme of this class being somewhat opinionated, 

574
00:38:54,875 --> 00:38:59,099
尤其是针对本课程的主题,
I'm gonna go ahead and say that if you're using Linux, especially for the first time, 

575
00:38:59,125 --> 00:39:00,750
请选择类似Ubuntu或Debian这样的东西.
choose something like Ubuntu or Debian. 

576
00:39:00,750 --> 00:39:04,475
所以,Ubuntu也是基于Debian的发行版,但可能更加友好.
So, you Ubuntu too is a Debian-based distribution but maybe is a little bit more friendly. 

577
00:39:04,475 --> 00:39:06,150
Debian则更加简约.
Debian is a little bit more minimalist. 

578
00:39:06,150 --> 00:39:08,475
例如,我在所有的服务器上使用Debian,
I use Debian and all my servers, for example. 

579
00:39:08,475 --> 00:39:11,025
我在自己使用的计算机上用的是Debian桌面发行版.
And I use Debian desktop on my desktop computers that run Linux. 

580
00:39:11,025 --> 00:39:14,858
如果你想学习更多的东西,
If you're going for maybe trying to learn more things 

581
00:39:14,858 --> 00:39:19,100
并且想要平衡稳定性和最新版本的软件,
and you want a distribution that trades stability for having more up-to-date software 

582
00:39:19,100 --> 00:39:21,898
也许你可以考虑
maybe at the expense of you having to fix a broken distribution every once in a while, 

583
00:39:21,898 --> 00:39:28,625
像Arch Linux,Gentoo或Slackware这样的东西.
then maybe you can consider something like Arch Linux or Gentoo or Slackware. 

584
00:39:28,650 --> 00:39:32,051
噢,我意思是,如果你想安装Linux并只是为了完成工作,
Oh man, I'd say that like if you're installing Linux 

585
00:39:32,051 --> 00:39:34,550
Debian是一个很好的选择.
and just like want to get work done, Debian is a great choice. 

586
00:39:35,275 --> 00:39:37,500
是的,我同意这个观点.
Yeah, I think I agree with that.

587
00:39:37,500 --> 00:39:40,475
另一个观察是,你可以安装BSD.
The other observation is like you couldn't install BSD. 

588
00:39:40,475 --> 00:39:44,450
BSD从过去到现在发生了很大的变化.
BSD has come a long way from where it was. 

589
00:39:44,450 --> 00:39:47,900
虽然仍然有一些软件在BSD上无法使用,
There's still a bunch of software you can't really get for BSD, 

590
00:39:47,900 --> 00:39:50,925
但它提供了一个非常完善的文档体验.
but it gives you a very well-documented experience, 

591
00:39:50,925 --> 00:39:55,797
与Linux不同的是,
and one thing that's different about BSD compared to Linux is that

592
00:39:55,797 --> 00:40:02,150
在安装BSD时,你会得到一个完整的操作系统.
in BSD when you install BSD, you get a full operating system, mostly. 

593
00:40:02,225 --> 00:40:06,067
许多程序都是由同一个团队维护,
So many of the programs are maintained by the same team 

594
00:40:06,067 --> 00:40:09,395
他们同时升级,
that maintains the kernel and everything is sort of upgraded together, 

595
00:40:09,395 --> 00:40:12,500
这与Linux世界的工作方式有些不同.
which is a little different than how things work in the Linux world. 

596
00:40:12,500 --> 00:40:15,100
这确实也意味着更新通常会慢一点.
It does mean that things often move a little bit slower. 

597
00:40:15,100 --> 00:40:19,575
我不会用来打游戏等方面,因为对驱动程序支持一般.
I would not use it for things like gaming either because driver support is meh. 

598
00:40:19,575 --> 00:40:23,625
但是它很有趣,还是值得一看.
But it is an interesting environment to look at.

599
00:40:23,625 --> 00:40:32,675
接下来,对于像 Mac OS 和 Windows 这样的系统,如果你是一个程序员,
And then for things like Mac OS and Windows, I think if you are a programmer, 

600
00:40:32,675 --> 00:40:37,125
我不知道为什么你会使用 Windows,除非你正在构建 Windows 的东西,
I don't know why you are using Windows unless you are building things for Windows, 

601
00:40:37,125 --> 00:40:42,062
或者你想玩游戏之类的,
or you want to be able to do gaming and stuff, 

602
00:40:42,062 --> 00:40:46,800
但在这种情况下,也许可以尝试双系统,即使这也很麻烦.
but in that case, maybe try dual booting, even though that's a pain too. 

603
00:40:46,800 --> 00:40:50,639
Mac OS 是两者之间的一个很好的中间点,
Mac OS is a good sort of middle point 

604
00:40:50,639 --> 00:40:54,750
你可以得到一个相对不错的系统.
between the two where you get a system that is relatively nicely polished for you. 

605
00:40:54,750 --> 00:41:00,650
但你仍然可以访问一些较底层的内容.
But you still have access to some of the lower-level bits at least to a certain extent. 

606
00:41:00,650 --> 00:41:03,850
而且装 Mac OS 和 Windows 双系统也非常容易.
It's also really easy to dual boot Mac OS and Windows.

607
00:41:03,850 --> 00:41:09,500
但 Mac OS 和 Linux,以及 Linux 和 Windows 之间就不是这种情况了.
It is not quite the case with like Mac OS and Linux or Linux and Windows. 

608
00:41:13,300 --> 00:41:15,000
好的,来看看剩下的问题,
Alright, for the rest of the questions, 

609
00:41:15,000 --> 00:41:16,650
这些问题都没有人投票,
so these are all 0 upvote questions, 

610
00:41:16,650 --> 00:41:19,750
所以我们应该可以最后五分钟快速回答它们.
so maybe we can go through them quickly in the last five or so minutes of class. 

611
00:41:19,750 --> 00:41:21,655
下一个问题是 Vim 和 Emacs 呢?
So the next one is Vim versus Emacs? 

612
00:41:21,655 --> 00:41:24,050
Vim!很容易的答案.
Vim! Easy answer. 

613
00:41:24,050 --> 00:41:30,400
但认真的说,我们仨都把 Vim 作为我们的主编辑器.
But a more serious answer is like I think all three of us use vim as our primary editor. 

614
00:41:30,400 --> 00:41:34,175
我在一些要求用Emacs的工作中使用 Emacs,
I use Emacs for some research-specific stuff which requires Emacs.

615
00:41:34,175 --> 00:41:38,050
但总体来看,两个编辑器的理念都很有趣.
But at a higher level, both editors have interesting ideas behind them. 

616
00:41:38,050 --> 00:41:41,200
如果你有时间的话,两个都探索一下,看哪一个更适合你.
And if you have the time, it's worth exploring both to see which fits you better. 

617
00:41:41,200 --> 00:41:46,125
另外,Emacs里也有vim模式.
Also, you can use Emacs and run it in a vim emulation mode. 

618
00:41:46,125 --> 00:41:48,025
我认识很多这样做的人,
I actually know a good number of people who do that, 

619
00:41:48,025 --> 00:41:50,005
这样他们就可以使用一些很酷的 Emacs 特性
so they get access to some of the cool Emacs functionality 

620
00:41:50,005 --> 00:41:51,554
和一些酷的哲学思想。
and some of the cool philosophy behind that. 

621
00:41:51,554 --> 00:41:55,025
比如 Emacs 可以通过 Lisp 进行编程一样,这很酷.
Like Emacs is programmable through Lisp, which is kind of cool, 

622
00:41:55,025 --> 00:41:56,300
比 vimscript 好多了,
much better than vimscript.

623
00:41:56,300 --> 00:41:58,425
但人们喜欢 vim 的模态编辑,
But people like vim's modal editing, 

624
00:41:58,425 --> 00:42:03,700
所以有一个 Emacs 插件叫做 evil 模式,它在 Emacs 中提供了 vim 模态编辑.
so there's an emacs plugin called evil mode which gives you vim modal editing within Emacs. 

625
00:42:03,700 --> 00:42:08,400
所以不一定非此即彼,如果你愿意,可以将两个工具结合起来.
So it's not necessarily a binary choice, you can kind of combine both tools if you want to. 

626
00:42:08,400 --> 00:42:10,750
如果你有时间,两个编辑器都试试看.
And it's worth exploring both if you have the time.

627
00:42:11,000 --> 00:42:15,151
下一个问题:机器学习有什么技巧或诀窍吗?
Next question: Any tips or tricks for machine learning applications?

628
00:42:18,701 --> 00:42:23,232
我认为,了解一些工具的使用方法,
I think, like knowing how a lot of these tools, 

629
00:42:23,232 --> 00:42:25,750
尤其是
mainly the data wrangling a lot of the shell tools, 

630
00:42:25,750 --> 00:42:28,182
数据处理方面的许多shell工具非常重要,
it's really important 

631
00:42:28,182 --> 00:42:33,686
因为作为机器学习研究人员,很大一部分工作都是尝试不同的东西.
because it seems a lot of what you're doing as a machine learning researcher is trying different things. 

632
00:42:33,686 --> 00:42:36,050
但我认为做到这一点的核心,
But I think one core aspect of doing that, 

633
00:42:36,050 --> 00:42:38,290
就像许多科学工作一样,
and like a lot of scientific work, 

634
00:42:38,290 --> 00:42:43,730
是能够以合理的方式获得可重复的结果并将其记录下来.
is being able to have reproducible results and logging them in a sensible way. 

635
00:42:43,750 --> 00:42:47,223
例如,与其想出
So for example, instead of trying to come up with really hacky solutions of

636
00:42:47,223 --> 00:42:50,850
如何命名你的文件夹以理解实验,
how you name your folders to make sense of the experiments, 

637
00:42:50,850 --> 00:42:53,367
不如直接使用一个JSON文件
maybe it's just worth having, for example, what I do is 

638
00:42:53,367 --> 00:42:56,375
它描述了整个实验.
have like a JSON file that describes the entire experiment. 

639
00:42:56,375 --> 00:42:58,500
我通常会在其中记录所有的参数,
I know like all the parameters that are within 

640
00:42:58,500 --> 00:43:02,925
然后我可以使用我们已经介绍过的工具,
and then I can really quickly, using the tools that we have covered, 

641
00:43:02,925 --> 00:43:09,525
快速查询到使用特定数据集的实验.
query for all the experiments that have some specific purpose or use some dataset. 

642
00:43:09,525 --> 00:43:10,400
诸如此类.
Things like that. 

643
00:43:10,400 --> 00:43:13,706
除此之外,另一方面,
Apart from that, the other side of this is 

644
00:43:13,706 --> 00:43:19,250
如果你正在进行机器学习训练,
if you are running kind of things for training machine learning applications 

645
00:43:19,250 --> 00:43:21,900
而你还没有使用
and you are not already using some sort of cluster,

646
00:43:21,900 --> 00:43:25,250
类似于大学或公司提供的某种集群,
like university or your company is providing 

647
00:43:25,300 --> 00:43:31,025
那么你可能只是手动通过SSH连接到目标计算机,这是许多实验室所采用的简单方式.
and you're just kind of manually sshing, like a lot of labs do because that's kind of the easy way. 

648
00:43:31,025 --> 00:43:33,996
那么自动化这项工作是很值得的,
It's worth automating a lot of that job because 

649
00:43:33,996 --> 00:43:35,949
因为手动进行这些操作可能看起来很不起眼,
it might not seem like it 

650
00:43:35,949 --> 00:43:40,045
但却需要
but manually doing a lot of these operations takes away a lot of your time 

651
00:43:40,045 --> 00:43:45,200
大量的时间和精力.
and also kind of your mental energy for running these things.

652
00:43:47,925 --> 00:43:52,725
还有其他的vim技巧吗?我有一个建议.
Anymore vim tips? I have one. 

653
00:43:52,725 --> 00:43:57,197
在vim讲座中,我们尽量不会向你介绍太多不同的vim插件,
So in the vim lecture we tried not to link you to too many different vim plugins 

654
00:43:57,197 --> 00:43:59,275
因为我们不希望那堂课让你感到不知所措.
because we didn't want that lecture to be overwhelming. 

655
00:43:59,275 --> 00:44:01,535
但我认为探索vim插件是值得的,
But I think it's actually worth exploring vim plugins 

656
00:44:01,535 --> 00:44:04,050
因为有很多非常酷的插件可供选择.
because there are lots and lots of really cool ones out there. 

657
00:44:04,050 --> 00:44:07,475
一个资源是你可以使用不同的讲师的配置文件.
One resource you can use is the different instructors dotfiles. 

658
00:44:07,475 --> 00:44:11,251
跟大多数人一样,我使用了大约两打vim插件,
Like a lot of us, I think I use like two dozen vim plugins 

659
00:44:11,251 --> 00:44:14,325
我发现其中很多都很有用,而且我每天都在使用它们.
and I find a lot of them quite helpful and I use them every day. 

660
00:44:14,325 --> 00:44:16,200
我们仨使用的插件都略微不同.
We all use slightly different subsets of them. 

661
00:44:16,200 --> 00:44:19,912
因此,去看看我们使用了什么或查看我们给出链接的其他资源,
So go look at what we use or look at some of the other resources we've linked to 

662
00:44:19,912 --> 00:44:21,960
你可能会发现一些有用的东西.
and you might find some stuff useful. 

663
00:44:22,050 --> 00:44:23,705
另外,
A thing to add to that is, 

664
00:44:23,705 --> 00:44:27,975
我认为我们在讲座中没有详细介绍过的是leader键,
I don't think we went into a lot of detail in the lecture, correct me if I'm wrong. 

665
00:44:27,975 --> 00:44:30,041
这是一种特殊的键,
It's getting familiar with the leader key 

666
00:44:30,041 --> 00:44:36,475
很多程序,特别是插件,都会使用到它,
which is kind of a special key that a lot of programs will especially plugins, that will link to.

667
00:44:36,475 --> 00:44:41,250
比如vim里很多常见操作虽然已经很简短了,
And for a lot of the common operations vim has short ways of doing it, 

668
00:44:41,250 --> 00:44:45,150
但是通过leader键可以更快.
but you can just figure out like quicker versions for doing them. 

669
00:44:45,150 --> 00:44:51,457
例如,我知道你可以使用`:wq`来保存和退出,
So for example, like I know that you can do like ":wq" to save 

670
00:44:51,457 --> 00:44:54,777
或者可以使用`ZZ`,
and exit or that you can do like capital ZZ 

671
00:44:54,777 --> 00:44:58,282
但我实际上只是使用leader(对我来说是空格),然后"w".
but I just actually just do leader (which for me is the space) and then "w".

672
00:44:58,282 --> 00:45:02,906
我已经为我经常执行的很多操作
And I have done that for a lot of a lot of kind of common operations 

673
00:45:02,906 --> 00:45:04,375
做到了这一点.
that I keep doing all the time. 

674
00:45:04,375 --> 00:45:06,540
因为在极其常见的操作中
Because just saving one keystroke

675
00:45:06,540 --> 00:45:10,500
节省一个按键,每月就能节省数千个按键.
for an extremely common operation is just saving thousands a month.

676
00:45:11,300 --> 00:45:14,075
是的,我来稍微展开说说什么是leader key,
Yeah just to expand a little bit on what the leader key is, 

677
00:45:14,075 --> 00:45:15,575
所以在vim中,你可以绑定一些键.
so in vim you can bind some keys. 

678
00:45:15,575 --> 00:45:19,679
我可以做像"ctrl+j"这样的事情,就按住一个键然后按另一个.
I can do like "ctrl+j" does something like holding one key and then pressing another. 

679
00:45:19,679 --> 00:45:22,775
我可以将其绑定到某个动作,或者我可以将单个键绑定到某个动作.
I can bind that to something or I can bind a single keystroke to something.

680
00:45:22,775 --> 00:45:25,425
leader key让你做的是绑定.
What the leader key lets you do, is bind. 

681
00:45:25,425 --> 00:45:27,975
因此,你可以指定任何键作为leader key,
So you can assign any key to be the leader key

682
00:45:27,975 --> 00:45:32,025
然后将leader加上其他某个键绑定到某个操作.
and then you can assign leader followed by some other key to some action. 

683
00:45:32,025 --> 00:45:36,125
例如,像Jose的leader key是空格,
So for example, like Jose's leader key is space and they can combine space 

684
00:45:36,125 --> 00:45:40,725
他可以将空格与按了空格后的某个其他键组合在一起,绑定到任意vim命令.
and then releasing space followed by some other key to an arbitrary vim command. 

685
00:45:40,725 --> 00:45:45,100
它只是给你另一种键位组合的方法.
It just gives you yet another way of binding like a whole set of key combinations. 

686
00:45:45,100 --> 00:45:49,100
Leader key加上键盘上的任何键可以实现某种功能.
Leader key plus kind of any key on the keyboard to some functionality.

687
00:45:49,625 --> 00:45:54,287
我忘记在vim讲座中有没有讲宏了,
I think I've I forget whether we covered macros in the vim,

688
00:45:54,287 --> 00:45:57,096
但是学习vim宏是很值得的.
but like vim macros are worth learning. 

689
00:45:57,175 --> 00:45:59,125
它们并不复杂,
They're not that complicated 

690
00:45:59,125 --> 00:46:02,075
但知道它们的存在
but knowing that they're there and knowing how to use them 

691
00:46:02,075 --> 00:46:03,803
以及如何使用它们将节省你很多时间.
is going to save you so much time.

692
00:46:03,825 --> 00:46:07,250
另一个是称为"mark(标记)"的东西.
The other one is something called marks. 

693
00:46:07,250 --> 00:46:13,200
因此,在vim中,你可以按"m",然后按键盘上的任何字母,就可以该文件中打标记,
So in vim you can press "m" and then any letter on your keyboard to make a mark in that file 

694
00:46:13,200 --> 00:46:18,375
然后可以按反引号,再按相同字母就可以跳回同一位置.
and then you can press apostrophe on the same letter to jump back to the same place. 

695
00:46:18,375 --> 00:46:21,056
例如,如果你要在两个代码的不同部分之间来回移动,
This is really useful if you're like moving back 

696
00:46:21,056 --> 00:46:23,808
这将非常有用.
and forth between two different parts of your code for example. 

697
00:46:23,808 --> 00:46:25,841
你可以将一个标记为"a",另一个标记为"b",
You can mark one as "a" and one as "b" 

698
00:46:25,841 --> 00:46:28,825
然后使用{\rcode}a{\r}和{\rcode}b{\r}在它们之间跳转.
and you can then jump between them with tick a and tick b.

699
00:46:28,825 --> 00:46:33,797
还有"Ctrl+O"可以跳转回到你在文件中上一次停留的位置,
There's also "Ctrl+O" which jumps to the previous place you were in the file

700
00:46:33,797 --> 00:46:36,350
无论是什么原因导致你移动了光标.
no matter what caused you to move. 

701
00:46:36,350 --> 00:46:39,625
例如,如果我在某行,
So for example if I am in a some line 

702
00:46:39,625 --> 00:46:41,574
然后跳转到"b",然后跳转到"a",
and then I jump to "b"  and then I jump to "a", 

703
00:46:41,574 --> 00:46:46,200
"Ctrl+O"将带我回到"b",然后再回到我最初的位置.
"Ctrl+O" will take me back to "b" and then back to the place I originally was. 

704
00:46:46,200 --> 00:46:47,907
如果你正在执行搜索,
This can also be handy for things like 

705
00:46:47,907 --> 00:46:52,963
则可以使用"Ctrl+O"从搜索的位置很方便地移动到文件的其他部分.
if you're doing a search then the place that you started the search is a part of that stack. 

706
00:46:53,000 --> 00:46:56,291
所以我可以进行搜索,然后我逐步浏览搜索结果并更改它们,
So I can do a search I can then like step through the results 

707
00:46:56,291 --> 00:46:59,850
然后按 "Ctrl+O" 原路返回.
and like change them and then "Ctrl+O" all the way back up to the search. 

708
00:46:59,850 --> 00:47:03,203
"Ctrl+O" 还允许你跨文件移动.
"Ctrl+O" also lets you move across files.

709
00:47:03,203 --> 00:47:06,531
因此如果我从一个文件转到另一个文件的某个位置,
So if I go from one file to somewhere else in different file 

710
00:47:06,531 --> 00:47:07,861
然后再返回第一个文件的某个位置.
and somewhere else in the first file. 

711
00:47:07,861 --> 00:47:10,499
"Ctrl+O"将让我我按栈逐步返回[*]
"Ctrl+O" will move me back through that stack
[*Ctrl+O"底层是使用栈这个数据结构]

712
00:47:10,499 --> 00:47:15,500
"Ctrl+I"可以向前移动该栈.
and then there's "Ctrl+I" to move forward in that stack. 

713
00:47:15,500 --> 00:47:18,425
因此,它并不是一旦弹出就永远消失.
So it's not as though you pop it and it goes away forever.

714
00:47:18,425 --> 00:47:23,150
":earlier" 这个命令很方便.
The command ":earlier" is really handy. 

715
00:47:23,150 --> 00:47:27,725
使用":earlier"可以获取文件的早期版本,
So, ":earlier" gives you an earlier version of the same file

716
00:47:27,725 --> 00:47:32,675
这是基于时间而不是基于操作的.
and it does this based on time not based on actions. 

717
00:47:32,675 --> 00:47:35,725
例如,如果你按了一些撤销和重做操作
So for example if you press a bunch of like undo and redo

718
00:47:35,725 --> 00:47:37,300
并进行了一些更改,
and make some changes and stuff, 

719
00:47:37,300 --> 00:47:43,575
":earlier"将获取文件的真正早期版本并将其还原到缓冲区.
":earlier" will take a literally earlier as in time version of your file and restore it to your buffer. 

720
00:47:43,575 --> 00:47:45,773
有时这很有用,
This can sometimes be good if you like

721
00:47:45,773 --> 00:47:50,000
如果你撤销了某些编辑操作,然后又重新编辑了一些内容,
undid and then rewrote something and then realize you actually wanted the version 

722
00:47:50,000 --> 00:47:53,775
之后又发现你实际上需要之前的版本,":earlier"可以让你这样做.
that was there before you started undoing ":earlier" lets you do this.

723
00:47:53,775 --> 00:47:59,850
另外,还有一个叫做"undo tree"的插件,
And there's a plugin called undo tree or something like that. 

724
00:47:59,850 --> 00:48:05,750
它向你展示vim撤销地历史记录完整地树结构.
There are several of these, that let you actually explore the full tree of undo history the vim keeps,

725
00:48:05,750 --> 00:48:09,175
它不仅仅保留线性历史记录,而是保留了完整的树结构.
Because it doesn't just keep a linear history, it actually keeps the full tree. 

726
00:48:09,175 --> 00:48:10,418
使用这个插件,
Letting you explore that 

727
00:48:10,418 --> 00:48:14,066
在某些情况下可能会避免你重新输入过去输入过的东西,
might in some cases save you from having to re-type stuff you typed in the past 

728
00:48:14,066 --> 00:48:18,925
或者忘记一开始的代码而导致不能工作.
or stuff  you just forgot exactly what you had there that used to work and no longer works.  

729
00:48:18,925 --> 00:48:22,122
还有一个我想要提到的就是,
And this is one final one I want to mention, which is,

730
00:48:22,122 --> 00:48:27,178
我们提到过vim中有动词和名词,
we mentioned how in vim you have verbs and nouns, right? 

731
00:48:27,178 --> 00:48:28,950
对于你的动词比如删除或复制,
To your verbs like delete or yank, 

732
00:48:28,950 --> 00:48:33,660
你还有名词,比如下一个字符
and then you have nouns like next of this character 

733
00:48:33,660 --> 00:48:35,964
或百分号来跳转括号等等.
or percent to swap brackets and that sort of stuff. 

734
00:48:35,964 --> 00:48:40,025
搜索命令是一个名词,
The search command is a noun, 

735
00:48:40,025 --> 00:48:44,400
所以你可以做一些类似"d/{string}"的操作,
so you can do things like "d/{string}", 

736
00:48:44,400 --> 00:48:48,025
它将删除到下一个匹配该模式的位置.
and it will delete up to the next match of that pattern. 

737
00:48:48,025 --> 00:48:52,800
这个功能非常有用,我经常使用.
This is extremely useful and I use it all the time. 

738
00:48:58,100 --> 00:49:01,577
还有一个
One another neat addition on the undo stuff 

739
00:49:01,577 --> 00:49:04,841
我发现对撤销功能的一个非常有价值的补充是,
that I find incredibly valuable in an everyday basis is that 

740
00:49:04,841 --> 00:49:11,250
vim内置的一个功能,就是你可以指定一个撤销目录.
like one of the built-in functionalities of vim is that you can specify an undo directory. 

741
00:49:11,250 --> 00:49:14,185
如果你指定了一个撤销目录,
And if you have specified an undo directory, 

742
00:49:14,185 --> 00:49:16,860
默认情况下,如果你没有启用这个功能,
by default vim, if you don't have this enabled, 

743
00:49:16,860 --> 00:49:21,400
每次进入一个文件时,你的撤销历史记录都是干净的.
whenever you enter a file, your undo history is clean. 

744
00:49:21,400 --> 00:49:22,625
什么东西都不会留下.
There's nothing in there. 

745
00:49:22,625 --> 00:49:26,550
你在文件中进行修改并撤消操作时,你会创建一个历史记录,
And as you make changes and then undo them, you kind of create this history, 

746
00:49:26,550 --> 00:49:29,350
但一旦你退出文件,它就会丢失.
but as soon as you exit the file, that's lost. 

747
00:49:31,275 --> 00:49:34,000
对不起,只要你一退出vim,它就会丢失.
Sorry, as soon as you exit vim, that's lost. 

748
00:49:34,000 --> 00:49:36,470
然而,如果你设置了一个撤销目录,
However, if you have an undodir,

749
00:49:36,470 --> 00:49:40,118
vim将持久化存储所有这些更改到这个目录中,
vim is gonna persist all those changes into this directory, 

750
00:49:40,118 --> 00:49:44,450
所以无论你进入和离开多少次,历史记录都将被保存,
so no matter how many times you enter and leave that history is persisted, 

751
00:49:44,450 --> 00:49:46,377
并且这非常有帮助,
and it's incredibly helpful 

752
00:49:46,377 --> 00:49:50,296
因为它可以帮助你维持文件的更新.
because even like it can be very helpful for some files that you modify often 

753
00:49:50,296 --> 00:49:52,825
如果你经常修改某些文件,你可以跟踪它们的变化.
because then you can kind of keep the flow. 

754
00:49:52,825 --> 00:49:57,449
还比如,如果你修改了你的"bashrc",
But it's also sometimes really helpful if you modify your bashrc see

755
00:49:57,449 --> 00:50:00,905
然后五天后发现某些东西坏了,然后你又使用vim.
and something broke like five days later and then you've vim again. 

756
00:50:00,925 --> 00:50:04,361
如果你没有版本控制,
Like what actually did I change, if you don't have say like version control, 

757
00:50:04,361 --> 00:50:07,900
你可以查看撤消记录,里面记录了你实际干了啥.
then you can just check the undos and that's actually what happened. 

758
00:50:07,900 --> 00:50:12,809
最后,熟悉vim的不同寄存器也非常有用,
And the last one, it's also really worth familiarizing yourself with registers and what different special registers vim uses. 

759
00:50:16,521 --> 00:50:21,725
如果你想要复制/粘贴一个特定寄存器中的内容,
So for example, if you want to copy/paste really that's gone into in a specific register, 

760
00:50:21,725 --> 00:50:27,337
而且你想要使用操作系统剪贴板来进行复制粘贴,
and if you want to for example use a copy like the OS clipboard, 

761
00:50:27,337 --> 00:50:32,850
那么你可以考虑从不同的寄存器中执行复制和粘贴操作,
you should be copying or yanking like copying and pasting from a different register, 

762
00:50:32,850 --> 00:50:34,275
寄存器有很多种.
and there's a lot of them. 

763
00:50:34,275 --> 00:50:39,775
你应该去探索一下,有很多关于寄存器的知识可以了解.
And yeah, I think that you should explore, there's a lot of things to know about registers. 

764
00:50:41,400 --> 00:50:44,041
下一个问题是关于双因素身份验证的,
The next question is asking about two-factor authentication, 

765
00:50:44,075 --> 00:50:47,200
出于时间考虑,我将简单回答一下.
and I'll just give a very quick answer to this one in the interest of time. 

766
00:50:47,225 --> 00:50:50,953
对于任何安全敏感的事情,使用双因素身份验证是值得的.
So it's worth using two-factor auth for anything security-sensitive.

767
00:50:51,050 --> 00:50:54,375
我用双因素认证来保护我的GitHub账号和邮箱等安全敏感信息.
So I use it for my GitHub account and for my email and stuff like that. 

768
00:50:54,375 --> 00:50:57,417
有很多不同类型的双因素认证,
And there's a bunch of different types of two-factor auth. 

769
00:50:57,425 --> 00:51:02,346
有基于短信的双因素认证,比如当你尝试登录时,
From SMS based to factor auth where you get special like a number texted to you 

770
00:51:02,346 --> 00:51:04,775
会向你发送一个特殊的数字,你必须输入这个数字,
when you try to log in you have to type that number 

771
00:51:04,775 --> 00:51:07,544
还有其他工具可以实现双因素认证,比如通用双因素认证(Universal 2nd Factor,U2F),
and to other tools like universal two-factor 

772
00:51:07,544 --> 00:51:11,547
这就像是将Yubikey等设备插入计算机中,每次登录时需要操作这些设备.
this is like those Yubikeys that you plug into your you have to tap it every time you login.

773
00:51:13,560 --> 00:51:15,675
嗯,jon搞了一个
yeah Jon is holding a Yubikey,
[这里老师好可爱~(◦˙▽˙◦)]

774
00:51:15,675 --> 00:51:18,700
所以并不是所有的双因素认证都是一样的,
So not all two-factor auth is created equal.

775
00:51:18,700 --> 00:51:22,860
你最好使用类似于U2F的硬件设备来进行双因素认证,而不是基于短信的认证.
And you really want to be using something like U2F rather than SMS based to factor auth. 

776
00:51:22,860 --> 00:51:24,801
还有一种基于一次性密码（One-Time Passcodes,OTP）的双因素认证,
There something based on one-time pass codes that 

777
00:51:24,801 --> 00:51:24,844
还有一种基于一次性密码（One-Time Passcodes,OTP）的双因素认证,
you have to type in.

778
00:51:24,844 --> 00:51:25,700
你需要在登录时输入仅限一次使用的密码以完成认证,
you have to type in.

779
00:51:25,700 --> 00:51:29,348
我们没时间深入讨论为什么有些方法比其他方法更好,
we don't have time to get into the details of why some methods are better than others 

780
00:51:29,348 --> 00:51:31,100
但总的来说建议使用U2F.
but at a high level use U2F 

781
00:51:31,100 --> 00:51:35,850
互联网上有许多关于为什么其他双因素认证方法不是理想选择的解释.
and the Internet has plenty of explanations for why other methods are not a great idea.

782
00:51:37,675 --> 00:51:41,463
最后一个问题:讲讲Web各个浏览器之间差异?
Last question:Any comments on differences between web browsers?

783
00:51:57,663 --> 00:52:01,363
最近几年Web浏览器之间的差异越来越少.
There are fewer and fewer differences between web browsers these day. 

784
00:52:01,400 --> 00:52:06,008
几乎所有的网页浏览器内核都是Chrome.
At this point almost all web browsers are chrome

785
00:52:06,008 --> 00:52:09,023
因为你要么是在用Chrome浏览器
Either because you're using Chrome or because you're using a browser

786
00:52:09,023 --> 00:52:12,050
要么是使用和Chrome浏览器相同引擎的浏览器.
that's using the same browser engine as Chrome. 

787
00:52:12,050 --> 00:52:14,625
这有点让人难过,
It's a little bit sad, one might say, 

788
00:52:14,625 --> 00:52:22,925
但我认为Chrome是一个很好的选择.
but I think these days whether you choose Chrome is a great browser for security reasons 

789
00:52:22,925 --> 00:52:28,045
如果你想要一个可以自定义的,
If you want to have something that's more customizable 

790
00:52:28,045 --> 00:52:35,469
或不想用google的浏览器,那么你可以使用Firefox,
or you don't want to be tied to Google then use Firefox, 

791
00:52:35,469 --> 00:52:41,125
不要使用Safari,它只是Chrome的更拉胯的版本.
don't use Safari it's a worse version of Chrome. 

792
00:52:41,125 --> 00:52:45,112
新出的Edge浏览器也很不错,
The new Internet Explorer edge is pretty decent 

793
00:52:45,112 --> 00:52:47,544
但是使用的引擎也是和Chrome一样的,
and also uses the same browser engine as Chrome 

794
00:52:47,544 --> 00:52:52,551
这没啥问题,但可以的话还是最好避免使用它,
and that's probably fine although avoid it if you can 

795
00:52:52,551 --> 00:52:55,025
因为它可能有一些你不想处理的遗留模式.
because it has some like legacy modes you don't want to deal with. 

796
00:52:58,000 --> 00:53:02,279
还有一个很酷的新浏览器叫做flow,
I think that's Oh, there's a cool new browser called flow 

797
00:53:02,279 --> 00:53:04,525
你目前不能用它做什么有用的事情,
that you can't use for anything useful yet 

798
00:53:04,525 --> 00:53:06,800
但他们正在编写自己的浏览器引擎,
but they're actually writing their own browser engine 

799
00:53:06,800 --> 00:53:08,450
这真的很棒.
and that's really neat

800
00:53:08,450 --> 00:53:11,125
Firefox也有一个叫做Servo的项目,
Firefox also has this project called servo

801
00:53:11,125 --> 00:53:15,475
他们正在使用Rust实现他们的浏览器引擎,
which is they're really implementing their browser engine in Rust 

802
00:53:15,475 --> 00:53:18,050
以实现超级并发这样的事情.
in order to write it to be like super concurrent 

803
00:53:18,050 --> 00:53:23,825
他们已经开始将该版本中的模块从Servo移植到Gecko,
and what they've done is they've started to take modules from that version and port them over to gecko 

804
00:53:25,638 --> 00:53:29,400
或者将它们与Gecko集成在一起,gecko是Firefox的主要浏览器引擎,
or integrate them with gecko which is the main browser engine for Firefox 

805
00:53:29,550 --> 00:53:31,583
以获得更好的速度提升,
just to get those speed ups there as well 

806
00:53:31,583 --> 00:53:35,450
这是一个很酷的东西,你可以关注一下.
and that's a neat neat thing you can be watching out for.

807
00:53:38,625 --> 00:53:40,700
这就是所有的问题,嘿,我们做到了.
That is all the questions, hey we did it. 

808
00:53:40,700 --> 00:53:49,575
很好,我想感谢你参加了这门Missing Semester,明年再见.
Nice I guess thanks for taking the missing semester class and let's do it again next year.

