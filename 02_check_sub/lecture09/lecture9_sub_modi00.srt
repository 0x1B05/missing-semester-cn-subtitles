1
00:00:01,275 --> 00:00:04,225
好的，那么，让我们开始今天的讲座吧。
Okay, so again, let's get started with today's lecture. 

2
00:00:04,225 --> 00:00:07,850
今天，我们将讨论安全和密码学，
So today, we're going to be talking about security and cryptography, 

3
00:00:07,850 --> 00:00:13,325
今天的讲座会与我们去年课堂上对这个话题的处理有些不同。
and today's lecture is going to be a little bit different than our treatment of this topic in last year's class. 

4
00:00:13,325 --> 00:00:20,025
去年，我们更注重从计算机用户的角度讨论安全和隐私问题，
So last year, we focused a little bit more on security and privacy from the perspective of a user of a computer, 

5
00:00:20,025 --> 00:00:24,050
但今天我们将更多地关注安全和密码学概念，
but today we're going to focus a little bit more on security and cryptography concepts 

6
00:00:24,050 --> 00:00:29,050
这些概念对于理解我们在这门课上早些时候讨论的一些工具非常重要。
that are relevant in understanding some of the tools that we talked about earlier in this class. 

7
00:00:29,050 --> 00:00:35,050
例如，我们在Git讲座中讨论了哈希函数或加密哈希函数（如sha-1），
For example, we talked about hash functions or cryptographic hash functions like sha-1 in the Git lecture, 

8
00:00:35,050 --> 00:00:42,175
在命令行环境讲座中讨论了公钥。
or we talked about public keys when we talked about SSH in the command line environment lecture. 

9
00:00:42,175 --> 00:00:48,200
因此，今天我们将更详细地讨论这些不同的密码原语，
And so today, we'll talk about these different cryptographic primitives in more detail and get an understanding of how they work 

10
00:00:48,200 --> 00:00:51,500
了解它们的工作原理以及它们在这些不同的工具中的使用方式。
and how they're used in these different tools that we're teaching in this class.

11
00:00:51,500 --> 00:00:56,650
这个讲座不是替代更严格的安全课程的，
This lecture is not a substitute for a more rigorous class in security. 

12
00:00:56,650 --> 00:01:02,250
麻省理工学院有很多非常好的课程，例如6.858，它是关于计算机系统安全的，
So there are a bunch of really good classes at MIT like 6.858, which is on computer system security,

13
00:01:02,250 --> 00:01:07,825
或者6.857和6.875，它们更加专注于密码学。
 or 6.857 and 6.875, which are more focused on cryptography. 

14
00:01:07,825 --> 00:01:13,650
因此，在没有接受这些课程或其他地方的安全形式培训的情况下，请不要从事安全工作。
So don't do security work without formal training in security from these classes or elsewhere. 

15
00:01:13,650 --> 00:01:17,225
除非你是专家，否则不要自己开发加密算法，
And unless you're an expert, don't roll your own crypto. 

16
00:01:17,225 --> 00:01:20,075
不要构建自己的加密实现或协议。
Don't build your own crypto implementations or protocols. 

17
00:01:20,075 --> 00:01:23,000
同样的原则也适用于计算机系统安全。
And the same principle applies to computer system security. 

18
00:01:23,000 --> 00:01:28,150
这个讲座不是关于构建自己的东西，而是关于了解已经存在的东西。
This lecture is not about building your own stuff; it's about understanding what's already out there. 

19
00:01:28,150 --> 00:01:30,067
因此，我们认为这个讲座将非常非正式
And so this lecture will have a very informal 

20
00:01:30,067 --> 00:01:33,650
但实用地处理这些基本的密码学概念，
but we think practical treatment of these basic cryptography concepts, 

21
00:01:33,700 --> 00:01:38,625
并希望它能帮助你理解我们在这门课上早些时候讨论的一些工具。
and yeah, hopefully, it'll help you understand some of the tools we talked about earlier in this class.

22
00:01:38,625 --> 00:01:43,400
今天的讲座计划有什么问题吗？太好了。
Any questions about the plan for today's lecture? Great. 

23
00:01:43,400 --> 00:01:46,875
那么今天的第一个话题是熵。
So the first topic for today is something called entropy. 

24
00:01:46,875 --> 00:01:48,775
熵是随机性的一种度量，
Entropy is a measure of randomness, 

25
00:01:48,775 --> 00:01:53,000
这在尝试确定密码强度时非常有用。
and this is useful, for example, when trying to determine the strength of a password. 

26
00:01:53,000 --> 00:01:56,000
让我们看看xkcd的这个漫画，
So let's take a look at this comic from xkcd. 

27
00:01:56,000 --> 00:01:58,000
我们很喜欢xkcd漫画。
We're a big fan of xkcd comics. 

28
00:01:58,000 --> 00:02:01,500
如果你以前看过这个漫画，请举手。
So this comic raises your hand if you've seen this before. 

29
00:02:01,500 --> 00:02:02,800
好的，你们中有很多人。
Okay, a good number of you. 

30
00:02:02,800 --> 00:02:08,675
这个漫画抱怨了这种常见的模式，这种模式被教给计算机用户，
So this comic is complaining about this common pattern that's been taught to users of computers, 

31
00:02:08,675 --> 00:02:12,600
即当你设计密码时，
that when you design passwords, they should be things like 

32
00:02:12,600 --> 00:02:20,425
它们应该是像“t＃0rU＆b40rM $”或“p3@ch3$”这样的字符串，
"t#0rU&b40rM$" or "p3@ch3$" -- a string in the top left -- like we should design passwords 

33
00:02:20,425 --> 00:02:24,300
就像我们应该设计充满有趣字符和其他内容的密码，以使攻击者很难猜测。
that are full of funny characters and things like that to make it hard for attackers to guess. 

34
00:02:24,300 --> 00:02:28,400
然而，事实证明，像这样的密码实际上相当脆弱，
And yet, it turns out that passwords like that are actually pretty weak and guessable 

35
00:02:28,400 --> 00:02:31,950
易于被能够快速猜测密码和暴力攻击的计算机所猜测。
by computers that can guess passwords really fast and brute-force attacks. 

36
00:02:31,975 --> 00:02:37,200
另一方面，像左下角的"correct horse battery staple"
And on the other hand, passwords which maybe intuitively don't look as secure, 

37
00:02:37,200 --> 00:02:40,425
这样直觉上看起来不太安全的密码，
like the one on the bottom left, "correct horse battery staple," 

38
00:02:40,425 --> 00:02:43,400
却被证明更安全。
that one turns out to be way more secure.

39
00:02:43,400 --> 00:02:48,425
那么我该如何量化这些不同密码的安全性呢？
So how do I actually quantify the security of these different passwords? 

40
00:02:48,425 --> 00:02:53,725
通过测量密码中的随机性数量，即其中有多少比特的随机性。
It's by measuring the amount of randomness in the password, how many bits of randomness are in there. 

41
00:02:53,725 --> 00:02:57,350
因此，熵是以比特为单位进行度量的。
And so entropy is measured in bits. 

42
00:02:57,350 --> 00:02:59,950
这段话主要是在讲如何量化密码的安全性，
This is like the same bits from information theory. 

43
00:03:05,875 --> 00:03:08,250
在简单的情况下，
And we're only going to talk about the simple case 

44
00:03:08,250 --> 00:03:10,700
我们只需要考虑从一组事物中随机选择的情况。
where you're trying to measure the amount of randomness

45
00:03:10,700 --> 00:03:14,150
当你从一组随机的事物中均匀地选择时
 when you're choosing from a set of things uniformly at random, 

46
00:03:14,150 --> 00:03:19,475
例如，构造一个由四个随机单词组成的密码时，
 so for example, when you're constructing a password that's in the format of four random words, 

47
00:03:19,475 --> 00:03:25,325
你可能在考虑从你拥有的字典中随机制作的四个随机单词的所有可能序列。
you're kind of considering all possible sequences of four random words made from some dictionary you have. 

48
00:03:25,325 --> 00:03:27,478
你可能有一本字典，比如说，十万个单词，
You might have a dictionary with, say, a hundred thousand words

49
00:03:27,478 --> 00:03:30,450
你随机统一选择每个单词。
 and you're selecting each word uniformly at random. 

50
00:03:30,450 --> 00:03:34,850
有多少种可能性？好吧，你可以去弄清楚。
How many possibilities are there? Well, you can go and figure that out. 

51
00:03:34,850 --> 00:03:38,735
在这个例子中，一旦你知道有多少种可能性，熵的度量
In that example, once you know how many possibilities there are,  the measure of entropy

52
00:03:38,735 --> 00:03:41,750
熵的度量是可能性数的对数基数 2。
 is log base 2 of the number of possibilities.  

53
00:03:46,375 --> 00:03:50,550
正如该漫画所暗示的那样，
And as that comic suggests, this is related to 

54
00:03:50,550 --> 00:03:54,450
这与攻击者尝试暴力破解您的不同密码所需的时间有关。
how long it'll take an attacker to try to brute-force through your different passwords. 

55
00:03:54,500 --> 00:03:58,875
在这个例子中，如果有一千个可能性，那么攻击者每秒尝试猜测一千个密码，
Like if you have a thousand possibilities, you're guessing passwords at a thousand passwords a second, 

56
00:03:58,875 --> 00:04:01,125
这不是一个很好的密码。
that's not a very good password. 

57
00:04:02,250 --> 00:04:05,500
所以这是几个简单的例子。
So this is a couple of quick examples. 

58
00:04:05,500 --> 00:04:08,625
抛硬币有两种可能性，
A coin flip has two possibilities, 

59
00:04:08,625 --> 00:04:10,175
让我们假设我们有一个公平的硬币。
and let's assume we have a fair coin. 

60
00:04:10,175 --> 00:04:19,600
因此，抛硬币的以2为底2，这是一点熵。
So a coin flip has log base 2 of 2, which is one bit of entropy. 

61
00:04:19,600 --> 00:04:23,150
我们可能会看到的另一件事是掷骰子之类的东西。
Another thing we might look at is something like a dice roll. 

62
00:04:24,200 --> 00:04:25,950
所以有六种可能性，
So there are six possibilities, 

63
00:04:25,950 --> 00:04:33,900
log以2为底6大约是 2.6 位的熵。
and log 2 of 6 is something like 2.6 bits of entropy. 

64
00:04:33,900 --> 00:04:37,850
这就是我们如何量化某物的随机性。
So that's how we quantify the amount of randomness in something.

65
00:04:39,200 --> 00:04:42,050
现在，回到xkcd漫画中的那个例子，
Now, going back to that example in the xkcd comic, 

66
00:04:42,050 --> 00:04:44,325
当我们想弄清楚密码中有多少熵时，
when we want to figure out how much entropy is in a password, 

67
00:04:44,350 --> 00:04:47,950
我们必须考虑如何生成密码的模型。
we have to consider the model for how the password was generated. 

68
00:04:47,950 --> 00:04:52,850
例如，在左上角，你可以考虑，好吧，我们取一个字典单词，
For example, in the top left, you could consider, okay, we take one dictionary word, 

69
00:04:52,875 --> 00:04:55,550
用看起来与该字符相似的数字替换某些字符，
make some substitutions of some of the characters 

70
00:04:55,550 --> 00:05:00,225
在末尾添加一个标点符号，
 with numbers that look similar to that character, add one punctuation mark at the end, 

71
00:05:00,225 --> 00:05:01,727
然后添加一个数字。
and add one numeral after that. 

72
00:05:01,727 --> 00:05:06,600
我们可以使用常规语言来计算这样的密码有多少种可能性，
We can take that model and then use common rhetoric to figure out how many possibilities there are, 

73
00:05:06,600 --> 00:05:10,100
然后计算出熵。
and from that, we can derive how many bits of entropy are in that password. 

74
00:05:10,100 --> 00:05:14,000
所以在那个特定的例子中，我不知道他们到底用什么模型作为密码，
So in that particular example, I don't know exactly what model they were using for the password, 

75
00:05:14,000 --> 00:05:16,600
但他们计算了28位熵。
but they calculated their 28 bits of entropy. 

76
00:05:16,975 --> 00:05:20,950
而在左下角的示例中，“correct horse battery staple”
Whereas in the bottom-left example, "correct horse battery staple", 

77
00:05:21,000 --> 00:05:26,150
他们假设你正在使用大约 2，000 个单词的字典。
  they assume that you're working from a dictionary of about 2,000 words. 

78
00:05:26,150 --> 00:05:30,650
所以当你把其中四个词组合在一起时，你会从中得到大约44位的熵。
 And so when you combine four of those words together, you get about 44 bits of entropy from that. 

79
00:05:30,650 --> 00:05:33,150
因此，它比前面的示例安全得多。
So it's much more secure than the example before it.

80
00:05:33,325 --> 00:05:38,550
那么关于熵的这个定义或为什么它有用吗？
So any questions about this definition of entropy or why it's useful?

81
00:05:42,500 --> 00:05:45,400
当您生成自己的密码时，请记住这一点。
  And when you're generating your own passwords, keep this in mind. 

82
00:05:45,400 --> 00:05:47,075
你想要一个高熵密码，
You want a high-entropy password, 

83
00:05:47,075 --> 00:05:50,550
您需要的确切数字取决于您要保护的内容。
and the exact number you need depends on exactly what you're trying to protect against. 

84
00:05:50,550 --> 00:05:53,900
就像一般而言，证券中的概念一样，您必须牢记您的威胁模型是什么。
Like in general, a concept in securities, you have to keep in mind what your threat model is. 

85
00:05:53,900 --> 00:05:58,625
比如你关心的攻击者，攻击者可能使用什么样的技术。
Like what attackers you're concerned about, what kinds of technique the attackers might be using. 

86
00:05:58,625 --> 00:06:03,150
例如，这个漫画提到了一个攻击者可以每秒猜测一千个密码。
For example, this comic refers to an attacker that can guess a thousand passwords a second. 

87
00:06:03,150 --> 00:06:06,799
这可能对某些允许人们尝试
This might be something that's possible for say, 

88
00:06:06,799 --> 00:06:10,975
使用您的电子邮件
a web service that allows people to try to log in with your email 

89
00:06:10,975 --> 00:06:13,100
和随机密码进行登录的网络服务来说是可能的。
and then random passwords that the attacker is trying. 

90
00:06:13,100 --> 00:06:18,450
但是，这个每秒猜测一千个密码的模型可能对其他情况不准确。
But this thousand passwords a second model might not be accurate for other scenarios. 

91
00:06:18,450 --> 00:06:21,174
例如，离线密码破解场景
For example, an offline password cracking scenario 

92
00:06:21,174 --> 00:06:25,050
或者攻击者已经破解了一个网站并下载了它们的数据库，
or maybe the attacker has broken into a website and downloaded their database 

93
00:06:25,150 --> 00:06:27,625
他们有一种混淆形式的您的密码，
and they have some obfuscated form of your password, 

94
00:06:27,625 --> 00:06:29,450
并且正在尝试找出密码是什么。
and they're trying to figure out what the password is. 

95
00:06:29,450 --> 00:06:33,000
也许他们可以并行化这种攻击，使其每秒进行一百万次猜测。
Maybe they can parallelize this attack and make it go to a million guesses a second .

96
00:06:33,000 --> 00:06:36,675
猜测次数取决于您需要保护自己免受什么样的攻击。
and so exactly how much entropy you need depends on exactly what you're trying to protect against. 

97
00:06:36,800 --> 00:06:40,750
但是，对于需要受到保护的网站并且您担心在线密码猜测的情况，
But roughly forty bits of entropy might be good enough for, 

98
00:06:40,750 --> 00:06:45,575
大约四十个比特的熵可能足够了。
 which is protected by a website and you're concerned about online password guesses. 

99
00:06:45,600 --> 00:06:48,700
如果您担心离线攻击并且想要真正、真正地安全，
And then maybe something like 80 bits of entropy might be good

100
00:06:48,700 --> 00:06:52,325
那么可能需要八十比特的熵。
  if you're concerned about offline attacks and you want to be really, really secure. 

101
00:06:52,325 --> 00:06:54,425
这些是您可以使用的大致指南。
So they're rough guidelines you can use. 

102
00:06:58,450 --> 00:07:01,075
那么，如何生成强密码呢？
And then how do you actually generate strong passwords? 

103
00:07:01,075 --> 00:07:02,725
首先，您需要一些密码模型。
Well, you have some model for a password. 

104
00:07:02,725 --> 00:07:04,550
例如，常用的字典词组，
For example, the for dictionary works thing, 

105
00:07:04,550 --> 00:07:06,100
您可以得到一个字典。
and you can actually get a dictionary. 

106
00:07:06,100 --> 00:07:08,300
然后，您可以使用类似于掷骰子的方法。
And then you can use methods like dice, where, 

107
00:07:08,300 --> 00:07:13,125
有一首歌曲在讲义中有链接，您可以获得物理骰子并将其滚动，
so there's a song we linked to in the lecture notes where you can actually get physical dice and roll them 

108
00:07:13,125 --> 00:07:17,275
然后将掷骰结果映射到字典词语，以最终将其转换为密码。
and then map dice rolls to dictionary words in order to eventually turn that into a password. 

109
00:07:17,325 --> 00:07:21,600
这样做的好处在于，使用一些您知道是随机的物理标记
And doing something like this, using some kind of physical token that you know is random,

110
00:07:21,600 --> 00:07:25,200
（如平衡骰子或硬币）是一个好习惯，
  like a balanced die or a coin that you know is balanced, 

111
00:07:25,200 --> 00:07:29,400
因为人类实际上并不擅长选择随机数字。
 is a good thing to do because humans are actually not good at choosing random numbers, right? 

112
00:07:29,400 --> 00:07:31,850
如果我让您从1到100中随机选择一个数字，
If I just asked you to name a random number for 1 to 100,

113
00:07:31,850 --> 00:07:35,025
您很有可能不能很好地以均匀随机的方式选择。
chances are that you're probably not doing so uniformly at random very well. 

114
00:07:35,025 --> 00:07:38,975
这就是为什么使用这些物理标记来产生随机性是好的。
And so that's why it's actually good to use these physical tokens in order to produce randomness. 

115
00:07:41,550 --> 00:07:44,000
熵是我们的第一个概念。
So entropy, that's our first concept recovering 

116
00:07:44,000 --> 00:07:50,475
有关此事或此漫画的任何问题吗？好的。
Any questions about that or about this comic? Great. 

117
00:07:50,475 --> 00:07:54,250
那么进入稍微有趣和复杂的主题，
So getting into slightly more interesting and complicated topics,

118
00:07:54,250 --> 00:07:57,650
下一个我们要谈论的是哈希函数。
 the next thing we're going to talk about is hash functions. 

119
00:07:57,650 --> 00:08:03,150
希望你们中的大多数人都参加了上一次关于Git中使用的SHA-1哈希函数的讲座。
So hopefully, most of you were here during the get lecture where we talked about the SHA-1 hash function used in get. 

120
00:08:03,150 --> 00:08:06,475
现在更详细地讨论这个主题，
So now going into that topic in a little bit more detail,

121
00:08:11,500 --> 00:08:18,175
哈希函数在高层次上是将可变数量的数据映射为固定大小输出的函数。
 hash functions at a high level are functions that map a variable amount of data into a fixed size output. 

122
00:08:18,175 --> 00:08:23,700
例如，SHA-1哈希函数是哈希函数的一个例子。
So for example, the SHA-1 hash function is one example of a hash function 

123
00:08:23,700 --> 00:08:33,375
这需要一些字节数的输入，并输出恰好 160 位的输出。
that takes in some input of some number of bytes and outputs exactly 160 bits of output. 

124
00:08:33,825 --> 00:08:38,050
这就是这个特定哈希函数的类型签名。
So that's kind of the type signature of this particular hash function. 

125
00:08:38,050 --> 00:08:41,750
然后这些函数具有一些有用的属性。
And then these functions have some number of properties that are useful. 

126
00:08:41,750 --> 00:08:49,350
因此，在高层次上，这些可以被认为是具有随机输出的难以反转的函数。
So at a high level, these can be thought about as hard-to-invert functions that have random-looking outputs. 

127
00:08:49,350 --> 00:08:54,150
我们实际上可以在一些随机数据上尝试一下。
We can actually try this out on some random piece of data. 

128
00:08:54,150 --> 00:09:01,250
例如，如果我在我的终端中输入 "printf hello"，
For example, if I enter into my terminal "printf hello", this does exactly what you would expect it does, 

129
00:09:01,250 --> 00:09:02,750
它将按照你所期望的那样打印出字符并将其导出到标准输出，
prints the set to standard out, 

130
00:09:02,750 --> 00:09:05,875
然后我可以将其导入 SHA-1 校验和命令。
and I can pipe this to the SHA-1 sum command. 

131
00:09:05,875 --> 00:09:12,275
这是一个命令行程序，通过标准输入接受输入，并计算SHA-1函数，
So this is a command-line program that accepts input via standard in and computes this SHA-1 function, 

132
00:09:12,275 --> 00:09:16,650
该函数从输入中获取一些可变数量的字节并生成一个160位的输出，
which takes in some variable number of bytes from the input and produces a 160-bit output,

133
00:09:16,650 --> 00:09:21,350
该输出在这种情况下表示为十六进制字符串。
 which in this particular case is represented or encoded as a hexadecimal string. 

134
00:09:21,350 --> 00:09:23,300
因此，它是一个长度为40的十六进制字符串，
So it's a length 40 hexadecimal string, 

135
00:09:23,300 --> 00:09:24,875
并且您可以在此处看到此输出。
and you see this output right here. 

136
00:09:24,875 --> 00:09:29,050
 "-"只是表示它从标准输入中获取了输入。
This "-" just means it took its input from standard in. 

137
00:09:29,050 --> 00:09:32,050
因此，此输出看起来像某些随机数字，
So this output just looks like some random number, 

138
00:09:32,050 --> 00:09:35,700
但重要的一点是，这是一个确定性数字。
but one important thing is that this is a deterministic number. 

139
00:09:35,700 --> 00:09:38,775
如果您在自己的计算机上尝试相同的命令
If you try the same command on your own computer,

140
00:09:38,775 --> 00:09:41,575
“printf hello | SHA-1 something”，您将得到相同的输出。
  "printf hello | SHA-1 something", you will get the same number out. 

141
00:09:41,600 --> 00:09:46,750
因此，SHA-1是一些人们已经就其所有参数达成一致的著名函数。
  So SHA-1 is some well-known function that people have agreed upon for all its parameters. 

142
00:09:46,750 --> 00:09:53,075
只要略微调整输入，比如说将“hello”更改为一个大写的“Holo”，
we'll see that if we tweak the input a little bit, like say changed 'hello' to 'elllo' with a capital H, 

143
00:09:53,075 --> 00:09:55,400
现在我得到了一个完全不同的输出。
  now I get a completely different looking output. 

144
00:09:55,400 --> 00:09:58,875
即使它是确定性的，它也看起来像某种其他随机的数字，
And this also looks like some other kind of random-ish number, even though it is deterministic, 

145
00:09:58,875 --> 00:10:01,625
并且您可以在自己的计算机上再现它。
and you could reproduce this on your own computer.

146
00:10:06,200 --> 00:10:10,425
哈希函数具有许多重要属性。
Hash functions have a number of properties that are pretty important. 

147
00:10:15,750 --> 00:10:20,075
密码哈希函数具有的第一个属性是它们是不可逆的。
The first property that cryptographic hash functions have is that they're non-invertible. 

148
00:10:20,075 --> 00:10:23,075
这意味着，如果您获取此函数的输出，例如，即
And what that means is that if you take the output from this function,

149
00:10:23,075 --> 00:10:27,189
“aaf4...”，
 for example, that is 'aaf4...',  as shown there

150
00:10:27,189 --> 00:10:33,475
则很难弄清楚产生该输出的输入是什么。
 from that output, it's hard to figure out what the input was that produced that output. 

151
00:10:33,750 --> 00:10:37,700
因此，您可以很容易地计算SHA-1哈希值，
So you can go one way, compute the SHA-1 hash easily, 

152
00:10:37,700 --> 00:10:39,300
但是您无法逆向操作。
but you can't go backwards.

153
00:10:39,300 --> 00:10:45,000
这些函数具有的另一个属性是它们是抗碰撞的。
Another property that these functions have is that they're collision-resistant. 

154
00:10:49,625 --> 00:10:56,500
这个属性的意思是很难找到两个不同的输入产生相同的输出。
And what this property means is that it's hard to find two different inputs that produce the same output. 

155
00:10:56,875 --> 00:11:01,550
因此，这基本上描述了什么是密码哈希函数。
So this basically describes what a cryptographic hash function is.

156
00:11:01,550 --> 00:11:10,300
你们有什么问题吗？
So any questions about the kind of specification of a cryptographic hash function? Okay, 

157
00:11:10,300 --> 00:11:12,825
那么，这些哈希函数实际上有什么用途呢？
so what are these hash functions actually useful for? 

158
00:11:12,825 --> 00:11:17,175
嗯，我们已经在Git中看到了内容地址存储的一个应用。
Well, we've already seen one application in Git for content address storage. 

159
00:11:17,175 --> 00:11:24,675
因此，我们希望得到一种统一的方式来命名存储在对象存储中的不同对象，
So we want it get, we want some uniform way of naming different objects that are in the object store, 

160
00:11:24,675 --> 00:11:28,200
而Git将它们全部命名为它们的SHA-1哈希。
and it turns out that Git addresses all of them by their SHA-1 hash.

161
00:11:28,200 --> 00:11:31,250
因此，您拥有要存储的实际数据，
So you have the actual data you want to store, 

162
00:11:31,250 --> 00:11:35,575
然后要为该特定数据命名，只需命名SHA-1哈希即可。
and then to name that particular piece of data, you just name the SHA-1 hash. 

163
00:11:35,575 --> 00:11:38,550
所有这些都以特定方式存储在对象存储中。
And all of that is stored in the object store in that particular way. 

164
00:11:39,500 --> 00:11:42,675
我们在查看Git的许多不同部分时看到了这一点。
We see this when looking at many different parts of Git. 

165
00:11:42,675 --> 00:11:44,650
例如，右边这里，我进入Git存储库。
For example, right here, I'm going to Git repository. 

166
00:11:44,650 --> 00:11:46,750
如果我执行'git log'，它会显示提交。
If I do 'git log', it shows me the commits. 

167
00:11:46,775 --> 00:11:52,875
例如，这个数字上面是密码哈希函数SHA-1应用于
And for example, this number up here is the cryptographic hash function SHA-1 

168
00:11:52,875 --> 00:11:56,350
描述此特定提交的提交对象。
 applied to the commit object that describes this particular commit.

169
00:11:57,400 --> 00:12:02,125
那么，有人知道为什么Git在这里使用密码哈希函数而不是......
So does anybody know why Git uses a cryptographic hash function here as opposed to... 

170
00:12:02,175 --> 00:12:06,225
你可能在其他计算机科学课程中听说过称为散列函数的东西，
So you might have heard in your other computer science classes, like say your introductory algorithms class, 

171
00:12:06,225 --> 00:12:11,600
没有前面加上“密码学”这个词。
there are things called hash functions without the word 'cryptographic' appended in front of them. 

172
00:12:11,600 --> 00:12:17,800
它们具有类似的属性，可以将可变大小的输入转换为某个固定大小的输出。
And they have similar properties that they turn a variable-sized input into some fixed-size output. 

173
00:12:17,800 --> 00:12:20,903
但是它们并没有完全具备
But they don't quite have these properties 

174
00:12:20,903 --> 00:12:25,100
难以找到产生特定输出的输入等属性。
where it's hard to find an input that produces a particular output or things like that. 

175
00:12:25,100 --> 00:12:27,225
这是一种比较弱的定义。
It's a kind of weaker definition than this.

176
00:12:27,225 --> 00:12:30,850
那么，为什么在 Git 中我们关心拥有一个密码哈希函数
So why is it that in Git we care about having a cryptographic hash function

177
00:12:30,850 --> 00:12:33,154
而不仅仅是一个普通的哈希函数？
 as opposed to just a regular old hash function? 

178
00:12:33,154 --> 00:12:34,450
大家有什么想法吗？
Does anybody have any ideas?

179
00:12:45,650 --> 00:12:53,775
是的，基本上就是这样，我们不希望这个哈希函数的输出产生冲突。
 Yeah, that's basically it, that we don't want to have kind of conflicts in the output from this hash function. 

180
00:12:53,775 --> 00:12:58,725
就像每个提交都由一个哈希函数标识，每个文件都由该文件的哈希标识。
Like every commit is identified by a hash function, every file is identified by the hash of that file. 

181
00:12:58,725 --> 00:13:03,900
如果在实践中有两个不同的内容产生了相同的输出，也就是说，
If it were ever the case that two different pieces of content in practice produce the same output, that is, 

182
00:13:03,900 --> 00:13:08,550
如果该函数不具有抗碰撞性，那么这可能会造成很大问题。
if the function were not collision-resistant, that could be really problematic, right?

183
00:13:08,550 --> 00:13:12,950
因为你和我，我们可能会为了得到我们认为是相同的 repo，
Because then you and I, we could have to do to get repos that we think are the same,

184
00:13:12,950 --> 00:13:14,850
检出相同的提交哈希，
 we check out the same commit hash, 

185
00:13:14,850 --> 00:13:17,275
并且我们可能会得到不同的文件。
and we might end up with different files. 

186
00:13:17,375 --> 00:13:22,975
这是令人担忧的，因为 Git 用于跟踪软件、跟踪软件的开发，
And this is concerning because Git is used to track software, a track development of software, 

187
00:13:22,975 --> 00:13:28,150
同时也涉及确保正确的人员在编写软件，
and it's also kind of involved in making sure that the right people are authoring the software,

188
00:13:28,150 --> 00:13:29,950
没有发生任何有趣的事情。
  nothing funny has happened in the process. 

189
00:13:29,950 --> 00:13:31,842
例如，有许多开源项目，
 For example, there are all these open-source projects 

190
00:13:31,842 --> 00:13:35,075
如 Linux 内核，使用 Git 进行开发。
like the Linux kernel where development is done using Git. 

191
00:13:35,100 --> 00:13:38,250
如果某个 Git 贡献者能够编辑
It would be really bad if some contributor to Git 

192
00:13:38,250 --> 00:13:42,557
某个文件并提出一些看起来相当良性的更改请求，
could say edit some file and propose some change that looks pretty benign like, 

193
00:13:42,557 --> 00:13:46,900
比如“让我改进一下 Linux 的这个部分”，提交该更改请求给 Linux 开发人员，
'Oh, let me go and improve this part of Linux,' submit that change request to the Linux developers, 

194
00:13:46,900 --> 00:13:53,000
然后在实践中实际提供一个具有相同提交哈希等的 Git 存储库，
and then in practice actually supply a Git repository that has the same commit hash and whatnot, 

195
00:13:53,000 --> 00:13:55,400
但实际上文件内容是不同的，
but actually the file contents are different. 

196
00:13:55,400 --> 00:13:56,325
那么就有一些恶意行为。
There's something malicious. 

197
00:13:56,325 --> 00:14:01,815
因此，Git 实际上依赖于这个 SHA-1 函数作为密码哈希函数，
So Git actually relies on this SHA-1 function being a cryptographic hash function

198
00:14:01,815 --> 00:14:04,700
以实现安全性。
 in order to achieve security. 

199
00:14:05,300 --> 00:14:12,750
还有其他一些有趣的哈希函数应用吗？
Any questions about that and some other interesting applications of hash functions?

200
00:14:12,750 --> 00:14:16,175
所以，就像我们看到的那样，哈希函数将大输入转换为小输出，
So, as we saw, hash functions turn big inputs into small outputs, 

201
00:14:16,175 --> 00:14:19,350
而且由于哈希函数是抗碰撞的，
and in a way, because the hash function is collision-resistant, 

202
00:14:19,350 --> 00:14:23,100
输出可以用来验证或标识输入。
the output can be used to kind of attest to or identify the input. 

203
00:14:23,100 --> 00:14:28,050
因此，您可以将哈希视为文件的简短摘要。
And so you can think of a hash as a short summary of a file. 

204
00:14:28,225 --> 00:14:30,925
例如，在此目录中的一堆文件中，
For example, in this directory of a bunch of files,

205
00:14:30,925 --> 00:14:34,975
我可以计算该目录下的一些文件的 SHA-1 校验和。
 I can compute the SHA-1 sum of some file in this directory. 

206
00:14:35,125 --> 00:14:39,900
这是应用于此自述文件 MD 文件的 SHA-1 算法。
And this is the SHA-1 algorithm applied to this readme MD file. 

207
00:14:39,950 --> 00:14:44,068
有趣的是，计算出另一个具有相同哈希输出的文件
And what's interesting is that it is computationally hard or like impossible,

208
00:14:44,068 --> 00:14:47,375
在计算上是计算上困难的，
 you can kind of think of it as impossible, to find any other file, 

209
00:14:47,375 --> 00:14:50,875
或者你可以认为是不可能的。
so a different file that has the same hash output. 

210
00:14:50,875 --> 00:14:56,150
在从互联网下载文件的情况下，这种场景非常有用。
And one scenario in which this is useful is when you download files from the internet. 

211
00:14:56,225 --> 00:15:03,250
例如，有许多 Linux 发行版从其网站分发大型 CD 或 DVD 映像。
For example, there are lots of Linux distributions that distribute large CD or DVD images from their website. 

212
00:15:03,250 --> 00:15:06,775
像我可以到 Debian org 上下载最新版本的 Debian。
Like, I can go to Debian org and download the latest version of Debian. 

213
00:15:07,025 --> 00:15:10,125
问题是，托管这些文件可能是昂贵的。
The thing is that hosting those files can be expensive. 

214
00:15:10,125 --> 00:15:13,100
因此，许多人很好心地提供这些文件的镜像。
And so a lot of people are nice enough to host mirrors of these files. 

215
00:15:13,150 --> 00:15:15,700
所以，我可以去许多其他站点之一，
So instead of downloading Debian from Debian org, 

216
00:15:15,700 --> 00:15:18,575
而不是从Debian org下载Debian，
I can go to one of many other sites 

217
00:15:18,575 --> 00:15:22,925
下载那些在Debian org托管的应该是相同的文件。
and download what are supposed to be the same files that are hosted at Debian org. 

218
00:15:22,925 --> 00:15:26,525
但是，我怎么知道我实际上得到了正确的文件？
But how do I know that I actually got the correct file? Like, 

219
00:15:26,625 --> 00:15:32,000
比如，如果我设置了一个恶意镜像，你去了类似Anisha是恶意Debian网站的地方
what if I set up a malicious mirror and you go to like Anisha is evil Debian website com

220
00:15:32,000 --> 00:15:36,600
然后尝试下载Debian，结果你的Linux安装被植入了后门。
 and then try to download Debian,  turns out that your Linux installation is backdoored.  

221
00:15:36,600 --> 00:15:40,675
好吧，你可以做的一件事就是从原始的Debian网站下载一份副本，
Well, one thing you could do is download a copy from the original Debian website 

222
00:15:40,675 --> 00:15:42,475
然后下载我的版本并进行比较。
and then download my version and compare them. 

223
00:15:42,475 --> 00:15:44,025
但这有点违背了初衷，对吧？
But that kind of defeats the purpose, right? 

224
00:15:44,025 --> 00:15:47,875
因为我们希望避免从Debian.org下载文件，因为托管这些文件很昂贵，
Because we want to avoid downloading things from Debian org because hosting these files is expensive, 

225
00:15:47,875 --> 00:15:51,675
我们希望让许多不同的人能够在其他地方镜像文件的副本。
and we want all these different people to be able to mirror copies of the files elsewhere. 

226
00:15:51,725 --> 00:15:57,200
那么，有没有人看到加密哈希函数如何有用来解决这个问题？
So, does anybody see how cryptographic hash functions could be useful to solve this problem? 

227
00:15:57,200 --> 00:16:00,325
我想从一个不受信任的来源下载一个文件，
That I want to download a file from an untrusted source

228
00:16:00,325 --> 00:16:03,875
而不是从受信任的来源本身下载文件。
 but and not from like the trusted source itself, 

229
00:16:03,875 --> 00:16:07,000
但也许我可以从这个受信任的来源获取一些小的信息，
But maybe I can get some small piece of information from this trusted source, 

230
00:16:07,000 --> 00:16:12,425
以便知道我从不受信任的来源下载的文件是否是我应该得到的东西。
in order to know whether the file I downloaded from the untrusted source is the thing I was supposed to get. 

231
00:16:16,475 --> 00:16:20,675
是的，它基本上只是一个加密哈希函数的简单应用。
Yes, like it's basically just a straightforward application of cryptographic hash functions. 

232
00:16:20,675 --> 00:16:26,800
因此，Debian.org可以生成它们的正确ISO文件或其他文件，
So what Debian.org can do is they can produce their kind of correct ISO file or whatever they want, 

233
00:16:26,800 --> 00:16:33,275
并且不是在其网站上发布文件本身，而是发布该文件的哈希值。
and instead of publishing the file itself on their website, they can publish a hash of that file. 

234
00:16:33,275 --> 00:16:36,600
与文件本身相比，
So, compared to the file itself which may be many gigabytes,

235
00:16:36,600 --> 00:16:41,450
这个哈希值可能只有160位数据，在这种特殊情况下非常便宜。
 this is only like in this particular case 160 bits of data, right? So very cheap to host. 

236
00:16:41,450 --> 00:16:44,450
然后，作为用户，我可以从任何随机网站下载该文件，
And then what I can do as a user is I can download 

237
00:16:44,450 --> 00:16:48,250
可能是一个不受信任的网站，
that file from any random website, it could be an untrusted website, 

238
00:16:48,250 --> 00:16:51,625
下载完成后，我只需双重检查sha-1哈希值。
and after I download, I just double-check the sha-1 hash. 

239
00:16:51,625 --> 00:16:56,200
如果哈希匹配，则我知道我有正确的文件，
And if the hash matches, then I know that I have the right file 

240
00:16:56,200 --> 00:16:58,554
因为对于某人来说，给我一些不同的文件，
because it's computationally infeasible for somebody 

241
00:16:58,554 --> 00:17:02,200
而这些文件恰好具有相同的哈希值是计算上不可能的，
to give me some different file that happens to have the same hash, 

242
00:17:02,200 --> 00:17:05,000
因为哈希函数是抗碰撞的。
because hash functions are collision-resistant. 

243
00:17:06,025 --> 00:17:08,725
对此应用有任何问题吗？是的，
So any questions about that application? Yeah, 

244
00:17:18,000 --> 00:17:23,025
这是一个很好的问题，为什么需要不同的人来托管信息？
so that's a good question, like why do you need different people to host the information? 

245
00:17:23,025 --> 00:17:25,250
难道对于每个人来说都同样昂贵吗？
Like wouldn't it be equally expensive for everybody?

246
00:17:25,250 --> 00:17:27,725
这个问题的答案有点复杂，
 So the answer to that question is a little bit complicated, 

247
00:17:27,725 --> 00:17:29,950
但这是部分答案。
but like here's a partial answer. 

248
00:17:29,950 --> 00:17:34,725
一件事是从服务器下载文件受到服务器距离你有多远的影响。
One thing is that downloading files from a server is affected by how far away the server is from you. 

249
00:17:34,725 --> 00:17:39,000
举个例子，如果服务器在马萨诸塞州而您在中国，
So for example, if the server is in Massachusetts and you're in say China, 

250
00:17:39,000 --> 00:17:42,000
您必须通过互联网进行大量的往返，
you have to kind of make a big round trip across the internet, 

251
00:17:42,000 --> 00:17:44,225
这可能会因为许多原因而变得昂贵，
and that may be expensive for a number of reasons. 

252
00:17:44,225 --> 00:17:47,467
比如延迟高，
Like the latency is high and the traffic needs to go through kind of 

253
00:17:47,467 --> 00:17:50,000
流量需要通过许多不同的电线才能到达您所在的位置。
lots of different wires to make its way all the way to where you are. 

254
00:17:50,000 --> 00:17:55,250
因此，这些网站所做的一件事情就是将他们的内容分发到世界各地的服务器上，
And so one thing that these websites do is that they distribute their content to servers that are all over the world, 

255
00:17:55,250 --> 00:17:58,050
然后作为用户，您从最接近您的服务器下载。
and then as a user, you download from the server that's closest to you. 

256
00:17:58,050 --> 00:18:03,400
比如，MIT维护一个Debian软件包存储库，镜像了所有的Debian软件。
Like for example, MIT maintains a Debian package repository and kind of mirrors all the Debian stuff. 

257
00:18:03,400 --> 00:18:09,175
因此，如果您是MIT的Debian用户，您可以使用MIT的所有内容副本，
So if you're a Debian user at MIT, you can use the MIT copy of everything, 

258
00:18:09,175 --> 00:18:12,200
然后通过我们快速的本地网络访问，
and then you can kind of access it over our fast local network, 

259
00:18:12,200 --> 00:18:15,250
这样流量根本不需要通过外部互联网，
and that traffic never needs to go to the outside Internet at all, 

260
00:18:15,250 --> 00:18:16,475
所以非常快速。
so it's very fast. 

261
00:18:16,475 --> 00:18:18,225
这是个好问题。
That's a good question. 

262
00:18:18,225 --> 00:18:21,675
还有其他问题吗？好的，
Any other questions? Okay, 

263
00:18:21,675 --> 00:18:24,600
最后一个有趣的哈希函数应用是
and then one final kind of interesting application of hash functions

264
00:18:24,600 --> 00:18:26,525
一种称为承诺方案的东西。
 is something called a commitment scheme. 

265
00:18:26,525 --> 00:18:29,125
我想玩一个游戏，
So I want to play a game, 

266
00:18:29,125 --> 00:18:30,325
我需要一个志愿者。
and I need a volunteer for this. 

267
00:18:30,325 --> 00:18:33,635
所以你实际上不需要从座位上站起来什么的，我只需要你跟我交流一下。
So you don't actually need to get up from your seat or anything, I just need you to talk with me. 

268
00:18:33,635 --> 00:18:39,825
有人愿意举手自愿吗？好的，你叫什么名字？Abdul Aziz？好的，太好了。
So any volunteers raise your hand? Yeah, okay, what's your name? Abdul Aziz? Okay, great. 

269
00:18:39,825 --> 00:18:44,833
所以，Abdul Aziz，我们要玩一个游戏，我要掷一枚硬币，
So Abdul Aziz, we're going to play a game where I'm going to flip a coin

270
00:18:44,833 --> 00:18:46,475
然后你要叫正面或反面，
 and then you're gonna call heads or tails, 

271
00:18:46,500 --> 00:18:48,350
如果你猜对了，你就赢了，
and if you call it right, you win, 

272
00:18:48,350 --> 00:18:49,900
如果你猜错了，你就输了。
and if you call it wrong, you lose. 

273
00:18:49,900 --> 00:18:52,425
这个游戏没有任何利益关系，
And there are no stakes for this game, 

274
00:18:52,425 --> 00:18:53,975
只是赢得荣誉。
but just the pride of winning. 

275
00:18:55,475 --> 00:18:59,300
不幸的是，我检查了一下我的钱包，只有美元，没有硬币。
Sadly, I checked my wallet and all I have is dollar bills, I don't have any coins with me. 

276
00:18:59,300 --> 00:19:01,600
所以，我只能在脑海中掷硬币。
So instead, I'm just going to flip the coin in my head. 

277
00:19:01,600 --> 00:19:02,450
好的，
Alright, 

278
00:19:02,450 --> 00:19:05,675
我掷硬币了，请你叫正面或反面。
so okay, I flip the coin, call heads or tails. 

279
00:19:05,675 --> 00:19:07,825
很抱歉，你输了，是正面。
Sorry, you lost, it was heads. 

280
00:19:11,025 --> 00:19:16,450
我可以作弊，对吧？我可以看到你说的并说相反的话。
I can cheat, right? I can just see what you say and say the opposite thing. 

281
00:19:16,450 --> 00:19:18,175
所以让我们试着修正一下这个游戏。
So let's try fixing this game. 

282
00:19:18,175 --> 00:19:25,500
如果我说翻转结果是正面或反面，你再猜，怎么样？好的，
How about you call heads or tails after I say what the flip result was? Okay, yeah, 

283
00:19:25,500 --> 00:19:27,080
如果我说“结果是反面”，
so if I say, "Oh, the result is tails," 

284
00:19:27,080 --> 00:19:31,100
你会怎么猜？你会选反面？是的。
What are you gonna say? Are you gonna call tails? Yeah. 

285
00:19:33,350 --> 00:19:36,975
那么，我们是否可以
So, is it possible to play this 

286
00:19:36,975 --> 00:19:43,700
在没有共享物理硬币的情况下公平地玩这个“猜硬币翻转结果”的游戏呢？
 "Guess what the coin flip result is" game in a fair way without having a physical coin that we share? 

287
00:19:43,700 --> 00:19:46,025
因为我无法真正操纵你的物理现实。
Like, because I can't really manipulate your physical reality. 

288
00:19:46,025 --> 00:19:48,825
如果我在你面前翻硬币，你可能会相信它是好的，对吧？
If I flip a coin in front of you, you probably trust that it's okay, right? 

289
00:19:48,825 --> 00:19:52,750
所以，事实证明，哈希函数通过一种称为承诺方案的思想
So, it turns out that hash functions give us a kind of cool way to solve this problem 

290
00:19:52,750 --> 00:19:55,750
为我们提供了一种解决这个问题的很酷的方法。
through an idea called a commitment scheme. 

291
00:19:55,825 --> 00:20:00,600
因此，我可以说：“这是解决方案的构造。”
So, I can say, "Here's the construction of the solution. 

292
00:20:00,625 --> 00:20:02,850
我可以选择正面或反面，
I can pick heads or tails, 

293
00:20:02,850 --> 00:20:09,425
实际上我要选择一个大的随机数，比如这个数，
and I'm actually going to pick a big random number, say like this number here, 

294
00:20:09,425 --> 00:20:15,775
我能做的是计算这个数字的 SHA-1 总和。
and what I can do is compute the SHA-1 sum of this number. 

295
00:20:15,775 --> 00:20:19,325
在这个时刻，你还没有看到这个数，我只是在脑海中做所有这些。
At this moment, you haven't seen this number yet, I'm just doing all this in my head. 

296
00:20:19,325 --> 00:20:23,200
然后，我告诉你：“好的，我翻了个硬币，
And then what I do is I tell you, "Okay, I flipped a coin, 

297
00:20:23,200 --> 00:20:27,800
我现在不会告诉你结果，因为你还没有猜正面或反面，
and I'm not going to tell you what the result is just yet because you haven't called heads or tails, 

298
00:20:27,800 --> 00:20:30,150
但我会告诉你结果的SHA-1摘要。
but I'll tell you what the SHA-1 sum of the result is. 

299
00:20:30,150 --> 00:20:32,100
就是这样，我给你这个值。
Here you go,and I tell you this value. 

300
00:20:32,100 --> 00:20:34,475
现在，在此之后，你可以猜正面或反面了。
Now, after this, you can call heads or tails. 

301
00:20:34,475 --> 00:20:37,625
所以，你选什么？选正面。
So, what do you say? Like, say heads afterwards. 

302
00:20:37,625 --> 00:20:41,025
那么，我可以向你揭示我的输入值，
What I can do is I can reveal to you what my input to this function was, 

303
00:20:41,025 --> 00:20:42,725
然后你可以进行交叉检查，
and then you can cross-check this, right? 

304
00:20:42,725 --> 00:20:47,750
对输入进行SHA-1摘要以验证输出是否与我之前所说的一样，
You can compute the SHA-1 sum on the input to verify that the output is what I said it was earlier, 

305
00:20:47,750 --> 00:20:50,875
然后我们可以找到一种将这些数字映射到正面或反面的方法。
and then we can have some way of mapping these numbers to heads or tails. 

306
00:20:50,875 --> 00:20:55,575
所以，我可能事先同意偶数为正面，奇数为反面，
So, I might have agreed upon beforehand that even numbers are heads and odd numbers are tails, 

307
00:20:55,575 --> 00:20:57,625
这是一种修正游戏的方法。
and so this is a way of fixing that game. 

308
00:20:57,625 --> 00:20:59,875
所以，我们实际上可以在我们的脑海中玩这个游戏。
So, we can actually play this game in our heads. 

309
00:21:00,475 --> 00:21:02,625
我可以选择一个值，
I can pick a value, 

310
00:21:02,625 --> 00:21:04,225
但不向你透露该值，
but not reveal that value to you, 

311
00:21:04,225 --> 00:21:05,850
但我可以承诺该值。
but I can commit to the value. 

312
00:21:05,850 --> 00:21:10,400
因此，这是一种绑定承诺方案，我在告诉你之后无法改变主意，
So, this is a kind of binding commitment scheme that I can't change my mind after I've told you this, 

313
00:21:10,400 --> 00:21:12,850
但不会向你透露原始值。
but it doesn't reveal the original value to you. 

314
00:21:13,350 --> 00:21:16,800
因此，这是加密哈希函数的另一个不错的应用。
And so, this is one other neat application of cryptographic hash functions. 

315
00:21:16,950 --> 00:21:23,100
对于这个特定的构造有任何问题吗？好的。
Any questions about this particular construction? Okay, great. 

316
00:21:23,125 --> 00:21:28,800
接下来，我们将讨论密钥派生函数，
So, moving on to the next topic, we're going to talk about key derivation functions. 

317
00:21:38,975 --> 00:21:41,800
通常缩写为KDF。
Often abbreviated as KDF. 

318
00:21:44,075 --> 00:21:48,049
这是一个与哈希函数非常相似的概念，
So, this is a concept that's very similar to hash functions,

319
00:21:48,049 --> 00:21:52,725
除了它有一个额外的特性，即计算速度较慢。
 except it has kind of one extra property that it is slow to compute. 

320
00:21:52,800 --> 00:22:07,715
举个例子，有一个被称为PBKDF2的哈希函数
For example, there's a hash function or key derivation function known as PBKDF2, 

321
00:22:07,715 --> 00:22:09,828
或密钥派生函数，
password-based key derivation function, 

322
00:22:09,828 --> 00:22:15,070
它具有与我们在这里谈论的这些哈希函数类似的形式，
that has a kind of similar form as these hash functions we were talking about here,

323
00:22:15,070 --> 00:22:18,078
它们接受某些可变长度的输入并生成固定长度的输出。
 that they take in some variable length input and produce a fixed length output. 

324
00:22:18,175 --> 00:22:20,450
但它们通常被用于一特定目的。
But they're meant to be used for one particular purpose. 

325
00:22:20,450 --> 00:22:26,025
这个目的通常是将固定长度的输出作为另一个密码算法中的密钥。
The purpose is generally to use the fixed length output as a key in another cryptographic algorithm. 

326
00:22:26,025 --> 00:22:30,650
我们稍后将讨论这些算法，比如使用这个函数的输出的用途。
And we'll talk about those algorithms, like what use the output of this thing for in a moment. 

327
00:22:30,650 --> 00:22:34,550
但这些东西的一个特性就是它们很慢。
But one property of these things is that they're slow. 

328
00:22:34,550 --> 00:22:39,550
有没有人知道为什么要让算法变慢？
Does anybody have any idea why you'd want an algorithm to be slow? Like, 

329
00:22:39,550 --> 00:22:41,825
通常我们希望算法很快，对吧？
normally we want algorithms to be fast, right? 

330
00:22:41,825 --> 00:22:43,750
那么为什么我们希望算法很慢呢？
So why would we want an algorithm to be slow? 

331
00:22:43,750 --> 00:22:56,550
是的，没错，就是这个原因。
Yes, yeah, that's exactly it. 

332
00:22:56,550 --> 00:22:59,150
我重复一遍，这样话就可以被录音了。
So, I'll repeat so it goes into the microphone.

333
00:22:59,150 --> 00:23:01,518
你希望它变慢的原因是
The reason you want these to be slow is 

334
00:23:01,518 --> 00:23:05,200
在实际使用它进行密码认证时。
when you're actually using it for something like password authentication. 

335
00:23:05,200 --> 00:23:07,460
你保存了密码的哈希值，
Where you have the hash of a password saved

336
00:23:07,460 --> 00:23:10,518
然后有人输入密码，你想知道它是否与哈希值相对应。
 and then somebody inputs the password, you want to know if that corresponds to the hash. 

337
00:23:10,518 --> 00:23:13,950
它慢一些也没关系，因为你只需要进行这个检查一次。
It's okay if it's slow because you're only doing this check kind of once. 

338
00:23:13,950 --> 00:23:16,650
但另一种使用这个函数的情况是
But the other scenario in which you're going to be using this function 

339
00:23:16,650 --> 00:23:19,100
当有人试图暴力破解密码时。
is when somebody's trying to brute-force a password. 

340
00:23:19,125 --> 00:23:21,898
比如一个网站的密码数据库被盗，
Say a website has their password database stolen 

341
00:23:21,898 --> 00:23:24,775
有人在尝试破解所有密码。
and somebody's going through all the accounts, trying to break all the passwords. 

342
00:23:24,775 --> 00:23:27,750
那么在这种情况下，你希望这个函数变慢，
Well, in that case, you want this to be slow

343
00:23:27,750 --> 00:23:30,025
因为有人将要做这个操作数百万次。
 because someone's gonna be doing this like millions and millions of times. 

344
00:23:30,025 --> 00:23:32,750
通过使这个函数变慢，你可以大大减缓攻击者的速度。
And you can slow down the attacker a lot by making this function slow. 

345
00:23:32,750 --> 00:23:36,850
所以，如果这需要一秒钟才能计算出这个函数，这也没关系。
And so it's fine if this takes you like one second upon logging in to compute this function. 

346
00:23:36,850 --> 00:23:38,235
但当你进行暴力破解时，
But when you're brute-forcing it,

347
00:23:38,235 --> 00:23:41,550
我们不会像那个 XKCD 漫画中一样每秒尝试一千次。
 we don't go to a thousand guesses a second like in that XKCD comic. 

348
00:23:41,550 --> 00:23:42,550
我们可以让它慢一点。
We can slow it down a little bit. 

349
00:23:44,650 --> 00:23:48,425
那么密钥派生函数的输出实际上用于什么呢？
So what is the output of key derivation functions actually used for? 

350
00:23:48,425 --> 00:23:50,907
好的，我们接下来要讨论的，
Well, the next topic we're going to talk about,

351
00:23:50,907 --> 00:23:54,225
可能是当你想到密码学时最经典的东西之一，
 probably like one of the most classic things when you think about cryptography,

352
00:23:54,225 --> 00:23:56,325
就是加密和解密。
 is encryption and decryption. 

353
00:23:58,325 --> 00:24:01,550
接下来的话题是对称密钥密码学。
The next topic is symmetric key cryptography. 

354
00:24:14,425 --> 00:24:19,900
就像这节课的其余部分一样，我们不会讨论如何实现它们，
And like the rest of this lecture, we're not going to talk about how you implement these. 

355
00:24:19,900 --> 00:24:24,975
而是会讨论对称密钥密码学的 API，就是它们如何被使用。
We're going to talk about the API for a symmetric key, symmetric key crypto, like how it's used. 

356
00:24:24,975 --> 00:24:29,300
对称密钥密码系统有几个不同的函数。
So symmetric key cryptosystems have a couple different functions. 

357
00:24:30,000 --> 00:24:32,300
它们有一个密钥生成函数，
They have a key generation function,

358
00:24:32,300 --> 00:24:37,825
这是一个随机函数，生成我们称之为密钥的东西。
 which is a randomized function that produces a thing we call the key. 

359
00:24:37,875 --> 00:24:41,575
然后它们有一对函数，加密和解密。
And then they have a pair of functions, encrypt and decrypt. 

360
00:24:46,200 --> 00:24:51,250
加密将我们所称的明文作为输入，
And encrypt take as input something we refer to as the plaintext, 

361
00:24:52,400 --> 00:24:54,925
这只是一些字节序列，一些数据。
and this is just some sequence of bytes,  some data.  

362
00:24:54,925 --> 00:24:56,950
它采用一个密钥，
And it takes in a key, 

363
00:24:56,950 --> 00:24:59,975
这是一个来自这个密钥生成函数的输出，
so something that came as an output of this key generation function, 

364
00:24:59,975 --> 00:25:06,300
然后产生我们所称的密文。
and produces what we call the ciphertext. 

365
00:25:06,300 --> 00:25:08,475
然后解密函数则是相反的过程。
And then decrypt does the opposite of this. 

366
00:25:08,475 --> 00:25:17,350
它需要密文和密钥，产生明文。
So it takes the ciphertext along with the key and produces the plaintext. 

367
00:25:21,400 --> 00:25:26,175
这个三个函数有几个属性。
And this triple of functions has a couple properties. 

368
00:25:26,175 --> 00:25:30,644
其中之一，就像你预期的一样，
One is that, like one team you might expect, is that 

369
00:25:30,644 --> 00:25:35,975
这个函数并没有告诉你加密输入的所有信息。
this thing doesn't really tell you all that much about this input to the encryption. 

370
00:25:35,975 --> 00:25:45,492
所以第一个属性是，
So property number one is given the ciphertext, 

371
00:25:45,492 --> 00:25:56,825
只有在拥有密钥的情况下，你才能通过密文找出明文。
you can't figure out the plaintext without the key. 

372
00:26:00,850 --> 00:26:04,600
另一个属性是一种显而易见的正确性属性，
And the other property is kind of the obvious correctness property, 

373
00:26:04,600 --> 00:26:13,350
即如果你使用密钥加密
that if you take something and you encrypt it, 

374
00:26:13,850 --> 00:26:16,100
某个消息M，
some message M with a key K, 

375
00:26:16,100 --> 00:26:20,100
然后使用相同的密钥解密该密文，
and then you decrypt that ciphertext using the same key, 

376
00:26:20,100 --> 00:26:23,200
那么你将得到相同的消息。
that gives you back the same message. 

377
00:26:25,025 --> 00:26:28,100
这是一种显而易见的正确性属性。
This is the kind of obvious correctness property. 

378
00:26:28,975 --> 00:26:30,800
这个描述听起来合理吗？
So, does this description make sense? 

379
00:26:30,800 --> 00:26:33,175
它是否符合你对于
Does it fit your kind of intuitive understanding of 

380
00:26:33,175 --> 00:26:35,406
将某些数据模糊化
taking some piece of data and obscuring it 

381
00:26:35,406 --> 00:26:38,350
以便你无法知道原始输入
so you can't really tell anything about the original input, 

382
00:26:38,350 --> 00:26:41,358
的直觉理解，
but then taking that obscured result 

383
00:26:41,358 --> 00:26:47,475
然后通过某个解密函数以该密钥来检索原始输入的理解呢？
and then passing it through some decryption function given that key to retrieve the original input?

384
00:26:48,925 --> 00:26:53,800
虽然这不是关于安全性的严格定义，
and this isn't really a rigorous definition of what it means for something to be secure, 

385
00:26:53,800 --> 00:26:58,025
但这是一个足够好的直观定义，我们可以使用它。
but it's a good enough intuitive definition that we can work with it. 

386
00:26:59,325 --> 00:27:04,300
那么，这个描述有没有问题？
So any questions about that description there?

387
00:27:05,800 --> 00:27:09,028
对于对称密钥密码学的应用场景在哪里呢？
So where can symmetric key cryptography be useful?

388
00:27:09,028 --> 00:27:11,200
我们将在这个讲座后面讲解许多例子，
 We'll talk about a whole bunch of examples later in this lecture, 

389
00:27:11,200 --> 00:27:13,084
但现在我们讲解一个例子，
but one example we'll talk about right now 

390
00:27:13,084 --> 00:27:17,050
即将文件加密以便存储在一个不受信任的云服务中。
is encrypting files for storage in an untrusted cloud service. 

391
00:27:17,075 --> 00:27:22,872
考虑像Dropbox或Google Drive这样的服务，
So consider something like Dropbox or Google Drive,or things like that 

392
00:27:22,872 --> 00:27:24,913
你上传文件
 where you're uploading files there 

393
00:27:24,913 --> 00:27:29,175
并信任服务不会查看你的文件或者对其进行任何恶意操作。
and trusting the service to not look at your files or do anything malicious with them. 

394
00:27:29,750 --> 00:27:34,950
这些服务至少在我列举的这些中并没有进行加密等操作。
These services, at least the ones I named, are not encrypted or anything like that. 

395
00:27:34,950 --> 00:27:38,475
理论上，这些公司的任何员工都可以查看你的文件。
In theory, any employee of those companies could look at your files. 

396
00:27:38,475 --> 00:27:41,862
当然，这些公司有许多政策和技术控制
Now, of course, these companies have lots of policies and technical controls in place

397
00:27:41,862 --> 00:27:44,000
来确保这种情况不会发生，
 for making sure that that sort of thing doesn't happen, 

398
00:27:44,000 --> 00:27:47,150
但这并不意味着它在技术上不可能发生。
but that doesn't mean that it's not technically possible. 

399
00:27:47,175 --> 00:27:49,424
如果你不想信任这些云服务，
So one thing you might want to do if you don't want to 

400
00:27:49,424 --> 00:27:51,950
不想让他们窥视你的数据，
trust these cloud services to not peek at your data, 

401
00:27:51,950 --> 00:27:53,680
（比如进行机器学习），
not do like machine learning over them, 

402
00:27:53,680 --> 00:27:55,920
或者进行其他你不想要的操作
or do other sorts of things that you wouldn't really want, 

403
00:27:55,920 --> 00:27:57,840
那么你可以在上传这些文件到网络服务之前
is you can just take your files 

404
00:27:57,840 --> 00:28:02,530
对其进行加密。
and encrypt them before uploading them to these web services. 

405
00:28:02,625 --> 00:28:05,725
那么这个想法有道理吗？我可以将我的文件
So does that idea make sense? That I can take my file, 

406
00:28:05,725 --> 00:28:09,747
（比如中心照片）通过一个加密函数，产生密文，
like center pictures or whatever, pass it through an encryption function and produce the ciphertext, 

407
00:28:09,747 --> 00:28:13,700
然后将该密文安全地放置在网络服务上进行备份等操作，
and then place that ciphertext on the web service safe for backup purposes or whatever, 

408
00:28:13,700 --> 00:28:19,025
如果我需要该文件，我可以检索该密文，然后使用我的密钥将其解密回明文，
and if I ever need that, I can retrieve the ciphertext, then use my key to decrypt it back into the plaintext, 

409
00:28:19,025 --> 00:28:21,650
然后将结果用于我需要做的任何操作。
and then use the result for doing whatever I need to do. 

410
00:28:21,650 --> 00:28:23,150
这个想法有道理吗？
Does that make sense?

411
00:28:23,225 --> 00:28:29,525
是的，这是一个好问题。
Yeah, that's a good question. 

412
00:28:29,525 --> 00:28:33,150
问题是，任何人都可以通过相同的加密程序进行加密吗？
The question is, couldn't anybody else run it through the same encryption program? 

413
00:28:33,150 --> 00:28:37,100
或许我应该更详细地解释一下
One detail maybe I should have explained in a little bit more detail is 

414
00:28:37,100 --> 00:28:41,275
这个密钥生成函数是随机的，
this key generation function is randomized, 

415
00:28:44,525 --> 00:28:47,250
并且这个密钥具有高熵值。
and this key has high entropy. 

416
00:28:47,250 --> 00:28:53,550
回到我们之前讨论的主题，比如我们可能会使用AES-256。
So going back to that topic we talked about earlier, like an example is we might have AES-256. 

417
00:28:54,675 --> 00:28:57,625
这是一种特定的对称密码，
This is one particular symmetric cipher, 

418
00:28:57,625 --> 00:29:02,775
它的名称可能暗示了它的密钥具有256位熵。
and this, as the name might indicate, has 256 bits of entropy in the key. 

419
00:29:02,775 --> 00:29:05,327
这意味着只要攻击者
And so that means that as long as the attacker, 

420
00:29:05,327 --> 00:29:09,231
（即从网络服务下载密文的人）不知道你的密钥，
whoever downloads the ciphertext from the web service, doesn't know your key, 

421
00:29:09,231 --> 00:29:13,900
除非他们有更好的攻击手段，否则他们将不得不尝试所有可能的密钥。
unless they have some better attack in place, they'll have to try all the different possible keys. 

422
00:29:13,900 --> 00:29:18,675
如果有2的256次方个密钥，那么在合理的时间内尝试所有密钥是不可能的。
And if there are 2 to the 256 keys, that's too many keys to try in a reasonable amount of time. 

423
00:29:18,675 --> 00:29:20,525
这回答了你的问题吗？
Does that answer the question?

424
00:29:20,525 --> 00:29:22,700
好的，还有其他问题吗？
Okay, any other questions?

425
00:29:35,550 --> 00:29:37,050
这是一个很好的问题，
That's an excellent question, 

426
00:29:37,050 --> 00:29:39,450
也引出了我接下来要谈论的话题。
and that leads into what I was going to talk about next. 

427
00:29:39,450 --> 00:29:40,250
所以感谢你的提问。
So thanks for that question. 

428
00:29:40,250 --> 00:29:45,025
正如你所指出的，如果我丢了我的密钥，我就有点卡住了，对吧？
As you point out, like if I lose my key, I'm kind of stuck, right? 

429
00:29:45,025 --> 00:29:45,985
我需要我的密钥来解密。
I need my key to decrypt. 

430
00:29:45,985 --> 00:29:47,300
这就是这个东西的重点。
That's kind of the point of this thing. 

431
00:29:47,300 --> 00:29:50,925
如果我不需要我的密钥来解密，那么这个加密系统就不会很好。
If I didn't need my key to decrypt, then this wouldn't be a very good cryptosystem. 

432
00:29:50,925 --> 00:29:54,319
所以我可以将这个对称密钥加密的想法
And so I can combine this idea of symmetric key cryptography 

433
00:29:54,319 --> 00:29:57,600
与我们刚才谈论的密钥派生函数相结合。
with the topic we just talked about, key derivation functions. 

434
00:29:57,600 --> 00:30:01,935
因此，我不再使用一些通过密钥生成函数随机生成的密钥，
So instead of having some key that's randomly generated with my key generation function, 

435
00:30:01,935 --> 00:30:04,303
例如从计算机中的某个位置获取熵，
say sampling entropy from somewhere on my machine, 

436
00:30:04,375 --> 00:30:14,050
而是使用一个口令，并将其通过我的密钥派生函数处理后
I can have a passphrase and pass it through my key derivation function box, 

437
00:30:14,400 --> 00:30:16,500
得到我的密钥。
and this gives me my key. 

438
00:30:16,500 --> 00:30:26,300
然后，我可以将我的明文和密钥结合在我的加密函数中，
Then, I can take my plaintext and combine it with my key in my encrypt function, 

439
00:30:28,475 --> 00:30:30,950
从而产生我的密文。
and this produces my ciphertext. 

440
00:30:33,925 --> 00:30:36,825
我将这个密文存储在网络服务上，
I store this ciphertext on the web service, 

441
00:30:36,825 --> 00:30:39,000
但现在我不需要保存这个密钥了。
but now I don't need to save this key. 

442
00:30:39,000 --> 00:30:41,450
相反，我只需要记住我的口令，
Instead, I can just remember my passphrase, 

443
00:30:41,450 --> 00:30:45,650
每当我需要我的密钥时，我就可以从密钥派生函数中重新构建它。
and whenever I need my key, I can reconstruct it from the key derivation function. 

444
00:30:45,725 --> 00:30:46,650
问题：是的，
Question: yeah, 

445
00:30:56,850 --> 00:30:58,575
这是一个好问题。
so that's a good question. 

446
00:30:58,575 --> 00:31:03,762
问题是，密钥派生函数是否足够慢，以防止暴力破解？
The question is, is the key derivation function slow enough to prevent brute-force guessing? 

447
00:31:03,762 --> 00:31:07,075
答案是，这取决于你的口令有多长。
The answer is, it depends on how long your passphrase is. 

448
00:31:07,075 --> 00:31:10,866
例如，如果你的口令像字符串“password”一样简单，
For example, if your passphrase is like the string 'password', 

449
00:31:10,866 --> 00:31:12,466
那么它很可能会很快被破解。
it is probably going to get broken very quickly. 

450
00:31:12,500 --> 00:31:15,825
但只要你的口令中有足够的熵，就足够了。
But as long as there's enough entropy in your passphrase, this is good enough. 

451
00:31:15,825 --> 00:31:19,400
所以，例如，如果我要上传一些文件到Dropbox，我真的希望它保持机密性，
So, like if I was uploading something to Dropbox and I really want it to stay secret, 

452
00:31:19,400 --> 00:31:21,400
那么一个64位口令，
I think a 64-bit passphrase, 

453
00:31:21,400 --> 00:31:26,550
真正具有64位熵的口令，在这种情况下将足够安全。
really a passphrase with 64 bits of entropy, it would be more than enough in that scenario, for example. 

454
00:31:27,275 --> 00:31:31,250
这里还有一个快速演示：有一些工具可以让这个过程变得非常容易。
And just a quick demo of this: so there are tools to make this really easy to do. 

455
00:31:31,250 --> 00:31:33,075
实际上，这是其中一个练习，
This is actually one of the exercises, 

456
00:31:33,075 --> 00:31:36,275
但我们可以使用一个名为OpenSSL的工具，
but we can take a tool, for example, called OpenSSL, 

457
00:31:36,275 --> 00:31:40,050
将对称密码应用于某个文件。
and use it to apply a symmetric cipher to some file. 

458
00:31:40,050 --> 00:31:42,725
例如，我有我的readme文本，readme.md。
So, I had my readme text here, for example, readme.md. 

459
00:31:42,725 --> 00:31:44,800
它里面有很多东西，
It has a bunch of stuff in it, 

460
00:31:44,800 --> 00:31:52,525
我可以做“openssl aes 256 cbc”，这是一个特定的对称密码的名称，
and I can do 'openssl aes 256 cbc', this is the name of a particular symmetric cipher, 

461
00:31:52,675 --> 00:31:57,696
然后我可以说我要将它应用于readme.md，
and I can say that I want to apply this to readme.md 

462
00:31:57,696 --> 00:32:02,475
并产生“readme.encrypted.md”，让我们给它起一个名字，
and produce 'readme.encrypted.md', let's give it some name, 

463
00:32:02,475 --> 00:32:03,925
然后它会要求你输入一个密码。
and then it's asking you for a password. 

464
00:32:03,925 --> 00:32:06,640
所以，默认情况下，它是在这种模式下工作的，我提供一个口令，
So, by default, this works in this mode where I provide a passphrase, 

465
00:32:06,640 --> 00:32:08,496
它经过KDF处理后生成一个密钥，
it's run through a KDF to produce a key, 

466
00:32:08,525 --> 00:32:09,875
然后用于加密。
and that's used for encryption. 

467
00:32:09,875 --> 00:32:12,750
所以，我会输入一些密码，再输入一遍，
So, I'll type in some password, type it in again, 

468
00:32:12,750 --> 00:32:15,625
然后现在我会生成这个readme.encrypted.md文件。
and now I produce this readme.encrypted.md file. 

469
00:32:15,625 --> 00:32:20,050
如果我查看这个文件，它看起来像垃圾一样，
If I look at this, it kind of looks like garbage, 

470
00:32:20,075 --> 00:32:22,750
但这正是对称加密的重点。
and that's, at a high level, the point of a symmetric cipher. 

471
00:32:22,750 --> 00:32:27,475
它产生了一些密文，应该与随机数据难以区分。
It produces some ciphertext that should be kind of indistinguishable from random data. 

472
00:32:28,050 --> 00:32:30,915
当我想要解密这个文件时，
And when I want to decrypt this, I can run 

473
00:32:30,915 --> 00:32:36,975
我可以运行类似的命令：“openssl aes 256 cbc -d”，表示解密，
a similar command: 'openssl aes 256 cbc -d', for decrypt,

474
00:32:36,975 --> 00:32:39,908
以readme.encrypted.md作为输入，
 take the input from readme.encrypted.md, 

475
00:32:39,950 --> 00:32:46,975
并将readme.decrypted.md作为输出。
and I like to do 'readme.decrypted.md' as the output. 

476
00:32:47,675 --> 00:32:50,825
我可以比较这两个文件，
And I can compare these two files, 

477
00:32:52,775 --> 00:32:58,325
对称加密的正确性属性告诉我这应该是相同的。
and the correctness property of symmetric cryptography tells me that this should be identical. 

478
00:32:58,325 --> 00:33:00,000
确实如此。
And this indeed is identical. 

479
00:33:00,000 --> 00:33:02,150
如果我查看返回值，比较返回值为0，
If I look at the return value, compare return 0, 

480
00:33:02,150 --> 00:33:03,850
这意味着它们是相同的文件。
so that means that are the same file. 

481
00:33:04,575 --> 00:33:12,750
所以，关于对称密钥密码学的问题，有什么问题吗？
 So, any questions about symmetric key cryptography? Yeah, 

482
00:33:19,775 --> 00:33:24,150
是的，这个特定的命令确实创建了一个新文件，
so the particular command did make a new file, 

483
00:33:24,150 --> 00:33:27,975
所以它将我们的输入readme.md并产生了这个文件作为输出，
so it took us input readme.md and produced output this file, 

484
00:33:27,975 --> 00:33:30,425
这就是该文件的加密版本。
so that is the encrypted version of the file.

485
00:33:30,425 --> 00:33:32,675
它并没有改变原始文件，
It left the original untouched, 

486
00:33:32,675 --> 00:33:35,275
但是我可以删除它，如果我想的话。
but then of course I could delete it if I wanted to. 

487
00:33:45,350 --> 00:33:47,269
是的，这是一个很好的问题。
Yeah, that's a good question. 

488
00:33:47,269 --> 00:33:49,425
这是我不会详细讨论的东西。
This is something I wasn't gonna talk about in too much detail. 

489
00:33:49,425 --> 00:33:52,625
问题是，我在这里提供了盐值参数，
The question is, I provided the salt argument here, 

490
00:33:52,625 --> 00:33:58,550
那么它存储在哪里？答案是，它存储在这里的输出中。
and where is that stored? So, the answer is that that is stored in this output here. 

491
00:33:58,750 --> 00:34:05,175
因此，此输出格式存储盐值和实际的输出密文，
So, this output format stores both the salt and the actual output ciphertext, 

492
00:34:05,175 --> 00:34:07,900
因此可以用于重构和解密。
so can be used in the reconstruction and decrypt. 

493
00:34:11,950 --> 00:34:12,900
是的，没错。
Yeah, that's correct. 

494
00:34:12,900 --> 00:34:14,975
它不保留任何数据库或其他东西。
It doesn't keep any database or anything. 

495
00:34:14,975 --> 00:34:16,525
它是完全自包含的。
This is fully self-contained. 

496
00:34:18,725 --> 00:34:19,405
是的，
Yeah, 

497
00:34:19,405 --> 00:34:22,025
正如John所说，盐并不是密码，
and as John says, the salt is not the secret, 

498
00:34:22,025 --> 00:34:26,375
密码短语才是这里的秘密。
like the passphrase is what is the secret thing here. 

499
00:34:27,750 --> 00:34:30,375
好的，
Okay, 

500
00:34:31,475 --> 00:34:34,075
让我们回到问题。
so let's go back to the question. 

501
00:34:34,075 --> 00:34:35,505
什么是盐？
What is salt? 

502
00:34:35,505 --> 00:34:38,975
在哈希函数的背景下，
The idea of a cryptographic salt 

503
00:34:38,975 --> 00:34:42,815
加密盐的概念可能最好解释。
is probably best explained in the context of hash functions. 

504
00:34:46,075 --> 00:34:50,400
哈希函数的一个常见应用是在密码数据库中存储密码。
So, one common application of hash functions is to store passwords in a password database. 

505
00:34:50,400 --> 00:34:55,500
如果我有一个网站，并且有用户的登录，像人们用他们的用户名和密码登录，
If I have a website and I have logins for users, like people log in with their username and password, 

506
00:34:55,575 --> 00:34:59,950
我实际上不想以纯文本形式存储人们的密码。
I don't actually want to store people's passwords in plain text just like as is. 

507
00:34:59,950 --> 00:35:07,350
有人知道我为什么不想这样做吗？是的，确切地说，
Does anybody know why I wouldn't want to do that? Yes, exactly. 

508
00:35:07,400 --> 00:35:09,425
如果出现违规行为，有人获取了您的所有数据，那会怎么样呢？
What if there was a breach and someone got all your data?

509
00:35:09,425 --> 00:35:12,561
所以，如果泄漏了所有用户的密码，那就真的很糟糕。
 So, it's really bad if you leak all your users' passwords. 

510
00:35:12,561 --> 00:35:16,175
特别是因为许多人在不同的网站上重复使用他们的密码。
It's especially bad because a lot of people reuse their passwords across different sites. 

511
00:35:16,175 --> 00:35:19,750
因此，您会看到攻击者侵入一个网站，例如，前段时间的雅虎泄漏事件，
So, you'll see attackers break into one thing, like there was big Yahoo breach a while ago, 

512
00:35:19,750 --> 00:35:21,925
他们发现了所有这些用户名和密码，
and they find all these usernames and passwords, 

513
00:35:21,925 --> 00:35:26,750
然后他们试图在Google、Facebook和YouTube等网站上使用这些相同的登录凭证。
and then they go and try those same login credentials on Google and on Facebook and on YouTube and whatnot. 

514
00:35:26,750 --> 00:35:28,400
这些人重复使用密码，
These people reuse passwords, 

515
00:35:28,775 --> 00:35:31,550
因此不要存储明文密码。
so it's bad to store plaintext passwords. 

516
00:35:31,550 --> 00:35:35,299
因此，您应该使用哈希函数
So, one thing you should do is you should store hashed passwords with a hash function, 

517
00:35:35,299 --> 00:35:39,775
或理想情况下是故意设计成缓慢的密码哈希函数来存储散列密码。
or ideally a password hashing function that's intentionally designed to be slow. 

518
00:35:39,775 --> 00:35:43,449
一旦攻击者意识到
But one thing attackers started doing 

519
00:35:43,449 --> 00:35:46,137
人们开始存储哈希密码之后，
once they realized that people started storing hashed passwords 

520
00:35:46,137 --> 00:35:48,725
攻击者开始做的一件事情就是构建所谓的“彩虹表”。
is they built these things called rainbow tables. 

521
00:35:48,725 --> 00:35:53,281
他们采用了一种生成大型密码列表的方法，
What people did was they took a way of generating big password lists,

522
00:35:53,281 --> 00:35:56,100
例如，这些密码的模式是什么样子的。
 like the kind of model what passwords might look like. 

523
00:35:56,100 --> 00:36:01,925
例如，获取所有字典单词，获取所有长度为零到八的字符串等等，
Say, take all the dictionary words, take all strings of like length from zero to eight and whatnot, 

524
00:36:01,925 --> 00:36:03,732
然后对它们进行哈希，
take all of those and then hash them 

525
00:36:03,732 --> 00:36:07,893
并生成一个将哈希映射回它们的原像的大型数据库。
and produce a big database mapping hashes back to their pre-image. 

526
00:36:07,893 --> 00:36:09,875
因此，给定一个哈希函数的输出，
And so given the output of a hash function, 

527
00:36:09,875 --> 00:36:12,325
而不必像即时所说的蛮力那样，
rather than have to like brute force said on the fly, 

528
00:36:12,325 --> 00:36:15,825
你可以去这个数据库中查找，'哦，对应于这个输出的输入是什么？
you can just go look up in this database, 'Oh, what is the input that corresponds to this output?' 

529
00:36:15,825 --> 00:36:19,500
人们已经为相当大的密码数据库构建了这些。
And people have built these for reasonably large password databases. 

530
00:36:19,675 --> 00:36:24,339
因此，作为防御，您可以做的一件事是，
And so one thing that you can do in reaction to that as a defense 

531
00:36:24,339 --> 00:36:27,411
不是存储在您的数据库中......
is rather than storing in your database... 

532
00:36:27,411 --> 00:36:33,400
您所做的不是仅存储密码的哈希值，
rather than storing just the hash of the password, 

533
00:36:33,400 --> 00:36:38,000
而是计算所谓的盐值。
what you do is you compute what's called a salt value. 

534
00:36:42,325 --> 00:36:45,000
这是一个大的随机字符串。
And what this is is a large random string. 

535
00:36:45,000 --> 00:36:50,025
然后，您将存储在密码数据库中的是盐，
And then what you do is you store in your password database the salt, 

536
00:36:50,025 --> 00:36:54,527
它不是真正的秘密，您可以将其与附加到其后的密码哈希值
which is not really a secret like you can store this in your password database

537
00:36:54,527 --> 00:37:02,875
一起存储在密码数据库中。
 along with a hash of the password with the salt appended to it. 

538
00:37:03,225 --> 00:37:05,175
这有什么用处呢？
Why is this useful?

539
00:37:05,175 --> 00:37:09,075
这种盐是每个用户的随机唯一值。
Well, this salt is a random unique value for every user. 

540
00:37:09,075 --> 00:37:13,300
因此，如果有人在一个网络服务上使用密码“safe password one two three”，
And so if someone has the password 'safe password one two three' on one web service, 

541
00:37:13,300 --> 00:37:15,991
如果您只存储密码的哈希值，
if you are just storing the hash of the password, 

542
00:37:15,991 --> 00:37:18,359
则哈希在两个网络服务上都是相同的，对吗？
then the hash would be the same on both Web Services, right?

543
00:37:18,359 --> 00:37:20,407
因为这个哈希函数是一个确定性函数。
 Because this hash function is a deterministic function. 

544
00:37:20,407 --> 00:37:23,671
但是，现在，由于我们使用了这个随机化的盐值，
But now, since we're using this randomized salt value, 

545
00:37:23,671 --> 00:37:27,511
我们存储了密码哈希值加上盐。
we store the hash of the password plus the salt. 

546
00:37:27,511 --> 00:37:30,711
因此，即使某些人在多个网站上使用相同的密码，
And so even if someone's using the same password on multiple sites, 

547
00:37:30,711 --> 00:37:33,975
这个东西在两种情况下看起来都不同。
this thing looks different in both cases. 

548
00:37:33,975 --> 00:37:38,583
它使这些大型数据库，将这些短密码
And it makes it so these big databases mapping these short passwords 

549
00:37:38,583 --> 00:37:42,551
或哈希输出映射回它们来自的短密码，
or hash outputs to the short passwords that they came from, 

550
00:37:42,551 --> 00:37:44,151
不再有用。
those are no longer useful. 

551
00:37:44,200 --> 00:37:45,975
当您拥有盐味密码时，
When you have salted passwords, 

552
00:37:45,975 --> 00:37:48,850
您需要为每个用户执行暴力攻击一次，
you kind of need to do the brute-force attack for every user 

553
00:37:48,850 --> 00:37:50,850
一旦找到他们的盐值，
once you find their salt value, 

554
00:37:50,850 --> 00:37:53,375
就不能再使用这个大型预先计算的数据库了。
rather than being able to use this big precomputed database. 

555
00:37:53,375 --> 00:37:57,340
这回答了什么是盐的问题吗？
Does that answer the question of what a salt is?

556
00:37:57,340 --> 00:38:01,300
那么，这个盐参数就是与之相关的。
 And so that's what that salt argument is related to. 

557
00:38:07,325 --> 00:38:11,175
看看，我们谈论过的任何问题吗？好的，
Let's see, any questions about anything we talked about so far? Great, okay, 

558
00:38:13,025 --> 00:38:17,319
那么我要抹去这个，
so the I'm gonna go ahead and erase this, 

559
00:38:17,319 --> 00:38:20,952
然后我们最后要谈论的是
and then the last topic we'll talk about is 

560
00:38:20,952 --> 00:38:23,350
密码学中最令人兴奋的发展之一。
one of the most exciting developments of cryptography. 

561
00:38:23,350 --> 00:38:24,400
它发生在相当长的时间以前，
Happen quite a while ago, 

562
00:38:24,425 --> 00:38:25,875
但仍然是一个非常酷的概念，
but it's still a really cool concept, 

563
00:38:25,875 --> 00:38:28,400
称为对称密钥密码学。
something called symmetric key cryptography. 

564
00:38:40,575 --> 00:38:44,423
这实际上是一种想法，使今天您使用的任何安全性
And so this is an idea that actually enables a lot of the security

565
00:38:44,423 --> 00:38:49,100
和隐私相关功能都成为可能，
 and privacy-related features of basically anything you use today. 

566
00:38:49,100 --> 00:38:52,059
例如，当您需要输入www.google.com时，
Like when you need to go and type in www.google.com

567
00:38:52,059 --> 00:38:55,500
密码学会作为其中的一部分。
 a cryptography is used as part of what goes on there. 

568
00:38:56,350 --> 00:39:00,573
这看起来与对称密钥密码学所讲的非常相似，
So this is going to look pretty similar to what we talked about in symmetric key cryptography,

569
00:39:00,573 --> 00:39:02,045
但有一个区别。
 except with a twist. 

570
00:39:04,225 --> 00:39:06,300
有一个密钥生成函数，
There's a key generation function,

571
00:39:06,300 --> 00:39:09,628
同样是随机的，但不是生成单个密钥，
 which similarly is randomized but instead of producing a single key, 

572
00:39:09,628 --> 00:39:12,444
而是生成一对密钥，
it produces a pair of keys, two different things, 

573
00:39:15,994 --> 00:39:19,461
其中一个被称为公钥，
one of which is referred to as a public key 

574
00:39:21,986 --> 00:39:26,450
另一个被称为私钥。
and the other is referred to as a private key. 

575
00:39:26,450 --> 00:39:29,073
然后可以使用它们进行加密和解密，
And then these can be used for encryption and decryption 

576
00:39:29,073 --> 00:39:31,825
方式与对称密钥密码学类似，
in a manner kind of similar to symmetric key crypto, 

577
00:39:31,825 --> 00:39:34,550
但这些不同的密钥现在具有不同的用途。
except these different keys have different uses now. 

578
00:39:34,575 --> 00:39:40,800
因此，我们有一个加密函数，它接受明文（我在这里写成P），
So we have an encryption function which takes in a plaintext, I'll write P here, 

579
00:39:40,800 --> 00:39:47,725
并且接受公钥，并产生密文。
and it takes in the public key and produces the ciphertext. 

580
00:39:47,725 --> 00:39:50,700
然后我有一个解密函数，
And then I have a decryption function 

581
00:39:50,700 --> 00:40:01,250
它接受我的密文和私钥，并将明文还原回来。
which takes in my ciphertext and the private key and gives me back my plaintext. 

582
00:40:02,450 --> 00:40:07,630
与前面所讲的两个属性类似，
And then similarly to those two properties we had over there,

583
00:40:07,630 --> 00:40:09,934
仅凭密文，
 given just the ciphertext,

584
00:40:09,934 --> 00:40:14,542
我们无法解密出明文，除非我们有私钥。
 we can't figure out the plaintext unless we have the private key. 

585
00:40:14,600 --> 00:40:19,375
然后，我们有一个明显的正确性属性，如果我们用公钥加密某些东西，
And then we have the obvious correctness property that if we encrypt something with the private key, 

586
00:40:19,375 --> 00:40:21,200
（纠正）
sorry, encrypt something with the public key, 

587
00:40:21,200 --> 00:40:24,150
然后拿着那个密文
and then take that ciphertext and try decrypting it 

588
00:40:24,150 --> 00:40:27,734
尝试用相应的私钥来解密，
with the corresponding private key that came from this key generation process, 

589
00:40:27,734 --> 00:40:29,949
输出两个不同的东西，
That outputs these two different things at once,

590
00:40:29,949 --> 00:40:32,884
那么最终我将得到相同的结果。
 then I get the same result back. 

591
00:40:35,050 --> 00:40:37,325
所以这非常类似于上面所说的，
So this is very similar to what's above, 

592
00:40:37,325 --> 00:40:40,950
但有一个扭曲的地方，我们有两个具有不同功能的不同密钥。
but there's a twist that we have these two different keys that have different functions. 

593
00:40:40,950 --> 00:40:46,000
这个公钥实际上可以被制作成公开的，这很棒，
It's really neat that this public key can actually be made, as the name indicates, public. 

594
00:40:46,000 --> 00:40:48,800
正如名称所示，任何人都可以在互联网上使用类似的加密系统，
Like I could be using a crypto system that works like this, 

595
00:40:48,800 --> 00:40:51,800
发布一个公钥供任何人查看，
post a public key on the internet for anybody to see, 

596
00:40:51,800 --> 00:40:53,425
但保持私钥的机密性。
but keep my private key secret. 

597
00:40:53,425 --> 00:40:56,536
然后我有了这个有趣的属性，
And then I have this interesting property that anybody on the internet 

598
00:40:56,536 --> 00:41:01,016
任何人都可以使用我的公钥加密任何内容
can take any piece of content and encrypt it for me using my public key, 

599
00:41:01,050 --> 00:41:02,875
并通过互联网将其发送给我。
and send it over the internet to me. 

600
00:41:02,875 --> 00:41:05,150
然后我可以使用我的私钥解密它，
And then I can decrypt it using my private key, 

601
00:41:05,150 --> 00:41:07,750
只要我的私钥保持机密，
and as long as my private key stays secret, 

602
00:41:07,750 --> 00:41:11,014
我的公钥对于任何人都可以使用是无关紧要的。
it doesn't matter if my public key is available to anybody on the internet.

603
00:41:11,025 --> 00:41:13,475
这就是不对称性的来源所在。
So here's where the asymmetry comes from. 

604
00:41:13,950 --> 00:41:18,800
之前，我们处于这样一种情况，假设我在互联网上，
Before, we were in a scenario where, suppose I was on the internet, 

605
00:41:18,800 --> 00:41:21,325
但你没有和我面对面交谈，
but you weren't like talking to me face-to-face, 

606
00:41:21,325 --> 00:41:24,450
你想通过一些未加密的频道
and you wanted to send me some data over the internet over some 

607
00:41:24,450 --> 00:41:27,425
将数据发送给我，
unencrypted channel where anybody could listen on what you were saying, 

608
00:41:27,425 --> 00:41:29,625
并且你想使用对称密钥加密。
and you wanted to use symmetric key cryptography. 

609
00:41:29,625 --> 00:41:32,500
我们需要一种方式事先交换密钥，
Well, we need some way of exchanging a key in advance 

610
00:41:32,500 --> 00:41:36,084
以便您可以使用密钥加密一些纯文本，并将那个密文传输给我，
so that you could encrypt some plaintext with a key and give me that ciphertext over the internet

611
00:41:36,084 --> 00:41:38,725
以便我可以使用该密钥解密它。
 so that I could decrypt it with that key.

612
00:41:38,725 --> 00:41:43,675
在对称密钥加密中，如果密钥是公开的，那么游戏就结束了，
In symmetric key crypto, if the keys public, it's game over, like anybody can decrypt your stuff. 

613
00:41:43,700 --> 00:41:46,000
任何人都可以解密你的东西。
Whereas in asymmetric key cryptography, 

614
00:41:46,000 --> 00:41:49,475
而在非对称密钥加密中，我可以拿出我的公钥并将其张贴在互联网上的公告板上，
I could take my public key and post it on a bulletin board on the internet, 

615
00:41:49,475 --> 00:41:53,025
您可以查看并使用一些内容来加密它们，
and you can go look at that, take some contents and encrypt them for me, 

616
00:41:53,025 --> 00:41:54,175
然后发送它们，
and then send them over, 

617
00:41:54,175 --> 00:41:55,800
这将是完全可以的，
and that would be totally fine. 

618
00:41:55,800 --> 00:41:58,125
您只能使用私钥来解密它。
You can only decrypt it with the private key.

619
00:41:58,125 --> 00:42:04,300
所以一个有用的比喻是将这些数学思想与物理锁进行比较。
So one analogy that may be helpful is comparing these mathematical ideas to physical locks. 

620
00:42:04,300 --> 00:42:07,625
你的房门可能有一个锁,
You probably have a lock on your door to your house, 

621
00:42:07,625 --> 00:42:09,960
你可以用钥匙将其旋转以锁门
and you can put in a key and like turn the thing

622
00:42:09,960 --> 00:42:12,968
或旋转另一个方向以解锁门。
 in order to lock the door or you can turn it the other way to unlock the door. 

623
00:42:12,975 --> 00:42:14,025
因此，有一把单一的钥匙，
So there's a single key, 

624
00:42:14,025 --> 00:42:16,100
它既可以锁门也可以解锁门。
and it can both lock and unlock the door. 

625
00:42:16,100 --> 00:42:18,121
但现在考虑这种替代构造，
But now consider this alternative construction,

626
00:42:18,121 --> 00:42:21,129
如果我想让你能够向我发送一条消息
 which you might use if, say, I want you to be able to send me a message 

627
00:42:21,129 --> 00:42:23,753
并通过互联网发送，
and have it be sent over the internet, 

628
00:42:23,753 --> 00:42:27,850
而且你和我之间不需要交换钥匙的方式。
and you and I don't really need a way to exchange a key with you beforehand.

629
00:42:27,850 --> 00:42:30,200
我可以买一个盒子，你可以把信放在里面，
I could get a box which you could put a letter inside, 

630
00:42:30,200 --> 00:42:31,550
然后你可以关上盒子。
and you can close the box. 

631
00:42:31,550 --> 00:42:33,400
我可以买一个锁眼，
And I can get one of the padlock things, 

632
00:42:33,400 --> 00:42:38,392
我可以打开锁眼并把它给你。
which I can give you by I could like take those padlock and open it and give it to you. 

633
00:42:38,392 --> 00:42:42,296
你可以在自己方便的时候把你的信息放在盒子里，
And you, at your own leisure, could put your message inside a box 

634
00:42:42,296 --> 00:42:44,500
然后拿起这个打开的锁眼，
and take this padlock, which is open, 

635
00:42:44,775 --> 00:42:48,050
把它固定在盒子周围，然后将其发送给我。
and shut it around the box and then send it over to me. 

636
00:42:48,050 --> 00:42:49,800
然后我可以用我的钥匙打开它。
And then I could put in my key and unlock it.

637
00:42:49,800 --> 00:42:53,362
所以你能看到这种不对称性，
So do you see how there is this asymmetry there as opposed to the 

638
00:42:53,362 --> 00:42:55,250
与我用来打开我家门的钥匙不同，
key that I used to open the door to my house, 

639
00:42:55,250 --> 00:42:57,250
同一把钥匙可以开关门。
where the same key opens and closes the thing? 

640
00:42:57,250 --> 00:43:01,775
相反，我给你这个打开的锁眼，你有能力关闭它但无法打开它。
Instead, I give you this open padlock that you have the ability to close but not open. 

641
00:43:01,775 --> 00:43:04,850
在你关闭它之后，我可以使用我保密的钥匙
And after you closed it, I can use my key, which I've kept secret, 

642
00:43:04,850 --> 00:43:07,175
来打开它并取出里面的东西。
in order to open the thing and retrieve what's inside. 

643
00:43:07,300 --> 00:43:09,450
也许这个比喻有帮助，也许没有。
Maybe this analogy is helpful, maybe it's not. 

644
00:43:09,450 --> 00:43:12,625
数学构造如果适合你，那么它就可以工作得很好。
The mathematical construction works just fine if that works for you.

645
00:43:12,625 --> 00:43:18,409
关于对称密钥加密和解密
So any questions about symmetric key encryption and decryption 

646
00:43:18,409 --> 00:43:22,925
以及它与对称密钥加密的关系有什么问题吗？
and how it relates to symmetric key crypto, how it's a little bit different?

647
00:43:24,250 --> 00:43:27,753
在我们讨论这个想法的应用之前，
So before we talk about applications of this idea, 

648
00:43:27,753 --> 00:43:33,900
我将谈论对称密钥密码学中的另一组概念。
I'm going to talk about one other set of concepts in symmetric key cryptography. 

649
00:43:33,900 --> 00:43:39,465
这些加密系统为您提供了另一组与加密和解密相关的工具，
These crypto systems give you another set of tools which are related to encryption and decryption, 

650
00:43:39,500 --> 00:43:41,650
称为签名和验证。
something called signing and verifying. 

651
00:43:41,650 --> 00:43:44,600
这在某种程度上类似于现实世界，
And this is kind of similar to the real world like I can 

652
00:43:44,600 --> 00:43:46,975
我可以得到一份文件并用我的签名签署它。
get a document and sign it with my signature. 

653
00:43:46,975 --> 00:43:50,550
除了现实世界的签名相对容易伪造外，
Except real-world signatures are, I don't think that hard to forge. 

654
00:43:50,550 --> 00:43:53,450
这些签名是相当难伪造的，因此更有用。
These are pretty hard to forge and, therefore, more useful. 

655
00:43:53,450 --> 00:43:57,522
签名方案是什么样子的？
What do signature schemes look like?

656
00:43:57,522 --> 00:44:05,050
有一个函数sign，它需要一些消息和私钥，
 There's a function sign that takes us some message and the private key, 

657
00:44:07,150 --> 00:44:10,100
注意这是私钥，而不是公钥，
so notice this, this is the private key, not the public key, 

658
00:44:10,100 --> 00:44:12,350
它会生成一个签名。
and it produces a signature. 

659
00:44:14,150 --> 00:44:23,625
然后还有另一个函数verify，它接收消息、签名
And then there's another function verify which takes in the message, the signature, 

660
00:44:23,750 --> 00:44:26,175
和这次是公钥，
and the public key this time, 

661
00:44:31,875 --> 00:44:36,450
它会返回一个布尔值，告诉我签名是否正确。
and it tells me it returns a boolean whether or not the signature checks out. 

662
00:44:36,450 --> 00:44:42,431
然后这一对函数具有以下性质，
And then this pair of functions has the property that, again, 

663
00:44:42,431 --> 00:44:50,075
这些性质是从物理签名直觉中产生的，
these are kind of properties that follow the intuition that come from physical signatures that, 

664
00:44:50,650 --> 00:44:55,167
即如果没有私钥，很难为任何消息产生一个签名，
without the private key, it's hard to produce a signature

665
00:44:55,167 --> 00:44:59,071
使得您可以将消息和签名
 for any message such that you can give the message in the signature 

666
00:44:59,071 --> 00:45:02,700
以及公钥提供给verify函数以使其返回true。
and the public key to the verify function to get it to return true. 

667
00:45:02,700 --> 00:45:06,200
在高层次上，它很难被伪造。
Like at a high level, it's hard to forge. 

668
00:45:09,800 --> 00:45:13,775
当然，没有私钥是很难伪造签名的。
It's hard to forge a signature, of course, without the private key. 

669
00:45:19,850 --> 00:45:22,705
然后有明显的正确性属性，
And then there's the obvious correctness property 

670
00:45:22,705 --> 00:45:27,697
如果您使用公钥签署了一个东西，然后尝试使用相应的私钥进行验证，
that if you signed a thing with a public key and then try verifying it with the corresponding, 

671
00:45:27,700 --> 00:45:29,536
不好意思，应该是用私钥签署了一个东西，
sorry, if you sign a thing with the private key 

672
00:45:29,536 --> 00:45:31,584
然后尝试使用相应的公钥进行验证，
and try to verify it with the corresponding public key, 

673
00:45:31,584 --> 00:45:35,025
它将返回一个好的验证结果。
it returns okay that this verification checks out. 

674
00:45:36,725 --> 00:45:44,550
因此，这是不对称密钥加密系统可以做的两种不同的事情。
So these are two different kinds of things you can do with asymmetric key cryptosystems. 

675
00:45:44,550 --> 00:45:47,732
您可能听说过，
An example of an asymmetric key cryptosystem that you might have heard of 

676
00:45:47,732 --> 00:45:49,375
有一个叫RSA的不对称密钥加密系统的例子。
is something called RSA. 

677
00:45:49,375 --> 00:45:53,675
RSA由许多人设计，其中一人是Ron Rivest，他是这里的教授。
So RSA is designed by a number of people, one of whom is Ron Rivest who's a professor here. 

678
00:45:57,550 --> 00:46:01,556
实际上有很多很有趣的不对称密钥加密应用，
So there are a couple of interesting applications of asymmetric key crypto, 

679
00:46:01,556 --> 00:46:04,692
您可能需要花上几天时间来谈论这些应用，
actually like tons and tons and tons of, you spend like days talking about this, 

680
00:46:04,692 --> 00:46:07,550
但其中一些例子是电子邮件加密。
but a couple examples are email encryption. 

681
00:46:07,550 --> 00:46:09,700
我们谈到了发送消息的一些事情。
So we talked a little bit about sending messages. 

682
00:46:09,700 --> 00:46:14,400
通过不对称密钥加密，您可以在网上发布公钥。
What we can do with asymmetric key crypto is that you can have public keys posted online. 

683
00:46:14,400 --> 00:46:18,125
我认为一些教练在他们的网站上发布了PGP公钥。
I think some of the instructors have PGP public keys on their website. 

684
00:46:18,125 --> 00:46:21,800
例如，如果您访问我的网站或John的网站，您将找到一个公钥。
So for example, you go to my website or John's website, you'll find a public key. 

685
00:46:21,800 --> 00:46:25,700
然后您可以发送给我们一个加密的电子邮件。
And then what you can do is you can send us an encrypted email. 

686
00:46:25,700 --> 00:46:30,775
即使该消息通过Gmail或其他电子邮件服务传递到我的T的邮件服务器，
And so even if that message goes through Gmail or whatever other mail service throughout my T's mail servers, 

687
00:46:30,775 --> 00:46:33,783
如果有攻击者窥探消息，
if there happens to be an attacker snooping on the messages,

688
00:46:33,783 --> 00:46:37,200
他们也无法理解其内容，因为它们都被加密了。
 they can't make any sense of their contents because they're all encrypted. 

689
00:46:37,200 --> 00:46:40,759
这真的很酷，因为你可以做到这一点，
And this is really cool because you can do this without kind of

690
00:46:40,759 --> 00:46:43,215
而无需亲自找到我们并交换密钥，
 finding us in person and exchanging keys, 

691
00:46:43,215 --> 00:46:45,431
你可能必须在对称密钥密码系统中这样做。
which you might have to do in a symmetric key cryptosystem. 

692
00:46:45,431 --> 00:46:49,200
你只要在网上找到我们的公钥，
You can just find our public key, which can be posted online without causing any issues, 

693
00:46:49,200 --> 00:46:51,425
然后发送加密邮件给我们。
and then send us encrypted email. 

694
00:46:51,425 --> 00:46:55,450
此外，非对称密钥加密还可以用于私人通信。
Another thing asymmetric key crypto is used for is private messaging.

695
00:46:55,450 --> 00:46:57,434
举手如果你使用过
So raise your hand if you've used anything like

696
00:46:57,434 --> 00:47:01,675
类似信号或电报或者WhatsApp的应用程序，
 signal or telegram or I think what's up is in theory antenna encrypted, 

697
00:47:01,675 --> 00:47:02,525
不错，很多人都用过了…
so a good number of you. 

698
00:47:03,150 --> 00:47:07,875
这些私人通信应用程序也使用
These private messaging applications also use asymmetric key crypto 

699
00:47:07,875 --> 00:47:10,600
非对称加密技术建立私人通信渠道。
to establish private communication channels. 

700
00:47:10,600 --> 00:47:14,700
基本上，每个人都与之相关联的都是一对密钥，
Basically, every person has associated with them a key pair, 

701
00:47:14,700 --> 00:47:17,475
因此你的设备已运行密钥生成功能
and so your device has run this key generation function 

702
00:47:17,475 --> 00:47:19,395
并生成了一个公钥和一个私钥，
produced a public key and a private key 

703
00:47:19,395 --> 00:47:22,250
自动将你的公钥发布到互联网上。
and automatically posted your public key to the internet. 

704
00:47:22,250 --> 00:47:25,700
例如，如果你使用信号，你的公钥就在信号服务器上，
So, for example, if you're using signal, your public key is on the signal servers, 

705
00:47:25,700 --> 00:47:27,725
当有人想要联系你时，
and then when someone wants to contact you,

706
00:47:27,725 --> 00:47:30,975
他们的手机可以查找你的公钥，检索它，
 their phone can look up your public key, retrieve it, 

707
00:47:30,975 --> 00:47:34,050
一旦检索到你的公钥，他们就可以为你加密信息。
and once it's retrieved your public key, they can encrypt information for you. 

708
00:47:34,050 --> 00:47:36,300
这是他们算法的一种近似方式，
This is a kind of approximation of how their algorithm works, 

709
00:47:36,300 --> 00:47:38,100
但从高层次来看，这就是正在发生的事情。
but at a high level that's what's going on.

710
00:47:38,550 --> 00:47:42,502
非对称密钥密码的另一个有趣应用是
Another neat application of asymmetric key crypto is 

711
00:47:42,502 --> 00:47:44,166
我们之前谈到的，
we were talking about earlier like 

712
00:47:44,166 --> 00:47:46,650
就是确保你从互联网上下载了正确的软件。
making sure you have the right software we downloaded from the internet. 

713
00:47:46,650 --> 00:47:50,125
非对称密钥密码可用于签署软件发布，
Asymmetric key crypto can be used to sign software releases, 

714
00:47:50,125 --> 00:47:52,486
这是一些人们为了确保
and this is something that people do for example 

715
00:47:52,486 --> 00:47:56,262
从互联网上下载的软件是来自正确的人所做的事情。
like Debian packages or whatever things you download from the internet. 

716
00:47:56,262 --> 00:47:59,475
开发人员会尝试签署他们的软件，以便你可以确保
The developer will try to sign their software so that you can make sure 

717
00:47:59,475 --> 00:48:01,107
从互联网上下载的任何东西
that whatever you've downloaded from the internet 

718
00:48:01,107 --> 00:48:03,750
都是来自正确的人所发出的。
is actually the right thing that came from the right person.

719
00:48:04,050 --> 00:48:08,100
我们在git的讲座中谈到了你可以使用git做的所有有趣的事情。
We talked about in the git lecture all the interesting things you can do with git. 

720
00:48:08,125 --> 00:48:12,875
我们没有涉及的是git中签名相关的功能。
One thing we didn't cover was signing related functionality and git. 

721
00:48:13,475 --> 00:48:16,400
所以git有提交，
So git has commits, 

722
00:48:16,400 --> 00:48:19,350
你可以将一些东西与提交关联起来，这被称为标签。
and you can associate with commits something called tags. 

723
00:48:19,350 --> 00:48:23,213
从高层次上看，你基本上可以将一个git提交与一个签名相关联，
At a high level, you can basically take a git commit and attach a signature to it

724
00:48:23,213 --> 00:48:27,400
将你的公钥绑定到此提交中，
 which binds your public key to this commit, 

725
00:48:27,400 --> 00:48:29,485
然后任何拥有你的公钥的人
and then anybody who has your public key

726
00:48:29,485 --> 00:48:31,981
都可以使用提交和你的公钥，
 can take the commit and your public key 

727
00:48:31,981 --> 00:48:36,325
所以请确保提交上有一个合法的签名。
and make sure that there's a legitimate signature on the commit.

728
00:48:39,500 --> 00:48:43,225
让我去我的一个随机存储库看一下。
So let me go to like some random repository that I have. 

729
00:48:43,925 --> 00:48:47,750
我可以查看与存储库相关联的一些标签。
I can look at a bunch of tags associated with the repository. 

730
00:48:47,750 --> 00:48:53,741
如果我查看与该标签相关联的原始数据，
If I do look at the raw data associated with this tag, 

731
00:48:53,741 --> 00:49:02,150
它具有一些元数据，然后是一段ascii编码的信息块，
it has some metadata and then a blob of like ascii encoded information 

732
00:49:02,200 --> 00:49:06,733
我可以使用“git tag -v4 verify”命令，
that I can use the get tagged - v4 verify command 

733
00:49:06,733 --> 00:49:11,469
以确保哦，这是一个好的签名来自这个人碰巧是我，
to make sure that oh this is a good signature from this person happens to be me 

734
00:49:11,469 --> 00:49:14,733
所以我签署了软件发布，这样任何从互联网下载软件的人
so I sign the software release so that anybody who downloads it from the Internet 

735
00:49:14,733 --> 00:49:17,650
都可以确保他们实际上得到了真实的副本。
can make sure that they actually got an authentic copy.

736
00:49:17,650 --> 00:49:19,150
是的，问题。
Yes, question. 

737
00:49:28,550 --> 00:49:31,125
所以问题是
So the question is 

738
00:49:31,125 --> 00:49:35,025
验证函数具体是在做什么或者它检查什么？
what exactly is the verify function doing or what is it checking against? 

739
00:49:37,025 --> 00:49:42,375
如果你想数学上了解具体是什么，可以在本讲座之后找我交流。
If you want to know mathematically what's going on, talk to me after this lecture. 

740
00:49:42,375 --> 00:49:45,840
从 API 的角度来看，
But from kind of an API perspective, what's going on here

741
00:49:45,840 --> 00:49:50,400
这里的签名和消息只是一组字节数据。
 is that the signature and also the message here are just a blob of bytes, 

742
00:49:50,400 --> 00:49:53,520
这些数据的设计基本上是这样的：
and it happens to be the case that these things are designed 

743
00:49:53,520 --> 00:50:00,225
对于某个特定的公钥，比如我的公钥，
such that basically if you take for some particular public key, like if you take my public key, 

744
00:50:00,225 --> 00:50:04,144
如果你没有我的私钥，
It's impossible for you, without knowledge of my private key,

745
00:50:04,144 --> 00:50:09,600
就不可能找到第二个参数使函数返回 true。
 for any message to find a second argument to this function that makes it return true. 

746
00:50:09,600 --> 00:50:13,125
你可以将它类比为签署一份文件。
You can kind of compare it to signing a document. 

747
00:50:13,125 --> 00:50:15,075
就像你不知道如何伪造我的签名一样，
Like, you don't know how to forge my signature. 

748
00:50:15,075 --> 00:50:17,425
我可以在任何纸张上签名，
I can take any piece of paper and sign it, 

749
00:50:17,425 --> 00:50:20,208
然后任何知道我的签名样式的人，
and then anybody who knows what my signature looks like,

750
00:50:20,208 --> 00:50:23,050
可以查看我的文件，验证签名正确。
 I can show my document - you can be like, yeah, that checks out. 

751
00:50:23,050 --> 00:50:26,864
但没有私钥的人
But nobody without the private key can produce a signature 

752
00:50:26,864 --> 00:50:31,675
无法为任何特定消息产生一个使此函数返回 true 的签名。
that will make this function return true for any particular message. 

753
00:50:33,825 --> 00:50:38,450
有任何相关的问题吗？我是否需要以其他方式解释，或者这讲得通？
And any related questions started, you want me to explain any other way, or does that make sense? 

754
00:50:50,775 --> 00:50:53,483
那么对于软件签名或对称密钥加密中讨论的其他几种应用程序，
So, any questions about signing software or any of the other

755
00:50:53,483 --> 00:50:57,550
有什么问题吗？
 handful of applications talked about of asymmetric key crypto?

756
00:50:59,050 --> 00:51:04,575
好的，最后我想谈谈密钥分发。
Well, so one final thing I want to talk about, we're almost out of time, is key distribution. 

757
00:51:04,575 --> 00:51:08,150
这是非对称密钥加密的一个有趣的副作用。
This is a kind of interesting side effect of asymmetric key cryptography. 

758
00:51:08,150 --> 00:51:12,325
它可以实现许多有趣的功能，比如我可以在互联网上发布我的公钥，
It enables a bunch of interesting functionality like I can post my public key on the internet. 

759
00:51:12,325 --> 00:51:14,350
你可以找到它并给我发加密邮件。
You can go find it and send me encrypted email. 

760
00:51:14,350 --> 00:51:17,637
但你怎么知道找到的公钥实际上是我的公钥？
But how do you know that the public key found is actually my public key? 

761
00:51:17,637 --> 00:51:20,625
这似乎存在一个引导问题，对吗？
It seems like there's a bootstrapping problem here, right? 

762
00:51:20,625 --> 00:51:26,085
所以，有一对，这就像一个非常有趣且非常困难的现实世界问题，
So, there are a couple, this is like a really interesting and really hard real-world problem, 

763
00:51:26,085 --> 00:51:30,350
你可能会采取几种不同的方法来解决这个问题。
and there are a couple different approaches you might take to this problem.

764
00:51:30,350 --> 00:51:32,861
一种是有点糟糕的解决方案，
One is kind of a lame solution, 

765
00:51:32,861 --> 00:51:35,300
但它可以解决许多密码学问题。
but this thing solves a lot of cryptography problems. 

766
00:51:35,300 --> 00:51:37,475
这种方法是在带外交换信息，
This exchange the information out-of-band. 

767
00:51:37,475 --> 00:51:40,625
也就是你想给我发加密邮件，
What that means is, you want to send me encrypted email, 

768
00:51:40,625 --> 00:51:42,250
我们在下课后就直接谈，
we'll just talk to me after class. 

769
00:51:42,250 --> 00:51:44,575
我会给你一张纸条上面写着我的公钥，
I'll give you my public key on a piece of paper, 

770
00:51:44,575 --> 00:51:47,967
由于你亲自与我交谈，你知道这确实是我的公钥，
and since you were talking to me in person, you know that it's actually my public key,

771
00:51:47,967 --> 00:51:51,295
而不仅仅是有人黑进我的网站，放上一些随机数。
 not just somebody like hacked my website and stuck some random number on there. 

772
00:51:51,350 --> 00:51:52,700
这样可以解决问题，
That solves the problem, 

773
00:51:52,700 --> 00:51:53,850
但不太优雅。
but it's not the most elegant.

774
00:51:53,850 --> 00:51:56,425
还有几种不同的方法，不同的应用程序使用不同的方法。
There are a couple other approaches that different applications use. 

775
00:51:56,425 --> 00:51:58,300
所以，使用 Signal 的人们，
So, those of you who use signal,

776
00:51:58,300 --> 00:52:01,884
你们有没有遇到过"安全号码"这个短语？
 have you ever encountered the phrase "safety number" 

777
00:52:01,884 --> 00:52:04,060
或是“与某某验证您的安全码”？
like "verify your safety number with so and so"? 

778
00:52:04,060 --> 00:52:08,653
对于 Signal，他们有一种交换公钥的方法，
So, with signal, they have a way of exchanging public keys 

779
00:52:08,653 --> 00:52:10,300
就是通过 Signal 服务器。
which is through the signal servers. 

780
00:52:10,300 --> 00:52:13,376
运行 Signal 服务的人只需在其服务器上
Whoever runs the signal service just maintains on their servers 

781
00:52:13,376 --> 00:52:15,800
维护一个从电话号码到公钥的映射。
basically a mapping from phone numbers to public keys. 

782
00:52:15,800 --> 00:52:18,300
当我说"我要给这个号码的人发消息"时，
And when I say, "Oh, I want to message this person with this number", 

783
00:52:18,300 --> 00:52:20,800
我的手机会从互联网上检索他们的公钥，
my phone just goes and retrieves their public key from the internet 

784
00:52:20,800 --> 00:52:23,075
然后为该公钥加密消息。
and then encrypts the message for that public key.

785
00:52:23,125 --> 00:52:30,925
现在，有人看到这个设置有什么问题吗？是的，正是如此。
Now, does anybody see a problem with the setup? Yeah, exactly. 

786
00:52:34,950 --> 00:52:37,875
Signal 服务器是一个故障点，
The signal servers are the point of failure there 

787
00:52:37,875 --> 00:52:41,175
因为如果 Signal 服务器给我错误的公钥，
because if the signal servers give me the wrong public key, 

788
00:52:41,175 --> 00:52:44,915
比如假设 Signal 只是生成了一对新的密钥并给我他们的公钥，
like suppose signal just produces a new key pair and give me their public key,

789
00:52:44,915 --> 00:52:46,451
现在他们可以读取我所有的消息，
 now they can read all my messages. 

790
00:52:46,451 --> 00:52:50,547
他们甚至可以坐在我和我的朋友之间，透明地解密我发送给他们的消息，
And they could even sit in between and transparently decrypt the messages I send them 

791
00:52:50,547 --> 00:52:53,225
然后重新加密并发送到最终目的地。
and then re-encrypt them and send them on to their final destination. 

792
00:52:53,225 --> 00:52:57,500
基本上，我需要某种方法来验证我获得的公钥，
Like, basically, I need some way of authenticating the public key I get.

793
00:52:57,500 --> 00:53:03,850
因此，信号有一个解决方案，也是将问题推给线下密钥交换的方法。
And so, signal has one solution to this, which is also just kind of punting the issue to out-of-band key exchange. 

794
00:53:03,850 --> 00:53:04,650
你可以与某个人见面，
You can meet up with somebody, 

795
00:53:04,650 --> 00:53:08,600
他们有一个稍微简化的流程，可以在屏幕上显示QR码。
and they have a slightly streamlined flow where they show QR codes on the screen. 

796
00:53:08,600 --> 00:53:11,000
你拿一部手机拍下另一部手机屏幕的图片，反之亦然，
You take one phone and take a picture of the other phone screen,  and vice versa,  

797
00:53:11,000 --> 00:53:13,375
现在你已经在人面前交换了公钥。
and now you've exchanged public keys in person. 

798
00:53:13,375 --> 00:53:14,650
从那时起，
And from that point on,

799
00:53:14,650 --> 00:53:17,100
从那时起，您已经启动了加密的端到端通信。
You've bootstrap your encrypted end-to-end communication. 

800
00:53:17,725 --> 00:53:22,475
它还有一个问题或方法，即固定公钥。
It also has an issue of, or it also has an approach of, pinning a public key. 

801
00:53:22,475 --> 00:53:26,187
一旦你知道一个特定的电话号码有一个特定的公钥，
So once you know that a particular phone number has a particular public key, 

802
00:53:26,187 --> 00:53:27,275
你的手机就会记住它，
your phone remembers that, 

803
00:53:27,275 --> 00:53:29,750
如果发生更改，它就会向你发出警告。
and if that ever changes, it'll complain to you. 

804
00:53:30,175 --> 00:53:33,075
然后还有几个解决这个问题的方法。
And then there are a couple of other solutions to this problem. 

805
00:53:33,075 --> 00:53:35,975
PGP是一个曾经流行过的解决方案，
PGP, one popular solution used to be popular a while ago,

806
00:53:35,975 --> 00:53:37,550
它有一个信任网络的概念。
 has this idea of a web of trust. 

807
00:53:37,550 --> 00:53:39,475
就像，我信任我朋友信任的人。
So, like, I trust people who my friends trust. 

808
00:53:39,475 --> 00:53:41,607
所以如果约翰和我的教授进行了一次超出带宽的交流，
So if John has done an out-of-band exchange with, 

809
00:53:41,607 --> 00:53:44,975
那么我可以向我的教授发送电子邮件，
say, my professor, then I can probably email my professor because, 

810
00:53:44,975 --> 00:53:47,375
因为我知道约翰信任我的教授，我信任约翰。
like, I know that John trusts my professor and I trust John. 

811
00:53:47,375 --> 00:53:49,150
所以你可以通过这种方式建立信任链。
So you got this chain of trust through there. 

812
00:53:49,150 --> 00:53:50,550
这是一种有趣的方法。
That's one interesting approach. 

813
00:53:50,550 --> 00:53:52,625
还有另一种模型，叫做最近出现的一种工具叫做key base，
And then another model that's called pretty recently, 

814
00:53:52,625 --> 00:53:55,075
这是一个非常好的...
as something that a tool called key base uses,

815
00:53:55,075 --> 00:54:03,475
哎呀，有一个叫做keybase.io的网站，
 this is a really neat whoops, there's a website called keybase.io, 

816
00:54:03,475 --> 00:54:07,950
他们有一个非常有趣的解决方案，叫做社会证明。
and they have a really interesting solution to this bootstrapping problem, which is social proof. 

817
00:54:07,950 --> 00:54:11,875
比如说，你可能在Facebook和Twitter上有你的朋友，
So saying you probably have your friends on Facebook and on Twitter and whatnot, 

818
00:54:11,875 --> 00:54:14,807
对于攻击者来说
and it's probably pretty hard for an attacker 

819
00:54:14,807 --> 00:54:18,250
同时入侵你朋友的Facebook账号、Twitter账号以及Hacker News账号等等。
to break into your friend's Facebook account at the same time as their Twitter account, 

820
00:54:18,250 --> 00:54:20,500
是非常非常困难的
at the same time as their hacker news account,  and so on.  

821
00:54:20,500 --> 00:54:21,790
因此，有一种有趣的方式，
And so there's this interesting way

822
00:54:21,790 --> 00:54:25,310
将公钥绑定到一组社交身份上，
 of binding public keys to a set of social identities 

823
00:54:25,310 --> 00:54:27,297
一旦你信任了与你的朋友相对应的一些社会身份。
such that you can retrieve a public key

824
00:54:27,297 --> 00:54:31,800
就可以检索到公钥。
 once you trust some number of social identities corresponding to your friend. 

825
00:54:32,025 --> 00:54:36,300
如果你想要更详细地了解这些内容，我们在讲义中提供了链接。
We have links to these in the lecture notes if you want to see these things in more detail. 

826
00:54:36,300 --> 00:54:40,200
这就是我们的安全和密码学讲座，
So that's it for our security and cryptography lecture, 

827
00:54:40,200 --> 00:54:43,350
明天的讲座将涉及到一些
and tomorrow's lecture will be on a random collection of topics 

828
00:54:43,350 --> 00:54:45,050
你的教师们认为有趣的话题。
that your instructors find interesting. 

829
00:54:45,050 --> 00:54:48,025
希望明天在讲座上见到你们。
So hopefully, see you in lecture tomorrow. 

830
00:54:51,700 --> 00:54:54,850
如果有任何问题，我会在课后呆上几分钟。
I'll also be here for a couple of minutes after class if anybody has questions. 

831
00:55:05,825 --> 00:55:07,100
好的，
Yes, okay, 

832
00:55:07,100 --> 00:55:09,600
约翰，如果你要离开，随意离开，
so John, feel free to leave if you have to leave, 

833
00:55:09,600 --> 00:55:11,050
但我想没有人在我们之后使用这个教室。
but I think nobody's using the classroom after us. 

834
00:55:11,050 --> 00:55:13,475
我要谈论另一个有趣的话题。
I'm going to talk about one other interesting topic. 

835
00:55:13,475 --> 00:55:18,368
约翰提出了非对称密钥加密速度慢，
So John brought up the fact that asymmetric key cryptography is slow

836
00:55:18,368 --> 00:55:20,875
对称密钥加密速度快的事实。
 and symmetric key cryptography is fast. 

837
00:55:20,875 --> 00:55:27,200
因此，在实践中，你不会仅仅使用对称密钥加密。
And so in practice, you don't really use just a symmetric key cryptography by itself. 

838
00:55:27,200 --> 00:55:33,575
通常情况下，它用于引导你正在使用的更复杂的协议。
It's usually used to bootstrap a more sophisticated protocol that you're using. 

839
00:55:37,575 --> 00:55:39,100
你可能想
One thing you might want to do is 

840
00:55:39,100 --> 00:55:41,596
使用对称密钥加密
use symmetric key cryptography

841
00:55:41,596 --> 00:55:43,400
来签名加密邮件，对吧？
 for signing encrypted email, right?

842
00:55:43,400 --> 00:55:45,075
我们已经讲过了这个例子。
 We talked about that example. 

843
00:55:45,075 --> 00:55:46,600
实际上的工作原理
And the way that works 

844
00:55:46,600 --> 00:55:51,144
并不像我们对非对称密钥加密的简单解释所猜测的那样。
isn't what you might have guessed from our straightforward explanation of asymmetric key crypto. 

845
00:55:51,144 --> 00:55:54,550
你不能只是使用上面的加密函数就结束了。
Like, you don't just use that encrypt function up there and call it a day. 

846
00:55:54,550 --> 00:55:56,617
在实践中，
In practice, what you do is 

847
00:55:56,617 --> 00:55:58,985
你所要做的是使用混合加密技术，
you use hybrid encryption

848
00:55:58,985 --> 00:56:08,850
结合对称密钥和非对称密钥加密。
 to use a combination of symmetric key and asymmetric key cryptography. 

849
00:56:08,975 --> 00:56:13,175
这里，我会画一个大的块状图。
What you do is, here, I'll draw this as a big block diagram. 

850
00:56:13,175 --> 00:56:14,925
你需要先取出你要发送的信息M，
You take your message M, 

851
00:56:14,925 --> 00:56:22,375
然后使用我所拥有的公钥进行加密。
and then I have my public key that I want to encrypt for. 

852
00:56:22,375 --> 00:56:23,579
但是，
But rather than just 

853
00:56:23,579 --> 00:56:26,840
与其将这两个信息直接通过上述加密函数加密，
take these two things and pass it through the encryption up there, 

854
00:56:26,840 --> 00:56:39,575
实际上，你需要使用对称密钥生成函数来产生一个对称密钥。
what I do is I use the symmetric key gen function to produce a symmetric key. 

855
00:56:41,125 --> 00:56:43,775
好的，我会在开头加上“对称”这个词，
Okay, I'm gonna, like, prepend this with "symmetric"

856
00:56:43,775 --> 00:56:47,065
以便我们可以将其与公钥密钥生成函数区分开来。
 so we can distinguish it from the public key key generation function. 

857
00:56:47,425 --> 00:56:50,367
然后我将这两个东西通过对称加密
And then what I do is I take these two things, 

858
00:56:50,367 --> 00:56:53,875
传递给我的加密盒子。
pass them through my symmetric encryption box. 

859
00:57:02,325 --> 00:57:05,275
这将产生密文，
This produces the ciphertext, 

860
00:57:08,325 --> 00:57:13,300
现在将其发送到接收者那里。
and now this by itself to the sender. 

861
00:57:13,300 --> 00:57:16,564
抱歉，这个加密后的内容
Sorry, this by itself to the receiver who has the private key 

862
00:57:16,564 --> 00:57:19,764
对接收者来说并没有什么用处，
corresponding to this public key here, this is not really useful, right? 

863
00:57:19,825 --> 00:57:23,924
因为它是使用本地计算机上运行的函数
Because this is encrypted with a symmetric cipher with this key K 

864
00:57:23,924 --> 00:57:29,450
产生的密钥K进行对称加密的。
that came from this function that I ran on my local machine. 

865
00:57:29,450 --> 00:57:34,100
因此，我需要某种方式将此传递给实际上用于解密邮件的人。
So I need some way of getting this to the person who actually used to decrypt the email. 

866
00:57:34,100 --> 00:57:38,975
因此，我将此内容拿出来，而且可能这个邮件很大，
And so what I do is I take this thing and now this email might have been big, 

867
00:57:38,975 --> 00:57:42,150
所以我使用对称加密将其加密。
and I use symmetric encryption with that because symmetric encryption is fast. 

868
00:57:42,150 --> 00:57:45,600
但是这个密钥很小，可能只有256位，
But this key is small, like it might be 256 bits or something, 

869
00:57:45,600 --> 00:57:50,975
所以我可以使用公钥进行对称加密，
so I can take this thing and encrypt it with a symmetric encryption using the public key, 

870
00:58:04,575 --> 00:58:07,675
这样就可以生成一个加密密钥。
and this gives me an encrypted key. 

871
00:58:07,825 --> 00:58:12,867
使用相应的私钥解密该密钥，
And this thing can be decrypted using the private key 

872
00:58:12,867 --> 00:58:16,625
就可以重构它。
corresponding to that public key to reconstruct this. 

873
00:58:16,850 --> 00:58:19,175
这是在发送者端进行的。
So this is on the sender's end. 

874
00:58:19,175 --> 00:58:24,195
现在，接收者获得这个密钥，将其倒序进行以下步骤：
Now, the receiver gets this and this and kind of does these things backwards. 

875
00:58:24,195 --> 00:58:25,566
因此，您从加密密钥开始，
So you start with the encrypted key

876
00:58:25,566 --> 00:58:30,430
并使用与发布的公钥对应的私钥
 and use asymmetric decryption using your public using your private key that

877
00:58:30,430 --> 00:58:32,432
使用非对称解密来重建
 corresponds to the posted public key

878
00:58:32,432 --> 00:58:36,175
用于对称加密框的此密钥，
 to reconstruct this key that were used for the symmetric encryption box, 

879
00:58:36,175 --> 00:58:40,368
然后使用重新构造的密钥使用对称密钥解密
and then use symmetric key decryption using that key that was reconstructed 

880
00:58:40,368 --> 00:58:44,675
来获取此密文并生成原始消息。
to take this ciphertext and produce the original message. 

881
00:58:44,775 --> 00:58:48,011
因此，这是对称和非对称密钥加密
So there's a kind of interesting example of how

882
00:58:48,011 --> 00:58:52,325
如何在实践中结合的有趣示例。
 in practice symmetric and asymmetric key cryptography is combined. 

883
00:58:54,500 --> 00:58:55,000
问题：
Question. 

884
00:59:00,475 --> 00:59:05,450
那么问题是，你会使用相同的对称密钥生成器吗？是的。
So the question is, will you be using the same symmetric key generators? Yes. 

885
00:59:07,300 --> 00:59:13,425
因此，您需要事先协商在此处使用哪个盒子。
Okay, so you need to kind of agree ahead of time which box you're using here. 

886
00:59:13,425 --> 00:59:19,475
例如，您可能会说，我将在这里使用AES 256 GC，
So you might be like, oh, I'm going to use AES 256 GC up here, 

887
00:59:19,475 --> 00:59:22,525
但这是一个众所周知的函数，
but this is a well-known function, 

888
00:59:22,525 --> 00:59:24,000
它是公开的。
and it's public. 

889
00:59:24,000 --> 00:59:26,975
攻击者可以知道此函数的所有参数。
Like the attackers allowed to know all the parameters this function. 

890
00:59:26,975 --> 00:59:31,050
这是攻击者不知道的唯一秘密。
This is the only secret thing that the attacker doesn't know, the key. 

891
00:59:31,775 --> 00:59:40,550
其他问题吗？是的，那是一个非常好的问题。
Any other questions? Yeah, that's a really good question. 

892
00:59:40,550 --> 00:59:42,790
什么样的数据值得加密？
What kind of data is important enough to encrypt?

893
00:59:42,790 --> 00:59:47,075
我认为这取决于您的威胁模型。
 And I think that depends on your threat model. 

894
00:59:47,075 --> 00:59:49,085
你关心什么样的攻击者？
Like, who, what kind of attackers are you concerned about?

895
00:59:49,085 --> 00:59:51,325
你想保护什么？
 What are you trying to protect against? 

896
00:59:51,325 --> 00:59:55,175
因此，您可能认为您根本不在意，
So you might have the stance that you just don't really care, 

897
00:59:55,175 --> 00:59:58,125
并且您与任何人的通信都可以公开。
and that like anything you communicate with anybody is allowed to be public. 

898
00:59:58,125 --> 01:00:03,925
我可能愿意将我与每个人的所有对话公开发布到互联网上供所有人查看。
I might be willing to post all my conversation with everybody for everybody to see publicly on the Internet. 

899
01:00:03,925 --> 01:00:06,805
另一方面，
On the other hand, maybe you're doing some 

900
01:00:06,805 --> 01:00:08,597
也许你正在从事一些类似安全敏感的工作，
like security-sensitive works here, 

901
01:00:08,597 --> 01:00:10,901
为美国政府签订合同，
working under a contract for the US government, 

902
01:00:10,901 --> 01:00:13,150
开发一些敏感军事项目。
developing some sensitive military stuff. 

903
01:00:13,150 --> 01:00:15,575
如果你在旅行中通过公共互联网发送这些信息，
If you're sending that through the open Internet while you're traveling, 

904
01:00:15,575 --> 01:00:18,069
你可能希望非常确定
you probably want to be pretty darn sure that no

905
01:00:18,069 --> 01:00:21,205
没有窃听者或其他人能够看到你发送的内容，
 eavesdroppers or anybody else along the way can see what you're sending, 

906
01:00:21,205 --> 01:00:23,575
并且你发送的信息确实到达了正确的位置，
and that whatever you're sending is in fact going to the right place, 

907
01:00:23,575 --> 01:00:27,325
并且接收方能够验证该信息确实来自你。
and that whoever is receiving it can authenticate that it in fact came from you. 

908
01:00:28,500 --> 01:00:32,469
因此，根据你的情况，你可能会担心各种不同类型的对手，
So you might be worried about all different kinds of adversaries depending on your scenario, 

909
01:00:32,469 --> 01:00:33,749
从试图使用随机脚本破解网站的毛头小子
from random script kiddies 

910
01:00:33,800 --> 01:00:37,425
到国家级攻击者，
who are trying to break into websites to nation-state level attackers, 

911
01:00:37,425 --> 01:00:42,075
你需要不同类型的技术来防御不同类别的攻击者。
and you'll need different types of techniques for defending against the different categories of attackers. 

912
01:00:44,625 --> 01:00:51,875
还有其他问题吗？好的，
Any other questions? Well, 

913
01:00:51,875 --> 01:00:58,400
希望明天能看到一些对于 John、Jose 和我感兴趣的随机的事物的集合。
so hopefully, see some of you tomorrow for a random collection of things that John, Jose,  and I find interesting. 

