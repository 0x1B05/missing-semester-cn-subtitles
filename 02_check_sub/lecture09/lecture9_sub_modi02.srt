1
00:00:01,275 --> 00:00:04,225
好的,那么,让我们开始今天的讲座吧.
Okay, so again, let's get started with today's lecture. 

2
00:00:04,225 --> 00:00:07,850
今天,我们将讨论安全和密码学,
So today, we're going to be talking about security and cryptography.

3
00:00:07,850 --> 00:00:13,325
今年的这节课与去年的略有不同.
And today's lecture is going to be a little bit different than our treatment of this topic in last year's class. 

4
00:00:13,325 --> 00:00:20,025
去年,我们更注重从计算机用户的角度讨论安全和隐私问题,
So last year, we focused a little bit more on security and privacy from the perspective of a user of a computer, 

5
00:00:20,025 --> 00:00:24,050
但今天我们将更多地关注安全和密码学的概念,
but today we're going to focus a little bit more on security and cryptography concepts 

6
00:00:24,050 --> 00:00:29,050
这些概念有利于理解我们在这门课上早些时候讨论的一些工具.
that are relevant in understanding some of the tools that we talked about earlier in this class. 

7
00:00:29,050 --> 00:00:35,050
例如,我们在Git讲座中讨论了哈希函数或加密哈希函数(如sha-1),
For example, we talked about hash functions or cryptographic hash functions like sha-1 in the Git lecture, 

8
00:00:35,050 --> 00:00:42,175
在命令行环境讲座中讲ssh时讨论了公钥.
or we talked about public keys when we talked about SSH in the command line environment lecture. 

9
00:00:42,175 --> 00:00:48,200
因此,今天我们将更详细地讨论这些密码学概念,
And so today, we'll talk about these different cryptographic primitives in more detail 

10
00:00:48,200 --> 00:00:51,500
了解它们的工作原理以及它们在这些工具中的应用.
and get an understanding of how they work and how they're used in these different tools that we're teaching in this class.

11
00:00:51,500 --> 00:00:56,650
这个讲座没法替代正规的安全课程,
This lecture is not a substitute for a more rigorous class in security. 

12
00:00:56,650 --> 00:01:02,250
麻省理工有很多非常好的课程,例如MIT 6.858,这门课就是关于计算机系统安全的,
So there are a bunch of really good classes at MIT like 6.858, which is on computer system security,

13
00:01:02,250 --> 00:01:07,825
或者MIT6.857和MIT6.875,这两门课更加专注于密码学.
or 6.857 and 6.875, which are more focused on cryptography. 

14
00:01:07,825 --> 00:01:13,650
因此,没有接受过正规的安全课程的培训前,不要从事安全工作.
So don't do security work without formal training in security from these classes or elsewhere. 

15
00:01:13,650 --> 00:01:17,225
除非你是专家,否则不要自己开发加密算法,
And unless you're an expert, don't roll your own crypto. 

16
00:01:17,225 --> 00:01:20,075
不要构建自己的加密实现或协议.
Don't build your own crypto implementations or protocols. 

17
00:01:20,075 --> 00:01:23,000
这个原则也同样适用于计算机系统安全.
And the same principle applies to computer system security. 

18
00:01:23,000 --> 00:01:28,150
这个讲座不是教你如何构建自己的东西,而是带你了解已经存在的东西.
This lecture is not about building your own stuff; it's about understanding what's already out there. 

19
00:01:28,150 --> 00:01:30,067
这节课将对密码学的基本概念进行非正式但实用的处理.
And so this lecture will have a very informal but we think practical treatment of these basic cryptography concepts, 

20
00:01:30,067 --> 00:01:33,650



21
00:01:33,700 --> 00:01:38,625
希望这节课能帮你理解之前课上讲的一些工具.
and yeah, hopefully, it'll help you understand some of the tools we talked about earlier in this class.

22
00:01:38,625 --> 00:01:43,400
有关今天规划有什么问题吗?太好了.
Any questions about the plan for today's lecture? Great. 

23
00:01:43,400 --> 00:01:46,875
那么今天的第一个话题是熵.
So the first topic for today is something called entropy. 

24
00:01:46,875 --> 00:01:48,775
熵是对随机性的一种度量,
Entropy is a measure of randomness, 

25
00:01:48,775 --> 00:01:53,000
这在确定密码强度时非常有用.
and this is useful, for example, when trying to determine the strength of a password. 

26
00:01:53,000 --> 00:01:56,000
让我们看看xkcd的这个漫画,
So let's take a look at this comic from xkcd. 

27
00:01:56,000 --> 00:01:58,000
我们很喜欢xkcd漫画.
We're a big fan of xkcd comics. 

28
00:01:58,000 --> 00:02:01,500
如果你以前看过这个漫画,请举手.
So this comic raises your hand if you've seen this before. 

29
00:02:01,500 --> 00:02:02,800
好的,有很多人都看过这个漫画.
Okay, a good number of you. 

30
00:02:02,800 --> 00:02:08,675
这幅漫画讲的是常要求用户设置密码的方式,
So this comic is complaining about this common pattern that's been taught to users of computers, 

31
00:02:08,675 --> 00:02:12,600
即当你设计密码时,
that when you design passwords, they should be things like 

32
00:02:12,600 --> 00:02:20,425
它们应该是像"t#0rU&b40rM$"或"p3@ch3$"这样的字符串,
"t#0rU&b40rM$" or "p3@ch3$" -- a string in the top left -- like we should design passwords 

33
00:02:20,425 --> 00:02:24,300
就像我们应该使用各种字符混合其他内容的密码,以使攻击者很难猜测.
that are full of funny characters and things like that to make it hard for attackers to guess. 

34
00:02:24,300 --> 00:02:28,400
然而,事实证明,像这样的密码实际上相当脆弱,
And yet, it turns out that passwords like that are actually pretty weak and guessable 

35
00:02:28,400 --> 00:02:31,950
容易被擅长暴力攻击的计算机破解.
by computers that can guess passwords really fast and brute-force attacks. 

36
00:02:31,975 --> 00:02:37,200
另一方面,像左下角的密码("correcthorsebatterystaple")
And on the other hand, passwords which maybe intuitively don't look as secure, 

37
00:02:37,200 --> 00:02:40,425
这样直觉上看起来不太安全的密码,
like the one on the bottom left, "correcthorsebatterystaple," 

38
00:02:40,425 --> 00:02:43,400
却被证明更安全.
that one turns out to be way more secure.

39
00:02:43,400 --> 00:02:48,425
那么我该如何量化这些不同密码的安全性呢?
So how do I actually quantify the security of these different passwords? 

40
00:02:48,425 --> 00:02:53,725
可以测算密码的随机性,即算出其中有多少比特的随机性.
It's by measuring the amount of randomness in the password, how many bits of randomness are in there. 

41
00:02:53,725 --> 00:02:57,350
因此,熵是以bit为单位进行度量的.
And so entropy is measured in bits.

42
00:02:57,350 --> 00:02:59,950
这里的bit和信息论中的bit是相同的.
This is like the same bits from information theory.

43
00:03:05,875 --> 00:03:08,250
我们只会讨论一种简单情况,
And we're only going to talk about the simple case 

44
00:03:08,250 --> 00:03:10,700
即只考虑从一组集合中随机选择,
where you're trying to measure the amount of randomness

45
00:03:10,700 --> 00:03:14,150
会有多少bit的随机性.
when you're choosing from a set of things uniformly at random.

46
00:03:14,150 --> 00:03:19,475
例如,当你想构建一个由四个随机单词组成的密码,
So for example, when you're constructing a password that's in the format of four random words, 

47
00:03:19,475 --> 00:03:25,325
你会考虑从某个字典中随机选择四个单词.
you're kind of considering all possible sequences of four random words made from some dictionary you have. 

48
00:03:25,325 --> 00:03:27,478
比如说你可能有一本十万个单词的字典,
You might have a dictionary with, say, a hundred thousand words

49
00:03:27,478 --> 00:03:30,450
你随机选择每个单词.
and you're selecting each word uniformly at random. 

50
00:03:30,450 --> 00:03:34,850
有多少种可能性?你可以算出来.
How many possibilities are there? Well, you can go and figure that out. 

51
00:03:34,850 --> 00:03:38,735
在这个例子中,一旦你知道有多少种可能性,
In that example, once you know how many possibilities there are, 

52
00:03:38,735 --> 00:03:41,750
熵就是以 2 为底对该可能性数量取对数.
the measure of entropy is log base 2 of the number of possibilities.  

53
00:03:46,375 --> 00:03:50,550
正如漫画所展示的那样,
And as that comic suggests, this is related to 

54
00:03:50,550 --> 00:03:54,450
这与攻击者暴力破解能力有关.
how long it'll take an attacker to try to brute-force through your different passwords. 

55
00:03:54,500 --> 00:03:58,875
如果有一千个可能性,那么攻击者可以每秒尝试一千个密码,
Like if you have a thousand possibilities, you're guessing passwords at a thousand passwords a second, 

56
00:03:58,875 --> 00:04:01,125
那这就不是一个很好的密码.
that's not a very good password. 

57
00:04:02,250 --> 00:04:05,500
这是几个简单的例子.
So this is a couple of quick examples. 

58
00:04:05,500 --> 00:04:08,625
抛硬币有两种可能性,
A coin flip has two possibilities, 

59
00:04:08,625 --> 00:04:10,175
假设我们有一个公平的硬币.
and let's assume we have a fair coin. 

60
00:04:10,175 --> 00:04:19,600
因此,抛硬币的熵是以2为底2的对数,就熵为1bit.
So a coin flip has log base 2 of 2, which is one bit of entropy. 

61
00:04:19,600 --> 00:04:23,150
还比如说掷骰子.
Another thing we might look at is something like a dice roll. 

62
00:04:24,200 --> 00:04:25,950
有六种可能性,
So there are six possibilities, 

63
00:04:25,950 --> 00:04:33,900
以2为底6的对数,大约是 2.6 bit的熵.
and log 2 of 6 is something like 2.6 bits of entropy. 

64
00:04:33,900 --> 00:04:37,850
这就是我们量化随机性的方法.
So that's how we quantify the amount of randomness in something.

65
00:04:39,200 --> 00:04:42,050
现在,回到xkcd漫画中的那个例子,
Now, going back to that example in the xkcd comic, 

66
00:04:42,050 --> 00:04:44,325
当我们要想算出密码的熵是多少,
when we want to figure out how much entropy is in a password, 

67
00:04:44,350 --> 00:04:47,950
我们必须知道密码是如何生成的.
we have to consider the model for how the password was generated. 

68
00:04:47,950 --> 00:04:52,850
例如,在左上角,你可以考虑,我们取一个单词字典,
For example, in the top left, you could consider, okay, we take one dictionary word, 

69
00:04:52,875 --> 00:04:55,550
在单词的某些字符中用相似的数字进行替换,
make some substitutions of some of the characters 

70
00:04:55,550 --> 00:05:00,225
再在末尾添加一个标点符号,
with numbers that look similar to that character, add one punctuation mark at the end, 

71
00:05:00,225 --> 00:05:01,727
然后再添加一个数字.
and add one numeral after that. 

72
00:05:01,727 --> 00:05:06,600
我们可以计算这样的密码有多少种可能性,
We can take that model and then use common rhetoric to figure out how many possibilities there are, 

73
00:05:06,600 --> 00:05:10,100
然后再计算熵.
and from that, we can derive how many bits of entropy are in that password. 

74
00:05:10,100 --> 00:05:14,000
在那个特定的例子中,我不知道他们到底用什么模型作为密码,
So in that particular example, I don't know exactly what model they were using for the password, 

75
00:05:14,000 --> 00:05:16,600
但他们计算出了28bits熵.
but they calculated their 28 bits of entropy. 

76
00:05:16,975 --> 00:05:20,950
而在左下角的示例中,"correcthorsebatterystaple"
Whereas in the bottom-left example, "correcthorsebatterystaple", 

77
00:05:21,000 --> 00:05:26,150
他们假设你生成密码使用的大约是 2,000 个单词的字典.
they assume that you're working from a dictionary of about 2,000 words. 

78
00:05:26,150 --> 00:05:30,650
所以把字典中的四个单词组合在一起的密码,大约有44位的熵.
And so when you combine four of those words together, you get about 44 bits of entropy from that. 

79
00:05:30,650 --> 00:05:33,150
因此,它比前面的那几个例子安全得多.
So it's much more secure than the example before it.

80
00:05:33,325 --> 00:05:38,550
关于我刚刚讲的这部分有什么问题吗?
So any questions about this definition of entropy or why it's useful?

81
00:05:42,500 --> 00:05:45,400
当你生成自己的密码时,请记住这一点.
And when you're generating your own passwords, keep this in mind. 

82
00:05:45,400 --> 00:05:47,075
你应该要一个高熵密码,
You want a high-entropy password, 

83
00:05:47,075 --> 00:05:50,550
具体熵要多高取决于你要保护的内容.
and the exact number you need depends on exactly what you're trying to protect against. 

84
00:05:50,550 --> 00:05:53,900
一般来说,在安全方面,你需要考虑你的威胁模型.
Like in general, a concept in securities, you have to keep in mind what your threat model is. 

85
00:05:53,900 --> 00:05:58,625
例如,你应该考虑你的攻击者是谁,他们可能使用什么样的攻击技术.
Like what attackers you're concerned about, what kinds of technique the attackers might be using. 

86
00:05:58,625 --> 00:06:03,150
例如,这个漫画提到了一个攻击者可以每秒猜测一千个密码.
For example, this comic refers to an attacker that can guess a thousand passwords a second. 

87
00:06:03,150 --> 00:06:06,799
这可能是一些网络服务上的情况,
This might be something that's possible for say, 

88
00:06:06,799 --> 00:06:10,975
攻击者会尝试使用你的电子邮件和随机密码来进行登录.
a web service that allows people to try to log in with your email and then random passwords that the attacker is trying. 

89
00:06:10,975 --> 00:06:13,100



90
00:06:13,100 --> 00:06:18,450
但这种每秒尝试一千次密码的模型可能并不适用于其他场景.
But this thousand passwords a second model might not be accurate for other scenarios. 

91
00:06:18,450 --> 00:06:21,174
例如,离线密码破解场景
For example, an offline password cracking scenario 

92
00:06:21,174 --> 00:06:25,050
或者攻击者已经破解了一个网站并下载了它们的数据库,
or maybe the attacker has broken into a website and downloaded their database 

93
00:06:25,150 --> 00:06:27,625
他们可能得到了你的密码的某种模糊形式,
and they have some obfuscated form of your password, 

94
00:06:27,625 --> 00:06:29,450
并且正在尝试找出正确的密码.
and they're trying to figure out what the password is. 

95
00:06:29,450 --> 00:06:33,000
也许他们可以并行攻击,让每秒猜测数达到一百万次.
Maybe they can parallelize this attack and make it go to a million guesses a second .

96
00:06:33,000 --> 00:06:36,675
所以你需要多少熵值,取决于你试图保护什么.
and so exactly how much entropy you need depends on exactly what you're trying to protect against. 

97
00:06:36,800 --> 00:06:40,750
不过要是密码已经受到了网站保护(这里的意思应该是本身网站会对密码有一些加密等保护措施),
But roughly forty bits of entropy might be good enough for, 

98
00:06:40,750 --> 00:06:45,575
那大约四十个比特的熵可能就够了.
which is protected by a website and you're concerned about online password guesses. 

99
00:06:45,600 --> 00:06:48,700
如果你担心离线攻击并且想要真正的安全,
And then maybe something like 80 bits of entropy might be good

100
00:06:48,700 --> 00:06:52,325
那么可能需要八十比特的熵.
if you're concerned about offline attacks and you want to be really, really secure. 

101
00:06:52,325 --> 00:06:54,425
刚刚讲的这些只是一个大致指南.
So they're rough guidelines you can use. 

102
00:06:58,450 --> 00:07:01,075
那么,如何生成强密码呢?
And then how do you actually generate strong passwords? 

103
00:07:01,075 --> 00:07:02,725
首先,你需要一些密码模型.
Well, you have some model for a password. 

104
00:07:02,725 --> 00:07:04,550
例如,常用的字典,
For example, the for dictionary works thing, 

105
00:07:04,550 --> 00:07:06,100
你可以得到一个字典.
and you can actually get a dictionary. 

106
00:07:06,100 --> 00:07:08,300
然后,你可以使用类似于掷骰子的方法.
And then you can use methods like dice, where, 

107
00:07:08,300 --> 00:07:13,125
在课程笔记中有一些链接,你可以获得一个仿真物理骰子并将其滚动,
so there's some we linked to in the lecture notes where you can actually get physical dice and roll them 

108
00:07:13,125 --> 00:07:17,275
然后你可以将掷骰结果映射到字典,最终将其转换为密码.
and then map dice rolls to dictionary words in order to eventually turn that into a password. 

109
00:07:17,325 --> 00:07:21,600
使用一些随机的物理标记,
And doing something like this, using some kind of physical token that you know is random,

110
00:07:21,600 --> 00:07:25,200
如平衡骰子或硬币,是一个好方法,
like a balanced die or a coin that you know is balanced, is a good thing to do.

111
00:07:25,200 --> 00:07:29,400
因为人类实际上并不擅长选择随机数字.
Because humans are actually not good at choosing random numbers, right? 

112
00:07:29,400 --> 00:07:31,850
如果我让你从1到100中随机选择一个数字,
If I just asked you to name a random number for 1 to 100,

113
00:07:31,850 --> 00:07:35,025
你很有可能不能均匀随机地进行选择.
chances are that you're probably not doing so uniformly at random very well. 

114
00:07:35,025 --> 00:07:38,975
这就是为啥我们要使用物理标记来进行随机.
And so that's why it's actually good to use these physical tokens in order to produce randomness. 

115
00:07:41,550 --> 00:07:44,000
熵是我们的第一个密码学概念.
So entropy, that's our first concept recovering 

116
00:07:44,000 --> 00:07:50,475
到现在为止有啥问题吗?好的.
Any questions about that or about this comic? Great. 

117
00:07:50,475 --> 00:07:54,250
那么进入有趣但稍微复杂的话题,
So getting into slightly more interesting and complicated topics,

118
00:07:54,250 --> 00:07:57,650
下一个我们要谈论的是哈希函数.
the next thing we're going to talk about is hash functions. 

119
00:07:57,650 --> 00:08:03,150
你们中的大多数人应该都参加了上一次关于Git的讲座吧,那次讲座就提到了Git使用了SHA-1哈希函数.
So hopefully, most of you were here during the get lecture where we talked about the SHA-1 hash function used in get. 

120
00:08:03,150 --> 00:08:06,475
现在我们要聊聊更多细节,
So now going into that topic in a little bit more detail,

121
00:08:11,500 --> 00:08:18,175
哈希函数能够将任意长度的输入数据压缩为固定长度的输出.
hash functions at a high level are functions that map a variable amount of data into a fixed size output. 

122
00:08:18,175 --> 00:08:23,700
例如,SHA-1哈希函数就是一个例子.
So for example, the SHA-1 hash function is one example of a hash function 

123
00:08:23,700 --> 00:08:33,375
SHA-1需要输入一些byte数据,但它会有恰好 160 bits输出.
that takes in some input of some number of bytes and outputs exactly 160 bits of output. 

124
00:08:33,825 --> 00:08:38,050
这就是SHA-1的一个特点.
So that's kind of the type signature of this particular hash function. 

125
00:08:38,050 --> 00:08:41,750
哈希函数具有一些有用的属性.
And then these functions have some number of properties that are useful. 

126
00:08:41,750 --> 00:08:49,350
总的来说,哈希函数可以被认为是输出一个随机数且难以逆推的函数.
So at a high level, these can be thought about as hard-to-invert functions that have random-looking outputs. 

127
00:08:49,350 --> 00:08:54,150
我们可以举些例子看看.
We can actually try this out on some random piece of data. 

128
00:08:54,150 --> 00:09:01,250
例如,如果我在我的终端中输入 `printf 'hello'`,
For example, if I enter into my terminal "printf 'hello'", this does exactly what you would expect it does, 

129
00:09:01,250 --> 00:09:02,750
他将输出"hello",
prints the set to standard out, 

130
00:09:02,750 --> 00:09:05,875
然后我可以将其传递给 "sha1sum" 命令.
and I can pipe this to the "sha1sum" command. 

131
00:09:05,875 --> 00:09:12,275
这是一个命令行程序,从标准输入接受输入,并计算SHA-1函数,
So this is a command-line program that accepts input via standard in and computes this SHA-1 function, 

132
00:09:12,275 --> 00:09:16,650
该函数从输入中获取不定长的数据并输出一个160bit的数据,
which takes in some variable number of bytes from the input and produces a 160-bit output,

133
00:09:16,650 --> 00:09:21,350
在这里它表示为十六进制字符串.
which in this particular case is represented or encoded as a hexadecimal string. 

134
00:09:21,350 --> 00:09:23,300
因此,它是一个长度为40的十六进制字符串,
So it's a length 40 hexadecimal string, 

135
00:09:23,300 --> 00:09:24,875
并且你可以看到此输出.
and you see this output right here. 

136
00:09:24,875 --> 00:09:29,050
"-"只是表示它从标准输入中获取了输入.
This "-" just means it took its input from standard in. 

137
00:09:29,050 --> 00:09:32,050
因此,此输出看起来像是一些随机数字,
So this output just looks like some random number, 

138
00:09:32,050 --> 00:09:35,700
但重要的是,这实际上是一个确定的数字.
but one important thing is that this is a deterministic number. 

139
00:09:35,700 --> 00:09:38,775
如果你在自己的设备上执行相同的命令,
If you try the same command on your own computer,

140
00:09:38,775 --> 00:09:41,575
"printf 'hello' | sha1sum",你将得到和这里相同的输出.
"printf 'hello' | sha1sum", you will get the same number out. 

141
00:09:41,600 --> 00:09:46,750
因此,SHA-1 是一个明星函数,人们在其所有参数上都达成了共识.
So SHA-1 is some well-known function that people have agreed upon for all its parameters. 

142
00:09:46,750 --> 00:09:53,075
只要略微调整输入,比如说将"hello"更改为"Hello",
we'll see that if we tweak the input a little bit, like say changed "hello" to "Hello" with a capital "H", 

143
00:09:53,075 --> 00:09:55,400
现在我得到了一个完全不同的输出.
now I get a completely different looking output. 

144
00:09:55,400 --> 00:09:58,875
即使它是确定的,它看起来像是一个随机数,
And this also looks like some other kind of random-ish number, even though it is deterministic, 

145
00:09:58,875 --> 00:10:01,625
并且你可以在自己的计算机上复现这个输出.
and you could reproduce this on your own computer.

146
00:10:06,200 --> 00:10:10,425
哈希函数具有许多重要属性.
Hash functions have a number of properties that are pretty important. 

147
00:10:15,750 --> 00:10:20,075
加密哈希函数具有的第一个属性是它们是不可逆的.
The first property that cryptographic hash functions have is that they're non-invertible. 

148
00:10:20,075 --> 00:10:23,075
这意味着,如果你知道此函数的输出,
And what that means is that if you take the output from this function,

149
00:10:23,075 --> 00:10:27,189
例如那个"aaf4...34d"的输出,
for example, that "aaf4...34d" string shown there

150
00:10:27,189 --> 00:10:33,475
单单从这个输出很难弄清楚输入是什么.
from that output, it's hard to figure out what the input was that produced that output. 

151
00:10:33,750 --> 00:10:37,700
因此,你可以很容易地计算出SHA-1哈希值,
So you can go one way, compute the SHA-1 hash easily, 

152
00:10:37,700 --> 00:10:39,300
但是你无法逆向操作.
but you can't go backwards.

153
00:10:39,300 --> 00:10:45,000
这些函数具有的另一个特性是它们具有抗碰撞性.
Another property that these functions have is that they're collision-resistant. 

154
00:10:49,625 --> 00:10:56,500
这个属性的意思是很难找到两个不同的输入产生相同的输出.
And what this property means is that it's hard to find two different inputs that produce the same output. 

155
00:10:56,875 --> 00:11:01,550
我大概讲了下什么是加密哈希函数.
So this basically describes what a cryptographic hash function is.

156
00:11:01,550 --> 00:11:10,300
你们有什么问题吗?
So any questions about the kind of specification of a cryptographic hash function?  

157
00:11:10,300 --> 00:11:12,825
那么,这些哈希函数实际上有什么用途呢?
Okay, so what are these hash functions actually useful for? 

158
00:11:12,825 --> 00:11:17,175
我们实际上已经在Git讲座中看到了一个应用,就是内容地址存储.
Well, we've already seen one application in Git for content address storage. 

159
00:11:17,175 --> 00:11:24,675
在Git中,我们希望统一命名object仓库中的对象,
So in Git, we want some uniform way of naming different objects that are in the object store, 

160
00:11:24,675 --> 00:11:28,200
而Git可以将它们全部命名为它们的SHA-1哈希.
and it turns out that Git addresses all of them by their SHA-1 hash.

161
00:11:28,200 --> 00:11:31,250
因此,你有存储好的数据,
So you have the actual data you want to store, 

162
00:11:31,250 --> 00:11:35,575
然后要为该数据命名,只需命名其为SHA-1哈希即可.
and then to name that particular piece of data, you just name the SHA-1 hash. 

163
00:11:35,575 --> 00:11:38,550
所有这些都存储在object仓库中.
And all of that is stored in the object store in that particular way. 

164
00:11:39,500 --> 00:11:42,675
我们在查看Git的仓库的时候可以看到.
We see this when looking at many different parts of Git. 

165
00:11:42,675 --> 00:11:44,650
例如,这里,我进入Git仓库.
For example, right here, I'm going to Git repository. 

166
00:11:44,650 --> 00:11:46,750
如果我执行"git log"',它会显示历史记录.
If I do "git log"', it shows me the commits. 

167
00:11:46,775 --> 00:11:52,875
例如,这个数字是这个提交的SHA-1值,
And for example, this number up here is the cryptographic hash function SHA-1 

168
00:11:52,875 --> 00:11:56,350
是这个提交的名字.
applied to the commit object that describes this particular commit.

169
00:11:57,400 --> 00:12:02,125
那么,有人知道为什么Git在这里使用加密哈希函数而不是......
So does anybody know why Git uses a cryptographic hash function here as opposed to... 

170
00:12:02,175 --> 00:12:06,225
你可能在其他课程,比如算法的入门课中听说过散列函数,
So you might have heard in your other computer science classes, like say your introductory algorithms class, 

171
00:12:06,225 --> 00:12:11,600
这个前面没有像"加密哈希函数"加上"密码"这个前缀.
there are things called hash functions without the word 'cryptographic' appended in front of them. 

172
00:12:11,600 --> 00:12:17,800
它们具有类似的属性,能够将可变长的输入压缩为某个固定大小的输出.
And they have similar properties that they turn a variable-sized input into some fixed-size output. 

173
00:12:17,800 --> 00:12:20,903
但是它们并没有完全具备
But they don't quite have these properties 

174
00:12:20,903 --> 00:12:25,100
比如说,难以找到产生特定输出的输入等属性.
where it's hard to find an input that produces a particular output or things like that. 

175
00:12:25,100 --> 00:12:27,225
这是一种比较弱的定义.
It's a kind of weaker definition than this.

176
00:12:27,225 --> 00:12:30,850
那么,为什么在 Git 中我们关心拥有一个加密哈希函数
So why is it that in Git we care about having a cryptographic hash function

177
00:12:30,850 --> 00:12:33,154
而不是一个普通的哈希函数?
as opposed to just a regular old hash function? 

178
00:12:33,154 --> 00:12:34,450
大家有什么想法吗?
Does anybody have any ideas?

179
00:12:45,650 --> 00:12:53,775
是的,基本上说对了,我们不希望这个哈希函数的输出产生冲突.
Yeah, that's basically it, that we don't want to have kind of conflicts in the output from this hash function. 

180
00:12:53,775 --> 00:12:58,725
就像每个提交都由一个哈希值标识,每个文件也该由该文件的哈希值标识.
Like every commit is identified by a hash function, every file is identified by the hash of that file. 

181
00:12:58,725 --> 00:13:03,900
如果有两个不同的内容产生了相同的输出,也就是说,
If it were ever the case that two different pieces of content in practice produce the same output, that is, 

182
00:13:03,900 --> 00:13:08,550
该函数不具有抗碰撞性,那么这可能会造成很大问题.
if the function were not collision-resistant, that could be really problematic, right?

183
00:13:08,550 --> 00:13:12,950
因为你和我可能会尝试获取我们认为是相同的仓库,
Because then you and I, we could have to do to get repos that we think are the same,

184
00:13:12,950 --> 00:13:14,850
我们检出相同的提交哈希,
we check out the same commit hash, 

185
00:13:14,850 --> 00:13:17,275
但是最终我们却可能会得到不同的文件.
and we might end up with different files. 

186
00:13:17,375 --> 00:13:22,975
这是绝对达咩的,因为Git是用于跟踪软件的开发,
And this is concerning because Git is used to track software, a track development of software, 

187
00:13:22,975 --> 00:13:28,150
同时它也要保证正确的人员在写代码,
and it's also kind of involved in making sure that the right people are authoring the software,

188
00:13:28,150 --> 00:13:29,950
过程中不能发生什么不妥之事.
nothing funny has happened in the process. 

189
00:13:29,950 --> 00:13:31,842
例如,有许多开源项目,
For example, there are all these open-source projects 

190
00:13:31,842 --> 00:13:35,075
如 Linux 内核,就使用 Git 进行进行跟踪.
like the Linux kernel where development is done using Git. 

191
00:13:35,100 --> 00:13:38,250
如果某个Git贡献者能够编辑某些文件
It would be really bad if some contributor to Git could say edit some file

192
00:13:38,250 --> 00:13:42,557
并提出一些看起来相当不错的优化请求,
and propose some change that looks pretty benign like, 

193
00:13:42,557 --> 00:13:46,900
比如"让我改进一下 Linux 的这个部分",提交该申请给 Linux 开发人员,
"Oh, let me go and improve this part of Linux", submit that change request to the Linux developers, 

194
00:13:46,900 --> 00:13:53,000
然后实际提供了一个具有相同提交哈希的 Git 仓库,
and then in practice actually supply a Git repository that has the same commit hash and whatnot, 

195
00:13:53,000 --> 00:13:55,400
而实际上文件内容是不同的.
but actually the file contents are different. 

196
00:13:55,400 --> 00:13:56,325
这种情况非常糟糕.
There's something malicious. 

197
00:13:56,325 --> 00:14:01,815
因此,Git 就需要依赖于这个 SHA-1 函数作为加密哈希函数,
So Git actually relies on this SHA-1 function being a cryptographic hash function

198
00:14:01,815 --> 00:14:04,700
以实现安全性.
in order to achieve security. 

199
00:14:05,300 --> 00:14:12,750
关于哈希函数的应用还有什么问题吗?
Any questions about that and some other interesting applications of hash functions?

200
00:14:12,750 --> 00:14:16,175
所以,就像我们看到的,哈希函数可以将很长的输入压缩为很短的输出,
So, as we saw, hash functions turn big inputs into small outputs, 

201
00:14:16,175 --> 00:14:19,350
而且由于哈希函数是抗碰撞的,
and in a way, because the hash function is collision-resistant, 

202
00:14:19,350 --> 00:14:23,100
输出可以用来验证或标识输入.
the output can be used to kind of attest to or identify the input. 

203
00:14:23,100 --> 00:14:28,050
因此,你可以将哈希看作文件的简短摘要.
And so you can think of a hash as a short summary of a file. 

204
00:14:28,225 --> 00:14:30,925
例如,在此目录中的一堆文件中,
For example, in this directory of a bunch of files,

205
00:14:30,925 --> 00:14:34,975
我可以计算该目录下的一些文件的 "sha1sum".
I can compute the "sha1sum" of some file in this directory. 

206
00:14:35,125 --> 00:14:39,900
这是"README.md" 的 SHA-1 哈希值.
And this is the SHA-1 algorithm applied to this "README.md" file. 

207
00:14:39,950 --> 00:14:44,068
有趣的是,要想计算出另一个具有相同哈希输出的文件
And what's interesting is that it is computationally hard or like impossible,

208
00:14:44,068 --> 00:14:47,375
是相当困难的,
you can kind of think of it as impossible, to find any other file, 

209
00:14:47,375 --> 00:14:50,875
你甚至可以认为是不可能的.
so a different file that has the same hash output. 

210
00:14:50,875 --> 00:14:56,150
这个对于验证在从互联网下载的文件非常有用.
And one scenario in which this is useful is when you download files from the internet. 

211
00:14:56,225 --> 00:15:03,250
例如,有许多 Linux 发行版会在其网站发布大型 CD 或 DVD 映像文件.
For example, there are lots of Linux distributions that distribute large CD or DVD images from their website. 

212
00:15:03,250 --> 00:15:06,775
像我可以到 Debian.org 上下载最新版本的 Debian.
Like, I can go to Debian.org and download the latest version of Debian. 

213
00:15:07,025 --> 00:15:10,125
问题是,在网站上托管这些文件非常昂贵.
The thing is that hosting those files can be expensive. 

214
00:15:10,125 --> 00:15:13,100
因此,许多好心人会提供这些文件的镜像.
And so a lot of people are nice enough to host mirrors of these files. 

215
00:15:13,150 --> 00:15:15,700
所以,我可以去许多其他镜像站点去下载Debian,
So instead of downloading Debian from Debian.org, 

216
00:15:15,700 --> 00:15:18,575
不用从Debian.org下载Debian,
I can go to one of many other sites 

217
00:15:18,575 --> 00:15:22,925
镜像站上的Debian和在Debian.org托管的应该是相同的文件.
and download what are supposed to be the same files that are hosted at Debian.org. 

218
00:15:22,925 --> 00:15:26,525
但是,我怎么知道我有没有得到正确的文件?
But how do I know that I actually got the correct file?  

219
00:15:26,625 --> 00:15:32,000
比如,如果有一个恶意镜像,比如你去了类似"AnishaIsEvilDebian.com"
Like, what if I set up a malicious mirror and you go to like "AnishaIsEvilDebian.com"

220
00:15:32,000 --> 00:15:36,600
然后尝试在上面下载Debian,那么结果可能是你的Linux安装程序被植入了后门.
and then try to download Debian,  turns out that your Linux installation is backdoored.  

221
00:15:36,600 --> 00:15:40,675
一种解决方案就是就是从官网下载一份副本,
Well, one thing you could do is download a copy from the original Debian website 

222
00:15:40,675 --> 00:15:42,475
然后和你从镜像站下载的版本进行比较.
and then download my version and compare them. 

223
00:15:42,475 --> 00:15:44,025
但这有点违背了初衷,对吧?
But that kind of defeats the purpose, right? 

224
00:15:44,025 --> 00:15:47,875
我们不想从Debian.org下载文件,因为托管这些文件很昂贵,
Because we want to avoid downloading things from Debian org because hosting these files is expensive, 

225
00:15:47,875 --> 00:15:51,675
我们希望让人们能够使用在其他地方的镜像.
and we want all these different people to be able to mirror copies of the files elsewhere. 

226
00:15:51,725 --> 00:15:57,200
那么,有没有人察觉到加密哈希函数可以用来解决这个问题.
So, does anybody see how cryptographic hash functions could be useful to solve this problem? 

227
00:15:57,200 --> 00:16:00,325
我想从一个不信任的源下载文件,
That I want to download a file from an untrusted source

228
00:16:00,325 --> 00:16:03,875
不是从可信源本身下载文件.
but and not from like the trusted source itself.

229
00:16:03,875 --> 00:16:07,000
但我也许可以从这个可信源获取一些简短的信息,
But maybe I can get some small piece of information from this trusted source, 

230
00:16:07,000 --> 00:16:12,425
以便验证我从不信任的源下载的文件.
in order to know whether the file I downloaded from the untrusted source is the thing I was supposed to get. 

231
00:16:16,475 --> 00:16:20,675
是的,它就是一个加密哈希函数的简单应用.
Yes, like it's basically just a straightforward application of cryptographic hash functions. 

232
00:16:20,675 --> 00:16:26,800
Debian可以生成正确的ISO文件或其他文件,
So what Debian.org can do is they can produce their kind of correct ISO file or whatever they want, 

233
00:16:26,800 --> 00:16:33,275
并且不用在他们的网站上发布文件本身,而是发布该文件的哈希值.
and instead of publishing the file itself on their website, they can publish a hash of that file. 

234
00:16:33,275 --> 00:16:36,600
与文件本身相比,
So, compared to the file itself which may be many gigabytes,

235
00:16:36,600 --> 00:16:41,450
这个哈希值可能只有160位数据,相对于发布源文件,发布哈希值非常便宜.
this is only like in this particular case 160 bits of data, right? So very cheap to host. 

236
00:16:41,450 --> 00:16:44,450
然后,作为用户,我可以随便从什么网站下载该文件,
And then what I can do as a user is I can download 

237
00:16:44,450 --> 00:16:48,250
可能是一个不受信任的网站,
that file from any random website, it could be an untrusted website, 

238
00:16:48,250 --> 00:16:51,625
下载完成后,我只需双重检查sha-1哈希值.
and after I download, I just double-check the sha-1 hash. 

239
00:16:51,625 --> 00:16:56,200
如果哈希匹配,则我知道我有正确的文件,
And if the hash matches, then I know that I have the right file 

240
00:16:56,200 --> 00:16:58,554
因为如果有一些不同的文件,
because it's computationally infeasible for somebody 

241
00:16:58,554 --> 00:17:02,200
而这些文件恰好具有相同的哈希值,这基本上是不可能的,
to give me some different file that happens to have the same hash, 

242
00:17:02,200 --> 00:17:05,000
因为哈希函数是抗碰撞的.
because hash functions are collision-resistant. 

243
00:17:06,025 --> 00:17:08,725
对此应用有任何问题吗?
So any questions about that application?  

244
00:17:18,000 --> 00:17:23,025
是的,这是一个很好的问题,问题是,为什么需要不同的人来托管信息?
Yeah, so that's a good question, like why do you need different people to host the information? 

245
00:17:23,025 --> 00:17:25,250
难道对于每个人来说托管的成本是不一样的吗?
Like wouldn't it be equally expensive for everybody?

246
00:17:25,250 --> 00:17:27,725
这个问题的答案有点复杂,
So the answer to that question is a little bit complicated, 

247
00:17:27,725 --> 00:17:29,950
但我会解释一部分.
but like here's a partial answer. 

248
00:17:29,950 --> 00:17:34,725
一件事是从服务器下载文件会受到服务器距离的限制.
One thing is that downloading files from a server is affected by how far away the server is from you. 

249
00:17:34,725 --> 00:17:39,000
举个例子,如果服务器在马萨诸塞州,而你在中国,
So for example, if the server is in Massachusetts and you're in say China, 

250
00:17:39,000 --> 00:17:42,000
你必须通过互联网进行大量数据的往返,
you have to kind of make a big round trip across the internet, 

251
00:17:42,000 --> 00:17:44,225
有许多原因,会让这个操作变得昂贵,
and that may be expensive for a number of reasons. 

252
00:17:44,225 --> 00:17:47,467
比如延迟高,
Like the latency is high and the traffic needs to go through kind of 

253
00:17:47,467 --> 00:17:50,000
流量需要通过许多不同的线才能到达你所在的位置.
lots of different wires to make its way all the way to where you are. 

254
00:17:50,000 --> 00:17:55,250
因此,这些网站所做的就是将他们的文件分发到世界各地的服务器上,
And so one thing that these websites do is that they distribute their content to servers that are all over the world, 

255
00:17:55,250 --> 00:17:58,050
然后作为用户,你从离你最近的服务器下载.
and then as a user, you download from the server that's closest to you. 

256
00:17:58,050 --> 00:18:03,400
比如,MIT维护一个Debian软件包仓库,里面涵盖所有的Debian软件的镜像.
Like for example, MIT maintains a Debian package repository and kind of mirrors all the Debian stuff. 

257
00:18:03,400 --> 00:18:09,175
因此,如果你是MIT的Debian用户,你可以使用MIT提供的镜像文件,
So if you're a Debian user at MIT, you can use the MIT copy of everything, 

258
00:18:09,175 --> 00:18:12,200
然后通过我们的本地网络快速访问资源,
and then you can kind of access it over our fast local network, 

259
00:18:12,200 --> 00:18:15,250
这样流量根本不需要通过外部互联网,
and that traffic never needs to go to the outside Internet at all, 

260
00:18:15,250 --> 00:18:16,475
所以速度非常快.
so it's very fast. 

261
00:18:16,475 --> 00:18:18,225
这是个好问题.
That's a good question. 

262
00:18:18,225 --> 00:18:21,675
还有其他问题吗?
Any other questions?

263
00:18:21,675 --> 00:18:24,600
好的,还有一个有趣的应用是
Okay, and then one final kind of interesting application of hash functions

264
00:18:24,600 --> 00:18:26,525
哈希函数的承诺机制.
is something called a commitment scheme. 

265
00:18:26,525 --> 00:18:29,125
我想玩一个游戏,
So I want to play a game, 

266
00:18:29,125 --> 00:18:30,325
我需要一个志愿者.
and I need a volunteer for this. 

267
00:18:30,325 --> 00:18:33,635
你不需要从座位上站起来,只需要你跟我交流一下.
So you don't actually need to get up from your seat or anything, I just need you to talk with me. 

268
00:18:33,635 --> 00:18:39,825
有人自愿参与吗?好的,你叫什么名字?Abdul Aziz?好的,太好了.
So any volunteers raise your hand? Yeah, okay, what's your name? Abdul Aziz? Okay, great. 

269
00:18:39,825 --> 00:18:44,833
所以,Abdul Aziz,我们要玩一个游戏,我要掷一枚硬币,
So Abdul Aziz, we're going to play a game where I'm going to flip a coin

270
00:18:44,833 --> 00:18:46,475
然后你要猜正面或反面,
and then you're gonna call heads or tails, 

271
00:18:46,500 --> 00:18:48,350
如果你猜对了,你就赢了,
and if you call it right, you win, 

272
00:18:48,350 --> 00:18:49,900
如果你猜错了,你就输了.
and if you call it wrong, you lose. 

273
00:18:49,900 --> 00:18:52,425
这个游戏没有任何利益关系,
And there are no stakes for this game, 

274
00:18:52,425 --> 00:18:53,975
就是为了成就感.
but just the pride of winning. 

275
00:18:55,475 --> 00:18:59,300
但是不幸的是,我看了一下我的钱包,只有美元,没有硬币.
Sadly, I checked my wallet and all I have is dollar bills, I don't have any coins with me. 

276
00:18:59,300 --> 00:19:01,600
所以,我只能在脑海中掷硬币.
So instead, I'm just going to flip the coin in my head. 

277
00:19:01,600 --> 00:19:02,450
好的,
Alright, 

278
00:19:02,450 --> 00:19:05,675
我掷硬币了,请你叫正面或反面.
so okay, I flip the coin, call heads or tails. 

279
00:19:05,675 --> 00:19:07,825
很抱歉,你输了,是正面.
Sorry, you lost, it was heads. 

280
00:19:11,025 --> 00:19:16,450
我可以作弊,对吧?我可以先听到你说的,然后我说相反的结果.
I can cheat, right? I can just see what you say and say the opposite thing. 

281
00:19:16,450 --> 00:19:18,175
所以让我们试着让这个游戏变得公平一些.
So let's try fixing this game. 

282
00:19:18,175 --> 00:19:25,500
就是如果我提前告诉你翻转结果是正面还是反面,你再猜.
How about you call heads or tails after I say what the flip result was? 

283
00:19:25,500 --> 00:19:27,080
好的,如果我说"结果是反面",
Okay, yeah, so if I say, "Oh, the result is tails," 

284
00:19:27,080 --> 00:19:31,100
你会怎么猜?你会选反面?是的.
What are you gonna say? Are you gonna call tails? Yeah. 

285
00:19:33,350 --> 00:19:36,975
那么,我们怎么可以
So, is it possible to play this 

286
00:19:36,975 --> 00:19:43,700
在没有硬币的情况下公平地玩这个"猜硬币"的游戏呢?
"Guess what the coin flip result is" game in a fair way without having a physical coin that we share? 

287
00:19:43,700 --> 00:19:46,025
因为我现在没有硬币.
Like, because I can't really manipulate your physical reality. 

288
00:19:46,025 --> 00:19:48,825
如果我在你面前抛硬币,你会相信它是公平的,对吧?
If I flip a coin in front of you, you probably trust that it's okay, right? 

289
00:19:48,825 --> 00:19:52,750
所以,人们发现了一种利用哈希函数的方法,是所谓的承诺方案的思想,
So, it turns out that hash functions give us a kind of cool way to solve this problem 

290
00:19:52,750 --> 00:19:55,750
为我们提供了一种解决这个问题的很酷的方案.
through an idea called a commitment scheme. 

291
00:19:55,825 --> 00:20:00,600
因此,这是解决问题的一种方案.
So, I can say, "Here's the construction of the solution. 

292
00:20:00,625 --> 00:20:02,850
我可以选择正面或反面,
I can pick heads or tails, 

293
00:20:02,850 --> 00:20:09,425
实际上我要选择一个大的随机数,比如这个数,
and I'm actually going to pick a big random number, say like this number here, 

294
00:20:09,425 --> 00:20:15,775
我能做的是计算这个数字的 sha1sum.
and what I can do is compute the sha1sum of this number. 

295
00:20:15,775 --> 00:20:19,325
在这个时刻,你还没有看到这个数,我只是在脑海中做所有这些.
At this moment, you haven't seen this number yet, I'm just doing all this in my head. 

296
00:20:19,325 --> 00:20:23,200
然后,我告诉你:"好的,我抛了硬币,
And then what I do is I tell you, "Okay, I flipped a coin, 

297
00:20:23,200 --> 00:20:27,800
我现在不会告诉你结果,因为你还没有猜正面或反面,
and I'm not going to tell you what the result is just yet because you haven't called heads or tails, 

298
00:20:27,800 --> 00:20:30,150
但我会告诉你结果的sha1sum.
but I'll tell you what the sha1sum of the result is. 

299
00:20:30,150 --> 00:20:32,100
就是这个值.
Here you go,and I tell you this value. 

300
00:20:32,100 --> 00:20:34,475
现在,你可以猜正面或反面了.
Now, after this, you can call heads or tails. 

301
00:20:34,475 --> 00:20:37,625
所以,你选什么?选正面.
So, what do you say? Like, say heads afterwards. 

302
00:20:37,625 --> 00:20:41,025
那么,我现在告诉你我的输入,
What I can do is I can reveal to you what my input to this function was, 

303
00:20:41,025 --> 00:20:42,725
然后你可以进行验证,
and then you can cross-check this, right? 

304
00:20:42,725 --> 00:20:47,750
对输入进行sha1sum以验证输出是否与我之前给你的一样,
You can compute the sha1sum on the input to verify that the output is what I said it was earlier, 

305
00:20:47,750 --> 00:20:50,875
我们需要将这些数字对应到正面或反面.
and then we can have some way of mapping these numbers to heads or tails. 

306
00:20:50,875 --> 00:20:55,575
比如说我们事先协商同意偶数为正面,奇数为反面,
So, I might have agreed upon beforehand that even numbers are heads and odd numbers are tails, 

307
00:20:55,575 --> 00:20:57,625
这是一种让游戏变公平的方法.
and so this is a way of fixing that game. 

308
00:20:57,625 --> 00:20:59,875
所以,现在我们可以在我们的脑海中玩这个游戏了.
So, we can actually play this game in our heads. 

309
00:21:00,475 --> 00:21:02,625
我可以选择一个值,
I can pick a value, 

310
00:21:02,625 --> 00:21:04,225
我不会告诉你这个值是什么,
but not reveal that value to you, 

311
00:21:04,225 --> 00:21:05,850
但我可以承诺该值.
but I can commit to the value. 

312
00:21:05,850 --> 00:21:10,400
因此,这是一种承诺机制,我在告诉你之后无法改变主意,
So, this is a kind of binding commitment scheme that I can't change my mind after I've told you this, 

313
00:21:10,400 --> 00:21:12,850
但不会向你透露原始值.
but it doesn't reveal the original value to you. 

314
00:21:13,350 --> 00:21:16,800
因此,这是加密哈希函数的另一个不错的应用.
And so, this is one other neat application of cryptographic hash functions. 

315
00:21:16,950 --> 00:21:23,100
对于承诺机制有什么问题吗?好的.
Any questions about this particular construction? Okay, great. 

316
00:21:23,125 --> 00:21:28,800
接下来,我们将讨论密钥生成函数,
So, moving on to the next topic, we're going to talk about key derivation functions. 

317
00:21:38,975 --> 00:21:41,800
通常缩写为KDF.
Often abbreviated as KDFs. 

318
00:21:44,075 --> 00:21:48,049
这是一个与哈希函数非常相似的概念,
So, this is a concept that's very similar to hash functions,

319
00:21:48,049 --> 00:21:52,725
但是它还有一个额外的特性,即计算速度较慢.
except it has kind of one extra property that it is slow to compute. 

320
00:21:52,800 --> 00:22:07,715
举个例子,有一个被称为PBKDF2的哈希函数
For example, there's a hash function or key derivation function known as PBKDF2, 

321
00:22:07,715 --> 00:22:09,828
或者说密钥生成函数,
password-based key derivation function, 

322
00:22:09,828 --> 00:22:15,070
它具有我们先前所说的这些哈希函数类似的性质,
that has a kind of similar form as these hash functions we were talking about here,

323
00:22:15,070 --> 00:22:18,078
它们接受可变长度的输入并生成固定长度的输出.
that they take in some variable length input and produce a fixed length output. 

324
00:22:18,175 --> 00:22:20,450
但它们通常被用于一特定目的.
But they're meant to be used for one particular purpose. 

325
00:22:20,450 --> 00:22:26,025
这个目的通常是将固定长度的输出作为另一个加密算法中的密钥.
The purpose is generally to use the fixed length output as a key in another cryptographic algorithm. 

326
00:22:26,025 --> 00:22:30,650
我们稍后将讨论这些算法,比如这个函数的用途.
And we'll talk about those algorithms, like what use the output of this thing for in a moment. 

327
00:22:30,650 --> 00:22:34,550
但这些函数的一个特性就是它们很慢.
But one property of these things is that they're slow. 

328
00:22:34,550 --> 00:22:39,550
有没有人知道为什么要让算法变慢?
Does anybody have any idea why you'd want an algorithm to be slow? Like, 

329
00:22:39,550 --> 00:22:41,825
通常我们希望算法很快,对吧?
normally we want algorithms to be fast, right? 

330
00:22:41,825 --> 00:22:43,750
那么为什么我们希望算法很慢呢?
So why would we want an algorithm to be slow? 

331
00:22:43,750 --> 00:22:56,550
是的,没错,就是这个原因.
Yes, yeah, that's exactly it. 

332
00:22:56,550 --> 00:22:59,150
我重复一遍.
So, I'll repeat so it goes into the microphone.

333
00:22:59,150 --> 00:23:01,518
希望它变慢的原因是
The reason you want these to be slow is 

334
00:23:01,518 --> 00:23:05,200
在实际使用它进行密码认证时.
when you're actually using it for something like password authentication. 

335
00:23:05,200 --> 00:23:07,460
你保存了密码的哈希值,
Where you have the hash of a password saved

336
00:23:07,460 --> 00:23:10,518
然后有人输入密码,你想知道它是否与哈希值相对应.
and then somebody inputs the password, you want to know if that corresponds to the hash. 

337
00:23:10,518 --> 00:23:13,950
它慢一些也没关系,因为你只需要做一次这个检查.
It's okay if it's slow because you're only doing this check kind of once. 

338
00:23:13,950 --> 00:23:16,650
但是这个函数需要慢的真正的原因是,
But the other scenario in which you're going to be using this function 

339
00:23:16,650 --> 00:23:19,100
当有人试图暴力破解密码时.
is when somebody's trying to brute-force a password. 

340
00:23:19,125 --> 00:23:21,898
比如一个网站的密码数据库被盗,
Say a website has their password database stolen 

341
00:23:21,898 --> 00:23:24,775
有人在尝试破解所有密码.
and somebody's going through all the accounts, trying to break all the passwords. 

342
00:23:24,775 --> 00:23:27,750
那么在这种情况下,你就需要这个函数变慢,
Well, in that case, you want this to be slow

343
00:23:27,750 --> 00:23:30,025
因为有人将要做这个操作数百万次.
because someone's gonna be doing this like millions and millions of times. 

344
00:23:30,025 --> 00:23:32,750
通过使这个函数变慢,可以大大减缓攻击者的破解速度.
And you can slow down the attacker a lot by making this function slow. 

345
00:23:32,750 --> 00:23:36,850
所以,如果这需要一秒钟才能计算出这个函数,这不影响密码的验证.
And so it's fine if this takes you like one second upon logging in to compute this function. 

346
00:23:36,850 --> 00:23:38,235
但当有人进行暴力破解时,
But when you're brute-forcing it,

347
00:23:38,235 --> 00:23:41,550
他们无法像那个 xkcd 漫画中一样每秒尝试一千次.
we don't go to a thousand guesses a second like in that xkcd comic. 

348
00:23:41,550 --> 00:23:42,550
我们可以让它慢一点.
We can slow it down a little bit. 

349
00:23:44,650 --> 00:23:48,425
那么密钥生成函数的输出实际上用于什么呢?
So what is the output of key derivation functions actually used for? 

350
00:23:48,425 --> 00:23:50,907
这就是我们接下来要讨论的,
Well, the next topic we're going to talk about,

351
00:23:50,907 --> 00:23:54,225
可能是一提到密码学你就会想到的东西,
probably like one of the most classic things when you think about cryptography,

352
00:23:54,225 --> 00:23:56,325
就是加密和解密.
is encryption and decryption. 

353
00:23:58,325 --> 00:24:01,550
我们先讲是对称加密.
The next topic is symmetric key cryptography. 

354
00:24:14,425 --> 00:24:19,900
就像先前讲哈希函数一样,我们不会讨论实现它们的具体细节,
And like the rest of this lecture, we're not going to talk about how you implement these. 

355
00:24:19,900 --> 00:24:24,975
而是仅仅讨论对称加密的 API,就是它们如何被使用.
We're going to talk about the API for a symmetric key, symmetric key crypto, like how it's used. 

356
00:24:24,975 --> 00:24:29,300
对称加密系统有几个不同的函数.
So symmetric key crypto systems have a couple different functions. 

357
00:24:30,000 --> 00:24:32,300
它们有一个密钥生成函数,
They have a key generation function,

358
00:24:32,300 --> 00:24:37,825
这是一个随机生成函数,生成所谓的密钥.
which is a randomized function that produces a thing we call the key. 

359
00:24:37,875 --> 00:24:41,575
有另外一对函数,进行加密和解密.
And then they have a pair of functions, encrypt and decrypt. 

360
00:24:46,200 --> 00:24:51,250
加密需要将我们所称的明文作为输入,
And encrypt take as input something we refer to as the plaintext, 

361
00:24:52,400 --> 00:24:54,925
明文可以是一些字节序列,一些数据.
and this is just some sequence of bytes,  some data.  

362
00:24:54,925 --> 00:24:56,950
它需要输入一个密钥,
And it takes in a key, 

363
00:24:56,950 --> 00:24:59,975
密钥就是来自这个密钥生成函数,
so something that came as an output of this key generation function, 

364
00:24:59,975 --> 00:25:06,300
然后产生所谓的密文.
and produces what we call the ciphertext. 

365
00:25:06,300 --> 00:25:08,475
然后解密函数则是相反的过程.
And then decrypt does the opposite of this. 

366
00:25:08,475 --> 00:25:17,350
输入密文和密钥,输出明文.
So it takes the ciphertext along with the key and produces the plaintext. 

367
00:25:21,400 --> 00:25:26,175
这个三个函数有几个属性.
And this triple of functions has a couple properties. 

368
00:25:26,175 --> 00:25:30,644
其中之一,如我们所料,
One is that, like one you might expect, is that 

369
00:25:30,644 --> 00:25:35,975
单单从密文无法得知明文.
this thing doesn't really tell you all that much about this input to the encryption. 

370
00:25:35,975 --> 00:25:45,492
所以第一个性质是,
So property number one is given the ciphertext, 

371
00:25:45,492 --> 00:25:56,825
只有在拥有密钥的情况下,你才能通过密文找出明文.
you can't figure out the plaintext without the key. 

372
00:26:00,850 --> 00:26:04,600
另一个是一个非常显然的属性,
And the other property is kind of the obvious correctness property, 

373
00:26:04,600 --> 00:26:13,350
即如果你使用密钥k加密
that if you take something and you encrypt it, 

374
00:26:13,850 --> 00:26:16,100
一个信息m,
some message m with a key k, 

375
00:26:16,100 --> 00:26:20,100
然后使用相同的密钥(即k)解密该密文,
and then you decrypt that ciphertext using the same key, 

376
00:26:20,100 --> 00:26:23,200
那么你将得到相同的消息(即m).
that gives you back the same message. 

377
00:26:25,025 --> 00:26:28,100
这是显而易见的.
This is the kind of obvious correctness property. 

378
00:26:28,975 --> 00:26:30,800
我讲明白了吗?
So, does this description make sense? 

379
00:26:30,800 --> 00:26:33,175
现在你们能不能更直观地理解密钥生成函数?
Does it fit your kind of intuitive understanding of taking some piece of data and obscuring it?

380
00:26:33,175 --> 00:26:35,406
我们通常将某些数据加密来隐藏原始输入,这样别人就无法知道原始输入,
So you can't really tell anything about the original input, but then taking that obscured result,

381
00:26:35,406 --> 00:26:38,350



382
00:26:38,350 --> 00:26:41,358



383
00:26:41,358 --> 00:26:47,475
然后我们自己使用密钥进行解密就可以获取原始数据.
and then passing it through some decryption function given that key to retrieve the original input?

384
00:26:48,925 --> 00:26:53,800
这个描述并不能完全阐明"安全"这一概念,
And this isn't really a rigorous definition of what it means for something to be secure, 

385
00:26:53,800 --> 00:26:58,025
但这是一个足够直观的定义,我们可以使用它来帮我们理解.
but it's a good enough intuitive definition that we can work with it. 

386
00:26:59,325 --> 00:27:04,300
那么,关于这个描述有没有问题?
So any questions about that description there?

387
00:27:05,800 --> 00:27:09,028
那么对称加密有什么应用呢?
So where can symmetric key cryptography be useful?

388
00:27:09,028 --> 00:27:11,200
这节课后面我们会讲解许多例子,
We'll talk about a whole bunch of examples later in this lecture, 

389
00:27:11,200 --> 00:27:13,084
但现在我就先举一个例子,
but one example we'll talk about right now 

390
00:27:13,084 --> 00:27:17,050
即将文件加密,然后把它存在一个不受信任的云服务中.
is encrypting files for storage in an untrusted cloud service. 

391
00:27:17,075 --> 00:27:22,872
比如说像Dropbox或Google Drive这样的服务,
So consider something like Dropbox or Google Drive,or things like that 

392
00:27:22,872 --> 00:27:24,913
你上传文件到这些云服务器上面,
where you're uploading files there 

393
00:27:24,913 --> 00:27:29,175
信任它们不会偷窥你的文件或者对其进行什么恶意操作.
and trusting the service to not look at your files or do anything malicious with them. 

394
00:27:29,750 --> 00:27:34,950
这些云服务商,至少在我刚刚提到的那几个,并没有在上传的时候进行加密等操作.
These services, at least the ones I named, are not encrypted or anything like that. 

395
00:27:34,950 --> 00:27:38,475
所以理论上,这些公司的任何员工都可以查看你的文件.
In theory, any employee of those companies could look at your files. 

396
00:27:38,475 --> 00:27:41,862
当然,这些公司有许多政策和技术控制
Now, of course, these companies have lots of policies and technical controls in place

397
00:27:41,862 --> 00:27:44,000
来确保这种情况不会发生,
for making sure that that sort of thing doesn't happen, 

398
00:27:44,000 --> 00:27:47,150
但这并不意味着偷窥在技术上不可实现.
but that doesn't mean that it's not technically possible. 

399
00:27:47,175 --> 00:27:49,424
如果你不信任这些云服务,
So one thing you might want to do if you don't want to 

400
00:27:49,424 --> 00:27:51,950
不想让他们偷窥你的数据,
trust these cloud services to not peek at your data, 

401
00:27:51,950 --> 00:27:53,680
比如拿你的数据进行机器学习,
not do like machine learning over them, 

402
00:27:53,680 --> 00:27:55,920
或者进行其他你不想要的操作等等.
or do other sorts of things that you wouldn't really want, 

403
00:27:55,920 --> 00:27:57,840
那么你可以在上传这些文件到云服务器之前
is you can just take your files 

404
00:27:57,840 --> 00:28:02,530
对其进行加密.
and encrypt them before uploading them to these web services. 

405
00:28:02,625 --> 00:28:05,725
这样是不是就提高了安全性?我可以将我的文件
So does that idea make sense? That I can take my file, 

406
00:28:05,725 --> 00:28:09,747
比如照片之类的,通过一个加密函数,产生密文,
like center pictures or whatever, pass it through an encryption function and produce the ciphertext, 

407
00:28:09,747 --> 00:28:13,700
然后加密后的文件就可以安全地上传到云服务器上进行备份等操作,
and then place that ciphertext on the web service safe for backup purposes or whatever, 

408
00:28:13,700 --> 00:28:19,025
如果我需要该文件,我可以检索该密文的密钥,然后将其解密回明文,
and if I ever need that, I can retrieve the ciphertext, then use my key to decrypt it back into the plaintext, 

409
00:28:19,025 --> 00:28:21,650
这样就得到了原始文件.
and then use the result for doing whatever I need to do. 

410
00:28:21,650 --> 00:28:23,150
你们有什么问题吗?
Does that make sense?

411
00:28:23,225 --> 00:28:29,525
是的,这是一个好问题.
Yeah, that's a good question. 

412
00:28:29,525 --> 00:28:33,150
问题是,是不是所有人都通过相同的加密程序进行加密?
The question is, couldn't anybody else run it through the same encryption program? 

413
00:28:33,150 --> 00:28:37,100
或许我应该更详细地解释一下,
One detail maybe I should have explained in a little bit more detail is 

414
00:28:37,100 --> 00:28:41,275
这个密钥生成函数生成的密钥是随机的,
this key generation function is randomized, 

415
00:28:44,525 --> 00:28:47,250
并且这个密钥具有高熵值.
and this key has high entropy. 

416
00:28:47,250 --> 00:28:53,550
回到我们之前讨论的主题,比如我们可能还会使用AES-256加密.
So going back to that topic we talked about earlier, like an example is we might have AES-256. 

417
00:28:54,675 --> 00:28:57,625
这是一种对称加密,
This is one particular symmetric cipher, 

418
00:28:57,625 --> 00:29:02,775
你们可能可以从它的名称猜到它的密钥具有256位熵.
and this, as the name might indicate, has 256 bits of entropy in the key. 

419
00:29:02,775 --> 00:29:05,327
这意味着只要攻击者(即从网络服务下载密文的人)
And so that means that as long as the attacker, 

420
00:29:05,327 --> 00:29:09,231
不知道你的密钥,
whoever downloads the ciphertext from the web service, doesn't know your key, 

421
00:29:09,231 --> 00:29:13,900
除非他们的攻击手段很牛杯,否则他们只能暴力尝试所有可能的密钥.
unless they have some better attack in place, they'll have to try all the different possible keys. 

422
00:29:13,900 --> 00:29:18,675
如果可能的密钥有2^256个,那么在一定的时间内尝试所有密钥是不可能的.
And if there are 2 to the 256 keys, that's too many keys to try in a reasonable amount of time. 

423
00:29:18,675 --> 00:29:20,525
这回答了你的问题吗?
Does that answer the question?

424
00:29:20,525 --> 00:29:22,700
好的,还有其他问题吗?
Okay, any other questions?

425
00:29:35,550 --> 00:29:37,050
这是一个很好的问题,
That's an excellent question, 

426
00:29:37,050 --> 00:29:39,450
也引出了我接下来要谈论的话题.
and that leads into what I was going to talk about next. 

427
00:29:39,450 --> 00:29:40,250
所以感谢你的提问.
So thanks for that question. 

428
00:29:40,250 --> 00:29:45,025
正如你所指出的,如果我丢了我的密钥,就寄了,对吧?
As you point out, like if I lose my key, I'm kind of stuck, right? 

429
00:29:45,025 --> 00:29:45,985
我需要我的密钥来解密.
I need my key to decrypt. 

430
00:29:45,985 --> 00:29:47,300
密钥就是这个加密系统的重点.
That's kind of the point of this thing. 

431
00:29:47,300 --> 00:29:50,925
如果我不需要密钥来解密,那么这个加密系统就不会有很好的安全性.
If I didn't need my key to decrypt, then this wouldn't be a very good crypto system. 

432
00:29:50,925 --> 00:29:54,319
所以我可以将这个对称加密的想法
And so I can combine this idea of symmetric key cryptography 

433
00:29:54,319 --> 00:29:57,600
与我们刚才谈论的密钥生成函数相结合.
with the topic we just talked about, key derivation functions. 

434
00:29:57,600 --> 00:30:01,935
因此,与其通过密钥生成函数随机生成密钥.
So instead of having some key that's randomly generated with my key generation function, say sampling entropy from somewhere on my machine, 

435
00:30:01,935 --> 00:30:04,303



436
00:30:04,375 --> 00:30:14,050
我可以使用一个口令,并将其传递给我的密钥生成函数,
I can have a passphrase and pass it through my key derivation function box, 

437
00:30:14,400 --> 00:30:16,500
处理后就可以得到我的密钥.
and this gives me my key. 

438
00:30:16,500 --> 00:30:26,300
然后,我可以将我的明文和密钥输入到我的加密函数中,
Then, I can take my plaintext and combine it with my key in my encrypt function, 

439
00:30:28,475 --> 00:30:30,950
从而产生我的密文.
and this produces my ciphertext. 

440
00:30:33,925 --> 00:30:36,825
我将这个密文存储在网络服务上,
I store this ciphertext on the web service, 

441
00:30:36,825 --> 00:30:39,000
现在我不需要保存这个密钥了.
but now I don't need to save this key. 

442
00:30:39,000 --> 00:30:41,450
我只需要记住我的口令,
Instead, I can just remember my passphrase, 

443
00:30:41,450 --> 00:30:45,650
每当我需要我的密钥时,我就可以通过密钥生成函数中重新生成它.
and whenever I need my key, I can reconstruct it from the key derivation function. 

444
00:30:45,725 --> 00:30:46,650
问题?
Question? 

445
00:30:56,850 --> 00:30:58,575
是的,这是一个好问题.
Yeah, so that's a good question. 

446
00:30:58,575 --> 00:31:03,762
问题是,密钥生成函数为了防止暴力破解是否足够慢?
The question is, is the key derivation function slow enough to prevent brute-force guessing? 

447
00:31:03,762 --> 00:31:07,075
答案是,这取决于你的口令有多长.
The answer is, it depends on how long your passphrase is. 

448
00:31:07,075 --> 00:31:10,866
例如,如果你的口令像字符串"password"一样简单,
For example, if your passphrase is like the string 'password', 

449
00:31:10,866 --> 00:31:12,466
那么它很可能很快就能被破解.
it is probably going to get broken very quickly. 

450
00:31:12,500 --> 00:31:15,825
但要是你的口令具有高熵,安全性就足够高.
But as long as there's enough entropy in your passphrase, this is good enough. 

451
00:31:15,825 --> 00:31:19,400
所以,如果我要上传一些文件到Dropbox,我希望它有很高的安全性,
So, like if I was uploading something to Dropbox and I really want it to stay secret, 

452
00:31:19,400 --> 00:31:21,400
那么一个64位口令,
I think a 64-bit passphrase, 

453
00:31:21,400 --> 00:31:26,550
一个具有64位熵的口令,在这种情况下将足够安全.
really a passphrase with 64 bits of entropy, it would be more than enough in that scenario, for example. 

454
00:31:27,275 --> 00:31:31,250
这里还有一个简单的演示:有一些工具可以简化这个流程.
And just a quick demo of this: so there are tools to make this really easy to do. 

455
00:31:31,250 --> 00:31:33,075
实际上,这是课程笔记的一个练习,
This is actually one of the exercises, 

456
00:31:33,075 --> 00:31:36,275
我们可以使用一个名为openssl的工具,
but we can take a tool, for example, called openssl, 

457
00:31:36,275 --> 00:31:40,050
对某个文件实施对称加密.
and use it to apply a symmetric cipher to some file. 

458
00:31:40,050 --> 00:31:42,725
例如,我有"README.md".
So, I had my README text here, for example, "README.md". 

459
00:31:42,725 --> 00:31:44,800
它里面有很多东西,
It has a bunch of stuff in it, 

460
00:31:44,800 --> 00:31:52,525
我可以输入"openssl aes-256-cbc","aes-256-cbc"是一个特定的对称加密算法,
and I can do "openssl aes-256-cbc", this is the name of a particular symmetric cipher, 

461
00:31:52,675 --> 00:31:57,696
然后我可以说我要将它应用于"README.md",
and I can say that I want to apply this to "README.md" 

462
00:31:57,696 --> 00:32:02,475
并输出为...让我们给它起一个名字,"README.enc.md",
and produce "README.enc.md", let's give it some name.

463
00:32:02,475 --> 00:32:03,925
然后它会要求你输入一个密码.
And then it's asking you for a password. 

464
00:32:03,925 --> 00:32:06,640
所以,默认情况下,它是这样工作的,我提供一个口令,
So, by default, this works in this mode where I provide a passphrase, 

465
00:32:06,640 --> 00:32:08,496
它经过KDF处理后生成一个密钥,
it's run through a KDF to produce a key, 

466
00:32:08,525 --> 00:32:09,875
然后用于加密.
and that's used for encryption. 

467
00:32:09,875 --> 00:32:12,750
所以,我会输入一个密码.再输入一遍....
So, I'll type in some password, type it in again, 

468
00:32:12,750 --> 00:32:15,625
然后现在已经生成了这个"README.enc.md".
and now I produce this "README.enc.md" file. 

469
00:32:15,625 --> 00:32:20,050
如果我查看这个文件,感觉它啥也不是.
If I look at this, it kind of looks like garbage, 

470
00:32:20,075 --> 00:32:22,750
但这正是对称加密的关键.
And that's, at a high level, the point of a symmetric cipher. 

471
00:32:22,750 --> 00:32:27,475
它产生的密文和随机数据一样,我们没法区分.
It produces some ciphertext that should be kind of indistinguishable from random data. 

472
00:32:28,050 --> 00:32:30,915
当我想要解密这个文件时,
And when I want to decrypt this, I can run 

473
00:32:30,915 --> 00:32:36,975
我可以运行类似的命令:"openssl aes-256-cbc -d",表示解密,
a similar command: 'openssl aes-256-cbc -d', for decrypt,

474
00:32:36,975 --> 00:32:39,908
"README.enc.md"作为输入,
take the input from "README.enc.md", 

475
00:32:39,950 --> 00:32:46,975
并将"README.dec.md"作为输出.
and I like to do "README.dec.md" as the output. 

476
00:32:47,675 --> 00:32:50,825
我可以比较这两个文件,
And I can compare these two files, 

477
00:32:52,775 --> 00:32:58,325
对称加密的属性告诉我解密后的结果应该与原始数据完全一致.
and the correctness property of symmetric cryptography tells me that this should be identical. 

478
00:32:58,325 --> 00:33:00,000
确实如此.
And this indeed is identical. 

479
00:33:00,000 --> 00:33:02,150
如果我查看返回值,返回值为0,
If I look at the return value, compare return 0, 

480
00:33:02,150 --> 00:33:03,850
这意味着它们是相同的文件.
so that means that are the same file. 

481
00:33:04,575 --> 00:33:12,750
所以,关于对称加密有什么问题吗?
So, any questions about symmetric key cryptography? Yeah, 

482
00:33:19,775 --> 00:33:24,150
是的,这个命令确实创建了一个新文件,
so the particular command did make a new file, 

483
00:33:24,150 --> 00:33:27,975
所以它以"README.md"作为我们的输入并产生了这个文件作为输出,
so it took us input "README.md" and produced output this file, 

484
00:33:27,975 --> 00:33:30,425
这就是该文件的加密版本.
so that is the encrypted version of the file.

485
00:33:30,425 --> 00:33:32,675
它并没有改变原始文件,
It left the original untouched, 

486
00:33:32,675 --> 00:33:35,275
但是如果我想,我可以删除它.
but then of course I could delete it if I wanted to. 

487
00:33:45,350 --> 00:33:47,269
是的,这是一个很好的问题.
Yeah, that's a good question. 

488
00:33:47,269 --> 00:33:49,425
但是我不会详细讨论.
This is something I wasn't gonna talk about in too much detail. 

489
00:33:49,425 --> 00:33:52,625
问题是,我在这里加了一些盐,那么它存储在哪里?
The question is, I provided the salt argument here, and where is that stored?

490
00:33:52,625 --> 00:33:58,550
答案是,它在这个输出的文件里面.
So, the answer is that that is stored in this output here. 

491
00:33:58,750 --> 00:34:05,175
因此,此输出文件存储了盐值和密文,
So, this output format stores both the salt and the actual output ciphertext, 

492
00:34:05,175 --> 00:34:07,900
它可以用于重构和解密.
so can be used in the reconstruction and decrypt. 

493
00:34:11,950 --> 00:34:12,900
是的,没错.
Yeah, that's correct. 

494
00:34:12,900 --> 00:34:14,975
它不需要任何数据库或其他东西.
It doesn't keep any database or anything. 

495
00:34:14,975 --> 00:34:16,525
它是自包含的.
This is fully self-contained. 

496
00:34:18,725 --> 00:34:19,405
是的,
Yeah, 

497
00:34:19,405 --> 00:34:22,025
正如John所说,盐并不是密码,
and as John says, the salt is not the secret, 

498
00:34:22,025 --> 00:34:26,375
口令才是秘密.
like the passphrase is what is the secret thing here. 

499
00:34:27,750 --> 00:34:30,375
好的,
Okay, 

500
00:34:31,475 --> 00:34:34,075
让我们回到问题.
so let's go back to the question. 

501
00:34:34,075 --> 00:34:35,505
什么是盐?
What is salt? 

502
00:34:35,505 --> 00:34:38,975
在哈希函数的背景下,
The idea of a cryptographic salt 

503
00:34:38,975 --> 00:34:42,815
加密盐的概念最好还是要解释一下.
is probably best explained in the context of hash functions. 

504
00:34:46,075 --> 00:34:50,400
哈希函数的一个常见应用是在数据库中存储密码.
So, one common application of hash functions is to store passwords in a password database. 

505
00:34:50,400 --> 00:34:55,500
如果我有一个网站,并且有用户会输入用户名和密码进行登录,
If I have a website and I have logins for users, like people log in with their username and password, 

506
00:34:55,575 --> 00:34:59,950
我不想以明文的形式存储人们的密码.
I don't actually want to store people's passwords in plain text just like as is. 

507
00:34:59,950 --> 00:35:07,350
有人知道我为什么不想这样做吗?
Does anybody know why I wouldn't want to do that?  

508
00:35:07,400 --> 00:35:09,425
是的.如果有攻击者获取了密码数据库,那会怎么样呢?
Yes, exactly.What if there was a breach and someone got all your data?

509
00:35:09,425 --> 00:35:12,561
所以,如果泄漏了所有用户的密码,那就真的很糟糕.
So, it's really bad if you leak all your users' passwords. 

510
00:35:12,561 --> 00:35:16,175
特别是许多人会在不同的网站上重复使用他们的密码.
It's especially bad because a lot of people reuse their passwords across different sites. 

511
00:35:16,175 --> 00:35:19,750
如果攻击者侵入一个网站,例如,前段时间雅虎的大规模泄露事件,
So, you'll see attackers break into one thing, like there was big Yahoo breach a while ago, 

512
00:35:19,750 --> 00:35:21,925
他们可能会找到所有的用户名和密码,
and they find all these usernames and passwords, 

513
00:35:21,925 --> 00:35:26,750
然后试图在Google,Facebook和YouTube等网站上使用这些相同的密码进行登录.
and then they go and try those same login credentials on Google and on Facebook and on YouTube and whatnot. 

514
00:35:26,750 --> 00:35:28,400
因为有些人会重复使用密码,
These people reuse passwords, 

515
00:35:28,775 --> 00:35:31,550
所以存储明文密码达咩.
so it's bad to store plaintext passwords. 

516
00:35:31,550 --> 00:35:35,299
为了保护账户安全,我们应该使用哈希函数
So, one thing you should do is you should store hashed passwords with a hash function, 

517
00:35:35,299 --> 00:35:39,775
或者是速度比较慢的密码哈希函数来存储加密后的密码.
or ideally a password hashing function that's intentionally designed to be slow. 

518
00:35:39,775 --> 00:35:43,449
一旦攻击者知道
But one thing attackers started doing 

519
00:35:43,449 --> 00:35:46,137
人们开始存储哈希密码之后,
once they realized that people started storing hashed passwords 

520
00:35:46,137 --> 00:35:48,725
攻击者开始做的一件事情就是构建所谓的"彩虹表".
is they built these things called rainbow tables. 

521
00:35:48,725 --> 00:35:53,281
攻击者会使用一些工具来生成可能的密码哈希映射数据库,
What people did was they took a way of generating big password lists,

522
00:35:53,281 --> 00:35:56,100
通常是基于一些密码模型来推断用户密码.
like the kind of model what passwords might look like. 

523
00:35:56,100 --> 00:36:01,925
例如,它将字典中的所有单词以及长度为 0 到 8 的字符串等全部进行哈希处理,
Say, take all the dictionary words, take all strings of like length from zero to eight and whatnot, take all of those and then hash them 

524
00:36:01,925 --> 00:36:03,732



525
00:36:03,732 --> 00:36:07,893
并将哈希值映射回原始密码,然后存储到数据库中.
and produce a big database mapping hashes back to their pre-image. 

526
00:36:07,893 --> 00:36:09,875
因此,给定一个哈希函数的输出,
And so given the output of a hash function, 

527
00:36:09,875 --> 00:36:12,325
不必像之前说的那么暴力尝试,
rather than have to like brute force said on the fly, 

528
00:36:12,325 --> 00:36:15,825
你可以去这个数据库中查找,"哦,对应于这个输出的输入是什么?"
you can just go look up in this database, "Oh, what is the input that corresponds to this output?" 

529
00:36:15,825 --> 00:36:19,500
实际上,有些攻击者已经针对相当大的真实密码数据库建立了彩虹表.
And people have built these for reasonably large password databases. 

530
00:36:19,675 --> 00:36:24,339
作为防御,你可以做的一件事是,
And so one thing that you can do in reaction to that as a defense 

531
00:36:24,339 --> 00:36:27,411
不是仅在你的数据库中存储密码的哈希值,
is rather than storing in your database.Rather than storing just the hash of the password, 

532
00:36:27,411 --> 00:36:33,400



533
00:36:33,400 --> 00:36:38,000
而是计算所谓的盐值.
what you do is you compute what's called a salt value. 

534
00:36:42,325 --> 00:36:45,000
这是一个长的随机字符串.
And what this is is a large random string. 

535
00:36:45,000 --> 00:36:50,025
然后,可以在密码数据库中存储盐,
And then what you do is you store in your password database the salt, 

536
00:36:50,025 --> 00:36:54,527
加密盐不是一个秘密,可以将盐值附加到密码后面再进行哈希处理,
which is not really a secret like you can store this in your password database

537
00:36:54,527 --> 00:37:02,875
然后把最终的哈希值存储在密码数据库中.
along with a hash of the password with the salt appended to it. 

538
00:37:03,225 --> 00:37:05,175
这有什么用处呢?
Why is this useful?

539
00:37:05,175 --> 00:37:09,075
这种盐是对于每个用户来说是随机唯一的.
Well, this salt is a random unique value for every user. 

540
00:37:09,075 --> 00:37:13,300
如果有人在两个网站上使用相同的密码"safe password one two three",
And so if someone has the password "safe password one two three" on two web service, 

541
00:37:13,300 --> 00:37:15,991
两个网站都直接对原始密码进行哈希并存储在数据库中,(这里假设使用相同的哈希函数)
if you are just storing the hash of the password, 

542
00:37:15,991 --> 00:37:18,359
则存储的哈希值在两个web服务器上都是相同的,对吧?
then the hash would be the same on both Web Services, right?

543
00:37:18,359 --> 00:37:20,407
因为这个哈希函数是一个确定性函数.
Because this hash function is a deterministic function. 

544
00:37:20,407 --> 00:37:23,671
但是现在,由于我们使用了这个随机的盐值,
But now, since we're using this randomized salt value, 

545
00:37:23,671 --> 00:37:27,511
我们存储了密码加上盐的哈希值.
we store the hash of the password plus the salt. 

546
00:37:27,511 --> 00:37:30,711
因此,即使有的人在多个网站上使用相同的密码,
And so even if someone's using the same password on multiple sites, 

547
00:37:30,711 --> 00:37:33,975
数据库里存储的密码看起来也都不同.
this thing looks different in both cases. 

548
00:37:33,975 --> 00:37:38,583
这个方案就会让彩虹表攻击不再有用.
And it makes it so these big databases mapping these short passwords or hash outputs to the short passwords that they came from, those are no longer useful. 

549
00:37:38,583 --> 00:37:42,551



550
00:37:42,551 --> 00:37:44,151



551
00:37:44,200 --> 00:37:45,975
当你的密码使用了加密盐的保护时,
When you have salted passwords, 

552
00:37:45,975 --> 00:37:48,850
攻击者需要为每个受攻击的用户和网站单独进行暴力破解,
you kind of need to do the brute-force attack for every user once you find their salt value, 

553
00:37:48,850 --> 00:37:50,850



554
00:37:50,850 --> 00:37:53,375
因为他们无法使用预先计算好的大型彩虹表.
rather than being able to use this big precomputed database. 

555
00:37:53,375 --> 00:37:57,340
这回答了什么是盐的问题吗?
Does that answer the question of what a salt is?

556
00:37:57,340 --> 00:38:01,300
那么,这些就是有关盐的一些事情.
And so that's what that salt argument is related to. 

557
00:38:07,325 --> 00:38:11,175
看看,对我们刚刚讲的有什么问题吗?
Let's see, any questions about anything we talked about so far? 

558
00:38:13,025 --> 00:38:17,319
好的,那么我要擦掉这个.
Great, okay, so the I'm gonna go ahead and erase this.

559
00:38:17,319 --> 00:38:20,952
然后我们最后要谈论的是
And then the last topic we'll talk about is 

560
00:38:20,952 --> 00:38:23,350
密码学中最令人兴奋的发展之一.
one of the most exciting developments of cryptography. 

561
00:38:23,350 --> 00:38:24,400
在很久很久以前就产生了这个概念,
Happen quite a while ago, 

562
00:38:24,425 --> 00:38:25,875
但放在现在也仍然非常酷,
but it's still a really cool concept, 

563
00:38:25,875 --> 00:38:28,400
即所谓的非对称加密.
something called asymmetric key cryptography. 

564
00:38:40,575 --> 00:38:44,423
这个想法,是现今许多安全和隐私相关的功能的基础
And so this is an idea that actually enables a lot of the security and privacy-related features of basically anything you use today. 

565
00:38:44,423 --> 00:38:49,100



566
00:38:49,100 --> 00:38:52,059
例如,当你要转到"www.google.com"时,
Like when you need to go and type in "www.google.com"

567
00:38:52,059 --> 00:38:55,500
非对称加密就会被用来保护你通信和数据传输安全.
asymmetric key cryptography is used as part of what goes on there. 

568
00:38:56,350 --> 00:39:00,573
这看起来与我们讲的对称加密非常相似,
So this is going to look pretty similar to what we talked about in symmetric key cryptography,

569
00:39:00,573 --> 00:39:02,045
但有一个区别.
except with a twist. 

570
00:39:04,225 --> 00:39:06,300
这里有一个密钥生成函数,
There's a key generation function,

571
00:39:06,300 --> 00:39:09,628
同样是随机的,但不是生成单个密钥,
which similarly is randomized but instead of producing a single key, 

572
00:39:09,628 --> 00:39:12,444
而是生成一对密钥,
it produces a pair of keys, two different things, 

573
00:39:15,994 --> 00:39:19,461
其中一个被称为公钥,
one of which is referred to as a public key 

574
00:39:21,986 --> 00:39:26,450
另一个被称为私钥.
and the other is referred to as a private key. 

575
00:39:26,450 --> 00:39:29,073
然后可以使用它们进行加密和解密,
And then these can be used for encryption and decryption 

576
00:39:29,073 --> 00:39:31,825
方式与对称加密类似,
in a manner kind of similar to symmetric key crypto, 

577
00:39:31,825 --> 00:39:34,550
但这俩密钥的用途不同.
except these different keys have different uses now. 

578
00:39:34,575 --> 00:39:40,800
现在我们有一个加密函数,我在这里放一个P,表示它是明文,
So we have an encryption function which takes in a plaintext, I'll write P here, 

579
00:39:40,800 --> 00:39:47,725
这个加密函数还要接受公钥,然后输出密文.
and it takes in the public key and produces the ciphertext. 

580
00:39:47,725 --> 00:39:50,700
然后我有一个解密函数,
And then I have a decryption function 

581
00:39:50,700 --> 00:40:01,250
它接收我的密文和私钥,并还原出明文.
which takes in my ciphertext and the private key and gives me back my plaintext. 

582
00:40:02,450 --> 00:40:07,630
与前面所讲的两个属性类似,
And then similarly to those two properties we had over there,

583
00:40:07,630 --> 00:40:09,934
仅凭密文,
given just the ciphertext,

584
00:40:09,934 --> 00:40:14,542
我们无法解密出明文,除非我们有私钥.
we can't figure out the plaintext unless we have the private key. 

585
00:40:14,600 --> 00:40:19,375
然后,我们也有一个显然正确的属性,如果我们用公钥加密某些东西,
And then we have the obvious correctness property that if we encrypt something with the public key, 

586
00:40:19,375 --> 00:40:21,200



587
00:40:21,200 --> 00:40:24,150
然后拿着那个密文
and then take that ciphertext and try decrypting it 

588
00:40:24,150 --> 00:40:27,734
尝试用相应的私钥来解密,
with the corresponding private key that came from this key generation process, 

589
00:40:27,734 --> 00:40:29,949
(公钥和私钥就是来自这个密钥生成函数的输出),
(That outputs these two different things at once)

590
00:40:29,949 --> 00:40:32,884
那么最终我将得到明文P.
then I get the same result back. 

591
00:40:35,050 --> 00:40:37,325
所以这非常类似于上面所说的对称加密,
So this is very similar to what's above, 

592
00:40:37,325 --> 00:40:40,950
但有一个不同的地方,我们有两个不同用处的密钥.
but there's a twist that we have these two different keys that have different functions. 

593
00:40:40,950 --> 00:40:46,000
有个很棒的事儿,这个公钥就像它的名字一样,可以进行公开,
It's really neat that this public key can actually be made, as the name indicates, public. 

594
00:40:46,000 --> 00:40:48,800
任何人都可以在互联网上使用非对称加密,
Like I could be using a crypto system that works like this, 

595
00:40:48,800 --> 00:40:51,800
然后发布一个公钥供任何人查看,
post a public key on the internet for anybody to see, 

596
00:40:51,800 --> 00:40:53,425
但保持私钥的私密性.
but keep my private key secret. 

597
00:40:53,425 --> 00:40:56,536
然后我有了这个有趣的属性,
And then I have this interesting property that anybody on the internet 

598
00:40:56,536 --> 00:41:01,016
任何人都可以使用我的公钥加密任何内容
can take any piece of content and encrypt it for me using my public key, 

599
00:41:01,050 --> 00:41:02,875
并通过互联网将其发送给我.
and send it over the internet to me. 

600
00:41:02,875 --> 00:41:05,150
然后我可以使用我的私钥解密它,
And then I can decrypt it using my private key, 

601
00:41:05,150 --> 00:41:07,750
只要我的私钥保持私密,
and as long as my private key stays secret, 

602
00:41:07,750 --> 00:41:11,014
任何人都可以使用我的公钥,这是无关紧要的.
it doesn't matter if my public key is available to anybody on the internet.

603
00:41:11,025 --> 00:41:13,475
这就是非对称性.
So here's where the asymmetry comes from. 

604
00:41:13,950 --> 00:41:18,800
之前,有这样一种情况,假设我在网上,
Before, we were in a scenario where, suppose I was on the internet, 

605
00:41:18,800 --> 00:41:21,325
你没有和我面对面交谈,
but you weren't like talking to me face-to-face, 

606
00:41:21,325 --> 00:41:24,450
你想在一些未加密的频道上,
and you wanted to send me some data over the internet over some 

607
00:41:24,450 --> 00:41:27,425
使用对称加密数据传送给我,
unencrypted channel where anybody could listen on what you were saying, and you wanted to use symmetric key cryptography. 

608
00:41:27,425 --> 00:41:29,625



609
00:41:29,625 --> 00:41:32,500
我们需要事先交换密钥,
Well, we need some way of exchanging a key in advance 

610
00:41:32,500 --> 00:41:36,084
然后你可以使用密钥加密一些纯文本,并将那个密文传输给我,
so that you could encrypt some plaintext with a key and give me that ciphertext over the internet

611
00:41:36,084 --> 00:41:38,725
然后我可以使用该密钥进行解密.
so that I could decrypt it with that key.

612
00:41:38,725 --> 00:41:43,675
在对称加密中,如果密钥被公开了,那么游戏就结束了,
In symmetric key crypto, if the keys public, it's game over, like anybody can decrypt your stuff. 

613
00:41:43,700 --> 00:41:46,000
任何人都可以解密你的东西.
Whereas in asymmetric key cryptography, 

614
00:41:46,000 --> 00:41:49,475
而在非对称加密中,我可以拿出我的公钥并将其张贴在互联网上的公告板上,
I could take my public key and post it on a bulletin board on the internet, 

615
00:41:49,475 --> 00:41:53,025
你可以使用公钥来加密一些内容,
and you can go look at that, take some contents and encrypt them for me, 

616
00:41:53,025 --> 00:41:54,175
然后在网上发放,
and then send them over, 

617
00:41:54,175 --> 00:41:55,800
这将是完全可以的,
and that would be totally fine. 

618
00:41:55,800 --> 00:41:58,125
但是这些内容只能使用私钥来解密.
You can only decrypt it with the private key.

619
00:41:58,125 --> 00:42:04,300
所以有一个比喻,是将这些数学思想与现实中的锁进行类比.
So one analogy that may be helpful is comparing these mathematical ideas to physical locks. 

620
00:42:04,300 --> 00:42:07,625
你的房门可能有一个锁,
You probably have a lock on your door to your house, 

621
00:42:07,625 --> 00:42:09,960
你可以用钥匙锁门,开门
and you can put in a key and like turn the thing in order to lock the door or you can turn it the other way to unlock the door. 

622
00:42:09,960 --> 00:42:12,968



623
00:42:12,975 --> 00:42:14,025
所以现在有一把的钥匙,
So there's a single key, 

624
00:42:14,025 --> 00:42:16,100
它既可以锁门也可以开门.
and it can both lock and unlock the door. 

625
00:42:16,100 --> 00:42:18,121
现在回到我们的情景上去,
But now consider this alternative construction,

626
00:42:18,121 --> 00:42:21,129
如果我想让你能够通过互联网发送向我发送一条消息
which you might use if, say, I want you to be able to send me a message and have it be sent over the internet, 

627
00:42:21,129 --> 00:42:23,753



628
00:42:23,753 --> 00:42:27,850
而且你和我之间不需要交换钥匙.
and you and I don't really need a way to exchange a key with you beforehand.

629
00:42:27,850 --> 00:42:30,200
我可以买一个盒子,你可以把信放在里面,
I could get a box which you could put a letter inside, 

630
00:42:30,200 --> 00:42:31,550
然后你可以关上盒子.
and you can close the box. 

631
00:42:31,550 --> 00:42:33,400
我可以买一个锁,
And I can get one of the padlock things, 

632
00:42:33,400 --> 00:42:38,392
我可以打开锁并把它给你.
which I can give you by I could like take those padlock and open it and give it to you. 

633
00:42:38,392 --> 00:42:42,296
你可以把你的信息放在盒子里,
And you, at your own leisure, could put your message inside a box 

634
00:42:42,296 --> 00:42:44,500
然后用这个打开的锁,
and take this padlock, which is open, 

635
00:42:44,775 --> 00:42:48,050
再把盒子锁上,然后将盒子发给我.
and shut it around the box and then send it over to me. 

636
00:42:48,050 --> 00:42:49,800
然后我可以用我的钥匙打开盒子.
And then I could put in my key and unlock it.

637
00:42:49,800 --> 00:42:53,362
从这里你能看到这种不对称性,
So do you see how there is this asymmetry there as opposed to the 

638
00:42:53,362 --> 00:42:55,250
与我用来打开我家门的钥匙不同,
key that I used to open the door to my house, 

639
00:42:55,250 --> 00:42:57,250
我家门只要用同一把钥匙就可以开关门.
where the same key opens and closes the thing? 

640
00:42:57,250 --> 00:43:01,775
而我给你这个打开的锁,你有能力关闭它但无法打开它.
Instead, I give you this open padlock that you have the ability to close but not open. 

641
00:43:01,775 --> 00:43:04,850
在你锁上之后,我可以使用我钥匙
And after you closed it, I can use my key, which I've kept secret, 

642
00:43:04,850 --> 00:43:07,175
来打开它并取出里面的东西.
in order to open the thing and retrieve what's inside. 

643
00:43:07,300 --> 00:43:09,450
这个比喻也许对你们理解有帮助,也许没有.
Maybe this analogy is helpful, maybe it's not. 

644
00:43:09,450 --> 00:43:12,625
如果你理解了数学原理,那么这个技术就可以很好地为你效劳.
The mathematical construction works just fine if that works for you.

645
00:43:12,625 --> 00:43:18,409
关于非对称加解密,
So any questions about asymmetric key encryption and decryption 

646
00:43:18,409 --> 00:43:22,925
以及它与对称加密的关系有什么问题吗?
and how it relates to symmetric key crypto, how it's a little bit different?

647
00:43:24,250 --> 00:43:27,753
在我们讨论非对称加密的应用之前,
So before we talk about applications of this idea, 

648
00:43:27,753 --> 00:43:33,900
我将先讲讲非对称加密中的另一组概念.
I'm going to talk about one other set of concepts in asymmetric key cryptography. 

649
00:43:33,900 --> 00:43:39,465
这些加密系统为你提供了些加密和解密的相关工具,
These crypto systems give you another set of tools which are related to encryption and decryption, 

650
00:43:39,500 --> 00:43:41,650
称为签名和验证.
something called signing and verifying. 

651
00:43:41,650 --> 00:43:44,600
这在一定程度上与现实世界有些类似,
And this is kind of similar to the real world like I can 

652
00:43:44,600 --> 00:43:46,975
我可以得到一份文件并签上我的大名.
get a document and sign it with my signature. 

653
00:43:46,975 --> 00:43:50,550
现实世界的签名相对容易伪造,
Except real-world signatures are, I don't think that hard to forge. 

654
00:43:50,550 --> 00:43:53,450
但是这里这些签名是相当难伪造的,因此更有用.
These are pretty hard to forge and, therefore, more useful. 

655
00:43:53,450 --> 00:43:57,522
签名方案是什么样的?
What do signature schemes look like?

656
00:43:57,522 --> 00:44:05,050
有一个函数"sign",它接收消息和私钥,
There's a function "sign" that takes us some message and the private key, 

657
00:44:07,150 --> 00:44:10,100
注意这是私钥,而不是公钥,
so notice this, this is the private key, not the public key, 

658
00:44:10,100 --> 00:44:12,350
它会生成一个签名.
and it produces a signature. 

659
00:44:14,150 --> 00:44:23,625
然后还有另一个函数"verify",它接收消息和签名
And then there's another function "verify" which takes in the message, the signature, 

660
00:44:23,750 --> 00:44:26,175
和..这次是公钥,
and the public key this time, 

661
00:44:31,875 --> 00:44:36,450
它会返回一个布尔值,告诉我签名是否正确.
and it tells me it returns a boolean whether or not the signature checks out. 

662
00:44:36,450 --> 00:44:42,431
然后这一对函数具有一些特性,
And then this pair of functions has the property that, again, 

663
00:44:42,431 --> 00:44:50,075
这些特性与现实里的签名和验证类似,
these are kind of properties that follow the intuition that come from physical signatures that, 

664
00:44:50,650 --> 00:44:55,167
即如果没有私钥,很难为任何消息产生一个签名,
without the private key, it's hard to produce a signature

665
00:44:55,167 --> 00:44:59,071
你就无法将消息和公钥一起提供给"verify"函数
for any message such that you can give the message in the signature 

666
00:44:59,071 --> 00:45:02,700
以获取返回值为 true.
and the public key to the "verify" function to get it to return true. 

667
00:45:02,700 --> 00:45:06,200
它很难被伪造.
Like at a high level, it's hard to forge. 

668
00:45:09,800 --> 00:45:13,775
没有私钥是很难伪造签名的.
It's hard to forge a signature, of course, without the private key. 

669
00:45:19,850 --> 00:45:22,705
然后也有显然正确的属性,
And then there's the obvious correctness property 

670
00:45:22,705 --> 00:45:27,697
即如果你使用公钥签署了一个东西,然后尝试使用相应的私钥进行验证,
that if you signed a thing with a public key and then try verifying it with the corresponding, 

671
00:45:27,700 --> 00:45:29,536
不好意思,应该是用私钥签署了一个东西,
sorry, if you sign a thing with the private key 

672
00:45:29,536 --> 00:45:31,584
然后尝试使用相应的公钥进行验证,
and try to verify it with the corresponding public key, 

673
00:45:31,584 --> 00:45:35,025
它将返回一个好的验证结果.
it returns okay that this verification checks out. 

674
00:45:36,725 --> 00:45:44,550
因此,这是非对称加密可以做的两件事.
So these are two different kinds of things you can do with asymmetric key crypto systems. 

675
00:45:44,550 --> 00:45:47,732
你可能听说过,
An example of an asymmetric key crypto system that you might have heard of 

676
00:45:47,732 --> 00:45:49,375
有一个叫RSA的非对称加密.
is something called RSA. 

677
00:45:49,375 --> 00:45:53,675
RSA是由许多人共同设计的,其中一人是Ron Rivest,他是这里的教授.
So RSA is designed by a number of people, one of whom is Ron Rivest who's a professor here. 

678
00:45:57,550 --> 00:46:01,556
实际上还有很多很有趣的非对称加密应用,
So there are a couple of interesting applications of asymmetric key crypto, 

679
00:46:01,556 --> 00:46:04,692
真要讲可能需要花上几天时间,
actually like tons and tons and tons of, you spend like days talking about this, 

680
00:46:04,692 --> 00:46:07,550
但其中有个例子是电子邮件加密.
but a couple examples are email encryption. 

681
00:46:07,550 --> 00:46:09,700
我们之前谈到了发送消息的一些事情.
So we talked a little bit about sending messages. 

682
00:46:09,700 --> 00:46:14,400
通过非对称加密,你可以在网上发布公钥.
What we can do with asymmetric key crypto is that you can have public keys posted online. 

683
00:46:14,400 --> 00:46:18,125
我认为一些教练在他们的网站上发布了PGP公钥.
I think some of the instructors have PGP public keys on their website. 

684
00:46:18,125 --> 00:46:21,800
例如,如果你访问我的网站或John的网站,你可以找到一个公钥.
So for example, you go to my website or John's website, you'll find a public key. 

685
00:46:21,800 --> 00:46:25,700
然后你可以发送给我们一个加密的电子邮件.
And then what you can do is you can send us an encrypted email. 

686
00:46:25,700 --> 00:46:30,775
即使该消息通过Gmail或其他电子邮件服务传递到MIT的邮件服务器,
And so even if that message goes through Gmail or whatever other mail service throughout MIT's mail servers, 

687
00:46:30,775 --> 00:46:33,783
如果有攻击者偷窥消息,
if there happens to be an attacker snooping on the messages,

688
00:46:33,783 --> 00:46:37,200
他们也无法理解其内容,因为它们都被加密了.
they can't make any sense of their contents because they're all encrypted. 

689
00:46:37,200 --> 00:46:40,759
这真的很酷,你可以做到这一点,
And this is really cool because you can do this without kind of

690
00:46:40,759 --> 00:46:43,215
而且你也无需亲自找到我们并交换密钥,
finding us in person and exchanging keys, 

691
00:46:43,215 --> 00:46:45,431
要是使用对称加密,你必须要交换密钥.
which you might have to do in a symmetric key crypto system. 

692
00:46:45,431 --> 00:46:49,200
但是现在你只要在网上找到我们的公钥,
You can just find our public key, which can be posted online without causing any issues, 

693
00:46:49,200 --> 00:46:51,425
然后发送加密邮件给我们.
and then send us encrypted email. 

694
00:46:51,425 --> 00:46:55,450
此外,非对称加密还可以用于私人通信.
Another thing asymmetric key crypto is used for is private messaging.

695
00:46:55,450 --> 00:46:57,434
如果你使用过
So raise your hand if you've used anything like

696
00:46:57,434 --> 00:47:01,675
类似Signal或Telegram或者WhatsApp(理论上支持端对端加密)的请举手,
signal or telegram or I think what's up is in theory antenna encrypted, 

697
00:47:01,675 --> 00:47:02,525
不错,很多人都用过了...
so a good number of you. 

698
00:47:03,150 --> 00:47:07,875
这些私人通信应用程序也使用
These private messaging applications also use asymmetric key crypto 

699
00:47:07,875 --> 00:47:10,600
非对称加密技术建立私人通信通道.
to establish private communication channels. 

700
00:47:10,600 --> 00:47:14,700
基本上,每个人都有一对密钥,
Basically, every person has associated with them a key pair, 

701
00:47:14,700 --> 00:47:17,475
你的设备会运行密钥生成函数
and so your device has run this key generation function 

702
00:47:17,475 --> 00:47:19,395
并生成了一个公钥和一个私钥,
produced a public key and a private key 

703
00:47:19,395 --> 00:47:22,250
并且自动将你的公钥发布到互联网上.
and automatically posted your public key to the internet. 

704
00:47:22,250 --> 00:47:25,700
例如,如果你使用Signal,你的公钥就在Signal服务器上,
So, for example, if you're using signal, your public key is on the signal servers, 

705
00:47:25,700 --> 00:47:27,725
当有人想要联系你时,
and then when someone wants to contact you,

706
00:47:27,725 --> 00:47:30,975
他们的手机可以查找你的公钥,
their phone can look up your public key, retrieve it, 

707
00:47:30,975 --> 00:47:34,050
一旦检索到你的公钥,他们就可以为你加密信息.
and once it's retrieved your public key, they can encrypt information for you. 

708
00:47:34,050 --> 00:47:36,300
他们算法大概就是这样工作的,
This is a kind of approximation of how their algorithm works, 

709
00:47:36,300 --> 00:47:38,100
概括来说,这就是实实在在发生的事情.
but at a high level that's what's going on.

710
00:47:38,550 --> 00:47:42,502
非对称密钥密码的另一个有趣应用是
Another neat application of asymmetric key crypto is 

711
00:47:42,502 --> 00:47:44,166
我们之前谈到的,
we were talking about earlier like 

712
00:47:44,166 --> 00:47:46,650
就是确保你从互联网上下载了正确的软件.
making sure you have the right software we downloaded from the internet. 

713
00:47:46,650 --> 00:47:50,125
非对称密钥密码可用于签署软件发布,
Asymmetric key crypto can be used to sign software releases, 

714
00:47:50,125 --> 00:47:52,486
这是人们在下载例如Debian软件包,
and this is something that people do for example like Debian packages

715
00:47:52,486 --> 00:47:56,262
或其他从互联网上下载的东西时所做的操作.
or whatever things you download from the internet. 

716
00:47:56,262 --> 00:47:59,475
开发人员会尝试签署他们的软件,以便你可以确保
The developer will try to sign their software so that you can make sure 

717
00:47:59,475 --> 00:48:01,107
从互联网上下载的任何东西
that whatever you've downloaded from the internet 

718
00:48:01,107 --> 00:48:03,750
都是来自正确的人.
is actually the right thing that came from the right person.

719
00:48:04,050 --> 00:48:08,100
我们在git的讲座中谈到了你可以使用git做的所有有趣的事情.
We talked about in the git lecture all the interesting things you can do with git. 

720
00:48:08,125 --> 00:48:12,875
但是我们没有涉及git中签名相关的功能.
One thing we didn't cover was signing related functionality and git. 

721
00:48:13,475 --> 00:48:16,400
所以git有提交,
So git has commits, 

722
00:48:16,400 --> 00:48:19,350
你可以将一些东西与提交关联起来,这被称为标签.
and you can associate with commits something called tags. 

723
00:48:19,350 --> 00:48:23,213
你可以将一个git提交与一个签名相关联,
At a high level, you can basically take a git commit and attach a signature to it

724
00:48:23,213 --> 00:48:27,400
将你的公钥绑定到此提交中,
which binds your public key to this commit, 

725
00:48:27,400 --> 00:48:29,485
然后任何拥有你的公钥的人
and then anybody who has your public key

726
00:48:29,485 --> 00:48:31,981
都可以使用此提交和你的公钥,
can take the commit and your public key 

727
00:48:31,981 --> 00:48:36,325
所以需要确保提交上有一个合法的签名.
and make sure that there's a legitimate signature on the commit.

728
00:48:39,500 --> 00:48:43,225
让我随便去个仓库看一下.
So let me go to like some random repository that I have. 

729
00:48:43,925 --> 00:48:47,750
我可以查看与仓库相关联的一些标签.
I can look at a bunch of tags associated with the repository. 

730
00:48:47,750 --> 00:48:53,741
如果我查看与该标签相关联的原始数据,
If I do look at the raw data associated with this tag, 

731
00:48:53,741 --> 00:49:02,150
它有一些元数据,然后是一段ascii码的信息块,
it has some metadata and then a blob of like ascii encoded information 

732
00:49:02,200 --> 00:49:06,733
我可以使用"git tag -v"命令来进行验证,
that I can use the "git tag -v" for verify command 

733
00:49:06,733 --> 00:49:11,469
以确保这就是来自于我.
to make sure that oh this is a good signature from this person happens to be me.

734
00:49:11,469 --> 00:49:14,733
所以我签署了软件发布,这样任何从互联网下载软件的人
so I sign the software release so that anybody who downloads it from the Internet 

735
00:49:14,733 --> 00:49:17,650
都可以确保他们实际上得到了真实的副本.
can make sure that they actually got an authentic copy.

736
00:49:17,650 --> 00:49:19,150
是的,问题?
Yes, question. 

737
00:49:28,550 --> 00:49:31,125
所以问题是
So the question is 

738
00:49:31,125 --> 00:49:35,025
"verify"函数具体是在做什么或者它检查什么?
what exactly is the verify function doing or what is it checking against? 

739
00:49:37,025 --> 00:49:42,375
如果你想在数学原理上了解具体是什么,可以在本讲座之后找我交流.
If you want to know mathematically what's going on, talk to me after this lecture. 

740
00:49:42,375 --> 00:49:45,840
从 API 的角度来看,
But from kind of an API perspective, what's going on here

741
00:49:45,840 --> 00:49:50,400
这里的签名和消息只是一组字节数据.
is that the signature and also the message here are just a blob of bytes, 

742
00:49:50,400 --> 00:49:53,520
这些数据基本上是这样的:
and it happens to be the case that these things are designed 

743
00:49:53,520 --> 00:50:00,225
对于某个特定的公钥,比如我的公钥,
such that basically if you take for some particular public key, like if you take my public key, 

744
00:50:00,225 --> 00:50:04,144
如果你没有我的私钥,
It's impossible for you, without knowledge of my private key,

745
00:50:04,144 --> 00:50:09,600
就不可能找到第二个钥匙使函数返回 true .
for any message to find a second argument to this function that makes it return true. 

746
00:50:09,600 --> 00:50:13,125
你可以将它类比为签署一份文件.
You can kind of compare it to signing a document. 

747
00:50:13,125 --> 00:50:15,075
就像你不知道如何伪造我的签名一样,
Like, you don't know how to forge my signature. 

748
00:50:15,075 --> 00:50:17,425
我可以在任何纸张上签名,
I can take any piece of paper and sign it, 

749
00:50:17,425 --> 00:50:20,208
然后任何知道我的签名样式的人,
and then anybody who knows what my signature looks like,

750
00:50:20,208 --> 00:50:23,050
可以查看我的文件,验证签名正确.
I can show my document - you can be like, yeah, that checks out. 

751
00:50:23,050 --> 00:50:26,864
但没有私钥的人,
But nobody without the private key can produce a signature 

752
00:50:26,864 --> 00:50:31,675
无法为任何消息产生一个使此函数返回 true 的签名.
that will make this function return true for any particular message. 

753
00:50:33,825 --> 00:50:38,450
还有问题吗?我是否需要用其他方式再解释一下?
And any related questions started, you want me to explain any other way, or does that make sense? 

754
00:50:50,775 --> 00:50:53,483
那么对于软件签名以及非对称加密的几种应用,
So, any questions about signing software or any of the other

755
00:50:53,483 --> 00:50:57,550
有什么问题吗?
handful of applications talked about of asymmetric key crypto?

756
00:50:59,050 --> 00:51:04,575
好的,最后我想谈谈密钥分发.
Well, so one final thing I want to talk about, we're almost out of time, is key distribution. 

757
00:51:04,575 --> 00:51:08,150
这是非对称加密的一个有趣的方面.
This is a kind of interesting side effect of asymmetric key cryptography. 

758
00:51:08,150 --> 00:51:12,325
它可以实现许多有趣的功能,比如我可以在互联网上发布我的公钥,
It enables a bunch of interesting functionality like I can post my public key on the internet. 

759
00:51:12,325 --> 00:51:14,350
你可以找到它并给我发加密邮件.
You can go find it and send me encrypted email. 

760
00:51:14,350 --> 00:51:17,637
但你怎么知道找到的公钥实际上是我的公钥?
But how do you know that the public key found is actually my public key? 

761
00:51:17,637 --> 00:51:20,625
这似乎存在一个引导问题,对吗?(在数字安全和加密领域,引导问题通常是指如何在没有预共享密钥和信任基础的情况下建立安全通信渠道的问题)
It seems like there's a bootstrapping problem here, right? 

762
00:51:20,625 --> 00:51:26,085
所以,这就像一个非常有趣但是有些困难的现实世界问题,
So, this is like a really interesting and really hard real-world problem, 

763
00:51:26,085 --> 00:51:30,350
可能有这么几种方法来解决这个问题.
and there are a couple different approaches you might take to this problem.

764
00:51:30,350 --> 00:51:32,861
第一种是有点糟糕的解决方案,
One is kind of a lame solution, 

765
00:51:32,861 --> 00:51:35,300
但它可以解决许多密码学问题.
but this thing solves a lot of cryptography problems. 

766
00:51:35,300 --> 00:51:37,475
就是在非网络渠道交换信息,
This exchange the information out-of-band. 

767
00:51:37,475 --> 00:51:40,625
也就是你想给我发加密邮件,
What that means is, you want to send me encrypted email, 

768
00:51:40,625 --> 00:51:42,250
你直接下课后来找我,
we'll just talk to me after class. 

769
00:51:42,250 --> 00:51:44,575
我会给你一张纸条上面写着我的公钥,
I'll give you my public key on a piece of paper, 

770
00:51:44,575 --> 00:51:47,967
由于你亲自与我交谈,你知道这确实就是我的公钥,
and since you were talking to me in person, you know that it's actually my public key,

771
00:51:47,967 --> 00:51:51,295
而不是有人黑进我的网站,放上的一些虚假信息.
not just somebody like hacked my website and stuck some random number on there. 

772
00:51:51,350 --> 00:51:52,700
这样可以解决问题,
That solves the problem, 

773
00:51:52,700 --> 00:51:53,850
但不太优雅.
but it's not the most elegant.

774
00:51:53,850 --> 00:51:56,425
还有几种不同的方法,不同的应用程序使用不同的方法.
There are a couple other approaches that different applications use. 

775
00:51:56,425 --> 00:51:58,300
比如,使用 Signal 的人们,
So, those of you who use signal,

776
00:51:58,300 --> 00:52:01,884
你们有没有遇到过"safety number"这个短语?
have you ever encountered the phrase "safety number" 

777
00:52:01,884 --> 00:52:04,060
或是"用..来验证你的safety number"?
like "verify your safety number with so and so"? 

778
00:52:04,060 --> 00:52:08,653
对于 Signal,他们有一种交换公钥的方法,
So, with signal, they have a way of exchanging public keys 

779
00:52:08,653 --> 00:52:10,300
就是通过 Signal 服务器.
which is through the signal servers. 

780
00:52:10,300 --> 00:52:13,376
运行 Signal 服务的人只需在其服务器上
Whoever runs the signal service just maintains on their servers 

781
00:52:13,376 --> 00:52:15,800
维护一个从电话号码到公钥的映射.
basically a mapping from phone numbers to public keys. 

782
00:52:15,800 --> 00:52:18,300
当我说"我要给这个号码的人发消息"时,
And when I say, "Oh, I want to message this person with this number", 

783
00:52:18,300 --> 00:52:20,800
我的手机会从互联网上检索他们的公钥,
my phone just goes and retrieves their public key from the internet 

784
00:52:20,800 --> 00:52:23,075
然后用该公钥加密消息.
and then encrypts the message for that public key.

785
00:52:23,125 --> 00:52:30,925
现在,有人对这个设置有什么问题吗?
Now, does anybody see a problem with the setup?  

786
00:52:34,950 --> 00:52:37,875
是的,正是如此.Signal 服务器是保证安全性的关键点,
Yeah, exactly. The signal servers are the point of failure there 

787
00:52:37,875 --> 00:52:41,175
因为如果 Signal 服务器给我错误的公钥,
because if the signal servers give me the wrong public key, 

788
00:52:41,175 --> 00:52:44,915
比如假设 Signal 只是生成了一对新的密钥,并给我这个新生成的公钥,
like suppose signal just produces a new key pair and give me their public key,

789
00:52:44,915 --> 00:52:46,451
那他们就可以读取我所有的消息,
now they can read all my messages. 

790
00:52:46,451 --> 00:52:50,547
他们甚至可以在我和我的朋友之间,透明地解密我发送给他们的消息,
And they could even sit in between and transparently decrypt the messages I send them 

791
00:52:50,547 --> 00:52:53,225
然后重新加密并发送到最终目的地.(这种攻击方式被称为"中间人攻击")
and then re-encrypt them and send them on to their final destination. 

792
00:52:53,225 --> 00:52:57,500
所以我需要某种方法来验证我获得的公钥,
Like, basically, I need some way of authenticating the public key I get.

793
00:52:57,500 --> 00:53:03,850
因此,Signal有一个解决方案,本质上还是线下交换密钥.
And so, signal has one solution to this, which is also just kind of punting the issue to out-of-band key exchange. 

794
00:53:03,850 --> 00:53:04,650
你可以与某个人见面,
You can meet up with somebody, 

795
00:53:04,650 --> 00:53:08,600
他们有一个稍微简化的流程,可以在屏幕上显示二维码.
and they have a slightly streamlined flow where they show QR codes on the screen. 

796
00:53:08,600 --> 00:53:11,000
你可以拿一部手机拍下二维码的图片,反之亦然,
You take one phone and take a picture of the other phone screen,  and vice versa,  

797
00:53:11,000 --> 00:53:13,375
现在你已经交换了公钥.
and now you've exchanged public keys in person. 

798
00:53:13,375 --> 00:53:14,650
从那时起,
And from that point on,

799
00:53:14,650 --> 00:53:17,100
你已经启动了加密的端到端通信.
You've bootstrap your encrypted end-to-end communication. 

800
00:53:17,725 --> 00:53:22,475
它还有一个方法,即固定公钥.
It also has an issue of, or it also has an approach of, pinning a public key. 

801
00:53:22,475 --> 00:53:26,187
一旦你知道一个特定的电话号码有一个特定的公钥,
So once you know that a particular phone number has a particular public key, 

802
00:53:26,187 --> 00:53:27,275
你的手机就会记住它,
your phone remembers that, 

803
00:53:27,275 --> 00:53:29,750
如果发生更改,它就会向你发出警告.
and if that ever changes, it'll complain to you. 

804
00:53:30,175 --> 00:53:33,075
然后还有几个解决这个问题的方法.
And then there are a couple of other solutions to this problem. 

805
00:53:33,075 --> 00:53:35,975
PGP是一个曾经流行过的解决方案,
PGP, one popular solution used to be popular a while ago,

806
00:53:35,975 --> 00:53:37,550
它有一个"信任网"的概念.
has this idea of a web of trust. 

807
00:53:37,550 --> 00:53:39,475
就像,我信任我朋友信任的人.
So, like, I trust people who my friends trust. 

808
00:53:39,475 --> 00:53:41,607
所以如果John和我的教授进行了一次线下交换,
So if John has done an out-of-band exchange with, 

809
00:53:41,607 --> 00:53:44,975
那么我可以向我的教授发送电子邮件,
say, my professor, then I can probably email my professor because, 

810
00:53:44,975 --> 00:53:47,375
因为我知道John信任我的教授,而我信任John.
like, I know that John trusts my professor and I trust John. 

811
00:53:47,375 --> 00:53:49,150
所以你可以通过这种方式建立信任链.
So you got this chain of trust through there. 

812
00:53:49,150 --> 00:53:50,550
这是一种有趣的方法.
That's one interesting approach. 

813
00:53:50,550 --> 00:53:52,625
还有另一种模型,最近非常火,
And then another model that's called pretty recently, 

814
00:53:52,625 --> 00:53:55,075
是一种叫做"key base"工具,
as something that a tool called key bases.

815
00:53:55,075 --> 00:54:03,475
有一个叫做"keybase.io"的网站,
This is a really neat whoops, there's a website called keybase.io, 

816
00:54:03,475 --> 00:54:07,950
他们有一个非常有趣的解决方案,叫做社会证明.
and they have a really interesting solution to this bootstrapping problem, which is social proof. 

817
00:54:07,950 --> 00:54:11,875
比如说,你可能在Facebook和Twitter上有你的朋友,
So saying you probably have your friends on Facebook and on Twitter and whatnot, 

818
00:54:11,875 --> 00:54:14,807
对于攻击者来说
and it's probably pretty hard for an attacker 

819
00:54:14,807 --> 00:54:18,250
同时入侵你朋友的Facebook账号,Twitter账号以及Hacker News账号等等,
to break into your friend's Facebook account at the same time as their Twitter account, 

820
00:54:18,250 --> 00:54:20,500
是非常非常困难的
at the same time as their hacker news account,  and so on.  

821
00:54:20,500 --> 00:54:21,790
因此,有一种有趣的方式,
And so there's this interesting way

822
00:54:21,790 --> 00:54:25,310
将公钥绑定到一组社交身份上,
of binding public keys to a set of social identities 

823
00:54:25,310 --> 00:54:27,297
如果你相信某个社交身份与你的朋友相对应,
such that you can retrieve a public key

824
00:54:27,297 --> 00:54:31,800
那么你可以通过这个社交身份来获取公钥.
once you trust some number of social identities corresponding to your friend. 

825
00:54:32,025 --> 00:54:36,300
如果你想要更详细地了解这些内容,我们在讲义中提供了链接.
We have links to these in the lecture notes if you want to see these things in more detail. 

826
00:54:36,300 --> 00:54:40,200
这就是我们的安全和密码学讲座,
So that's it for our security and cryptography lecture, 

827
00:54:40,200 --> 00:54:43,350
明天的讲座将讲一些
and tomorrow's lecture will be on a random collection of topics 

828
00:54:43,350 --> 00:54:45,050
我们认为很有趣的话题.
that your instructors find interesting. 

829
00:54:45,050 --> 00:54:48,025
希望明天在讲座上见到你们.
So hopefully, see you in lecture tomorrow. 

830
00:54:51,700 --> 00:54:54,850
如果有任何问题,我会在课后呆上几分钟.
I'll also be here for a couple of minutes after class if anybody has questions. 

831
00:55:05,825 --> 00:55:07,100
好的,
Yes, okay, 

832
00:55:07,100 --> 00:55:09,600
John,如果你要走,请随意.
so John, feel free to leave if you have to leave, 

833
00:55:09,600 --> 00:55:11,050
但我想没有人在我们之后使用这个教室.
but I think nobody's using the classroom after us. 

834
00:55:11,050 --> 00:55:13,475
噢,我还想谈谈另一个有趣的话题.
I'm going to talk about one other interesting topic. 

835
00:55:13,475 --> 00:55:18,368
John提到非对称加密速度慢,
So John brought up the fact that asymmetric key cryptography is slow

836
00:55:18,368 --> 00:55:20,875
对称加密速度快的事实.
and symmetric key cryptography is fast. 

837
00:55:20,875 --> 00:55:27,200
因此,在实践中,你可以不仅仅使用非对称加密.
And so in practice, you don't really use just asymmetric key cryptography by itself. 

838
00:55:27,200 --> 00:55:33,575
通常情况下,非对称加密用于启动你正使用的更复杂的协议.
It's usually used to bootstrap a more sophisticated protocol that you're using. 

839
00:55:37,575 --> 00:55:39,100
你可能想使用非对称加密来签名加密邮件,对吧?
One thing you might want to do is use asymmetric key cryptography for signing encrypted email, right?

840
00:55:39,100 --> 00:55:41,596



841
00:55:41,596 --> 00:55:43,400



842
00:55:43,400 --> 00:55:45,075
我们已经讲过了这个例子.
We talked about that example. 

843
00:55:45,075 --> 00:55:46,600
实际上的工作原理
And the way that works 

844
00:55:46,600 --> 00:55:51,144
并不像我所讲的那样简单.
isn't what you might have guessed from our straightforward explanation of asymmetric key crypto. 

845
00:55:51,144 --> 00:55:54,550
你不能只是使用上面的加密函数就结束了.
Like, you don't just use that encrypt function up there and call it a day. 

846
00:55:54,550 --> 00:55:56,617
实际上,
In practice, what you do is 

847
00:55:56,617 --> 00:55:58,985
你所要做的是使用混合加密技术,
you use hybrid encryption

848
00:55:58,985 --> 00:56:08,850
结合对称加密和非对称加密.
to use a combination of symmetric key and asymmetric key cryptography. 

849
00:56:08,975 --> 00:56:13,175
这里,我会画一个大的图.
What you do is, here, I'll draw this as a big block diagram. 

850
00:56:13,175 --> 00:56:14,925
这是你要发送的信息m,
You take your message m, 

851
00:56:14,925 --> 00:56:22,375
然后用我所拥有的公钥进行加密.
and then I have my public key that I want to encrypt for. 

852
00:56:22,375 --> 00:56:23,579
但是,
But rather than just 

853
00:56:23,579 --> 00:56:26,840
与其将这两个信息直接通过那里的加密函数加密,
take these two things and pass it through the encryption up there, 

854
00:56:26,840 --> 00:56:39,575
实际上,你需要使用对称密钥生成函数来产生一个对称密钥.
what I do is I use the symmetric key gen function to produce a symmetric key. 

855
00:56:41,125 --> 00:56:43,775
好的,我会在开头加上"symmetric(对称)"这个词,
Okay, I'm gonna, like, prepend this with "symmetric"

856
00:56:43,775 --> 00:56:47,065
以便我们可以将其与非对称的密钥生成函数区分开来.
so we can distinguish it from the public key key generation function. 

857
00:56:47,425 --> 00:56:50,367
然后我将这两个东西通过对称加密
And then what I do is I take these two things, 

858
00:56:50,367 --> 00:56:53,875
传递给我的对称加密盒子.
pass them through my symmetric encryption box. 

859
00:57:02,325 --> 00:57:05,275
这将产生密文,
This produces the ciphertext, 

860
00:57:08,325 --> 00:57:13,300



861
00:57:13,300 --> 00:57:16,564
这个加密后的内容
And now this by itself to the sender. Sorry, this by itself to the receiver who has the private key 

862
00:57:16,564 --> 00:57:19,764
对拥有公钥的接收者来说并没有什么用处,
corresponding to this public key here, this is not really useful, right? 

863
00:57:19,825 --> 00:57:23,924
因为它用的是本地的对称密钥生成函数
Because this is encrypted with a symmetric cipher with this key K 

864
00:57:23,924 --> 00:57:29,450
产生的密钥K进行对称加密的.
that came from this function that I ran on my local machine. 

865
00:57:29,450 --> 00:57:34,100
因此,我需要某种方式将这个对称密钥K发给用于解密邮件的人.
So I need some way of getting this to the person who actually used to decrypt the email. 

866
00:57:34,100 --> 00:57:38,975
因此,我将K单独拿出来.这个邮件可能很大,
And so what I do is I take this thing. And now this email might have been big, 

867
00:57:38,975 --> 00:57:42,150
所以我使用对称加密将其加密.
and I use symmetric encryption with that because symmetric encryption is fast. 

868
00:57:42,150 --> 00:57:45,600
但是这个密钥很小,可能只有256位,
But this key is small, like it might be 256 bits or something, 

869
00:57:45,600 --> 00:57:50,975
所以我可以用公钥对它进行非对称加密,
so I can take this thing and encrypt it with asymmetric encryption using the public key, 

870
00:58:04,575 --> 00:58:07,675
这样就可以生成一个加密密钥.
and this gives me an encrypted key. 

871
00:58:07,825 --> 00:58:12,867
因为那个公钥,这个加密密钥可以使用相应的私钥来解密,
And this thing can be decrypted using the private key corresponding to that public key to reconstruct this. 

872
00:58:12,867 --> 00:58:16,625



873
00:58:16,850 --> 00:58:19,175
这是在发送者端进行的.
So this is on the sender's end. 

874
00:58:19,175 --> 00:58:24,195
现在,接收者获得这个密钥,将倒序进行以下步骤:
Now, the receiver gets this and this and kind of does these things backwards. 

875
00:58:24,195 --> 00:58:25,566
因此,你从加密密钥开始,
So you start with the encrypted key

876
00:58:25,566 --> 00:58:30,430
使用与发布的公钥对应的私钥
and use asymmetric decryption using your public using your private key that

877
00:58:30,430 --> 00:58:32,432
来解密这个加密密钥得到K,
corresponds to the posted public key  to reconstruct this key that were used for the symmetric encryption box, 

878
00:58:32,432 --> 00:58:36,175



879
00:58:36,175 --> 00:58:40,368
然后使用刚刚解出来的对称密钥K
and then use symmetric key decryption using that key that was reconstructed 

880
00:58:40,368 --> 00:58:44,675
结合密文还原出原始消息.
to take this ciphertext and produce the original message. 

881
00:58:44,775 --> 00:58:48,011
因此,这是对称和非对称加密
So there's a kind of interesting example of how

882
00:58:48,011 --> 00:58:52,325
在实践中结合的有趣例子.
in practice symmetric and asymmetric key cryptography is combined. 

883
00:58:54,500 --> 00:58:55,000
问题?
Question?

884
00:59:00,475 --> 00:59:05,450
那么问题是,在这里你会使用相同的对称密钥生成器吗?
So the question is, will you be using the same symmetric key generators?

885
00:59:07,300 --> 00:59:13,425
是的.因此,你需要事先协商在此处使用哪个盒子(也就是使用哪个加密算法啦~).
Yes. Okay, so you need to kind of agree ahead of time which box you're using here. 

886
00:59:13,425 --> 00:59:19,475
例如,你可能会说,我将在这里使用AES-256-GCM,
So you might be like, oh, I'm going to use AES-256-GCM up here, 

887
00:59:19,475 --> 00:59:22,525
但这是一个众所周知的函数,
but this is a well-known function, 

888
00:59:22,525 --> 00:59:24,000
它是公开的.
and it's public. 

889
00:59:24,000 --> 00:59:26,975
攻击者可以知道此函数的所有参数.
Like the attackers allowed to know all the parameters this function. 

890
00:59:26,975 --> 00:59:31,050
这是攻击者不知道的唯一秘密.
This is the only secret thing that the attacker doesn't know, the key. 

891
00:59:31,775 --> 00:59:40,550
还有其他问题吗?是的,那是一个非常好的问题.
Any other questions? Yeah, that's a really good question. 

892
00:59:40,550 --> 00:59:42,790
什么样的数据值得加密?
What kind of data is important enough to encrypt?

893
00:59:42,790 --> 00:59:47,075
我认为这取决于你的威胁模型.
And I think that depends on your threat model. 

894
00:59:47,075 --> 00:59:49,085
你担心什么样的攻击者?
Like, who, what kind of attackers are you concerned about?

895
00:59:49,085 --> 00:59:51,325
你想保护什么?
What are you trying to protect against? 

896
00:59:51,325 --> 00:59:55,175
或者,你可能认为你根本什么都不在意,
So you might have the stance that you just don't really care, 

897
00:59:55,175 --> 00:59:58,125
你与任何人的通信都可以公开.
and that like anything you communicate with anybody is allowed to be public. 

898
00:59:58,125 --> 01:00:03,925
我愿意将我与每个人的所有对话公开发布到互联网上供所有人查看.
I might be willing to post all my conversation with everybody for everybody to see publicly on the Internet. 

899
01:00:03,925 --> 01:00:06,805
另一方面,
On the other hand, maybe you're doing some 

900
01:00:06,805 --> 01:00:08,597
也许你正在从事一些非常注重安全性的工作,
like security-sensitive works here, 

901
01:00:08,597 --> 01:00:10,901
比如为美国政府签订合同,
working under a contract for the US government, 

902
01:00:10,901 --> 01:00:13,150
开发一些敏感的军事项目等等.
developing some sensitive military stuff. 

903
01:00:13,150 --> 01:00:15,575
如果你在旅行中通过公共互联网发送这些信息,
If you're sending that through the open Internet while you're traveling, 

904
01:00:15,575 --> 01:00:18,069
你可能希望非常确定
you probably want to be pretty darn sure that no

905
01:00:18,069 --> 01:00:21,205
没有窃听者或其他人能够看到你发送的内容,
eavesdroppers or anybody else along the way can see what you're sending, 

906
01:00:21,205 --> 01:00:23,575
并且你发送的信息确实到达了正确的位置,
and that whatever you're sending is in fact going to the right place, 

907
01:00:23,575 --> 01:00:27,325
并且接收方能够验证该信息确实来自你.
and that whoever is receiving it can authenticate that it in fact came from you. 

908
01:00:28,500 --> 01:00:32,469
因此,根据你的情况不同,你会担心各种不同类型的对手,
So you might be worried about all different kinds of adversaries depending on your scenario, 

909
01:00:32,469 --> 01:00:33,749
从脚本小子
from random script kiddies 

910
01:00:33,800 --> 01:00:37,425
到国家级攻击者,
who are trying to break into websites to nation-state level attackers, 

911
01:00:37,425 --> 01:00:42,075
你需要不同类型的技术来防御不同类别的攻击者.
and you'll need different types of techniques for defending against the different categories of attackers. 

912
01:00:44,625 --> 01:00:51,875
还有其他问题吗?
Any other questions?

913
01:00:51,875 --> 01:00:58,400
好的,希望明天能看到你们,明儿会讲一些我们仨讲师都感兴趣的主题,这些主题之间比较跳跃.
Well, so hopefully, see some of you tomorrow for a random collection of things that John, Jose,  and I find interesting. 

