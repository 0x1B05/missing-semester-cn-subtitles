1
00:00:00,400 --> 00:00:04,175
大家好，让我们开始下一堂课。
All right everyone let's get started with the next lecture. 

2
00:00:04,175 --> 00:00:08,450
今天我们将解决元编程的主题，
So, today we're gonna tackle the topic of meta programming, 

3
00:00:08,450 --> 00:00:10,375
这个标题有点奇怪。
and this title is a little weird. 

4
00:00:10,375 --> 00:00:12,975
我们并没有完全清楚元编程的含义。
It's not entirely clear what we mean by meta programming. 

5
00:00:12,975 --> 00:00:16,200
我们在命名这个讲座时想不出更好的名字，
We couldn't really come up with a better name for this lecture 

6
00:00:16,200 --> 00:00:18,750
因为这个讲座是关于
because this lecture is about the processes 

7
00:00:18,750 --> 00:00:22,925
你在使用软件时所进行的工作周围的过程，
that surround the work that you do when working with software. 

8
00:00:22,925 --> 00:00:27,600
不一定是编程本身，而是关于这个过程的内容。
It is not about programming itself necessarily but about the process. 

9
00:00:27,600 --> 00:00:32,850
这可能涉及到如何构建你的系统、如何进行测试、
This can be things like how your system is built, how it's tested, 

10
00:00:32,850 --> 00:00:35,500
如何添加软件依赖等等，
how you add dependencies to your software, 

11
00:00:35,500 --> 00:00:37,625
这些内容在构建较大的软件时
that sort of stuff that becomes really relevant 

12
00:00:37,625 --> 00:00:40,000
变得非常重要，
 when you build larger pieces of software, 

13
00:00:40,000 --> 00:00:43,575
但它们本身并不是编程。
but they're not really programming in and of themselves.

14
00:00:43,575 --> 00:00:50,050
所以，我们这堂课首先要讨论的是构建系统的概念。
So, the first thing we're going to talk about in this lecture is the notion of build systems. 

15
00:00:50,050 --> 00:00:56,322
有多少人使用过构建系统或知道它是什么？好的，
So, how many of you have used a build system before or know what it is? Okay, 

16
00:00:56,322 --> 00:00:57,400
大约有一半的人。
so about 1/2 of you. 

17
00:00:57,400 --> 00:01:06,150
那么对于其余的人来说，构建系统的核心思想是，你正在编写一篇论文、
So, for the rest of you, the central idea behind a build system is that you're writing a paper, 

18
00:01:06,150 --> 00:01:10,425
编写软件、或者在学习某个课程，无论是哪种情况，
you're writing software, you're working on a class, whatever it might be, 

19
00:01:10,425 --> 00:01:15,100
你都有一堆命令，你可能把它们写在你的 shell 历史记录中，
and you have a bunch of commands that you like either written down in your shell history 

20
00:01:15,100 --> 00:01:17,311
或者在某个文档中记下来，
or you wrote them down in a document somewhere 

21
00:01:17,311 --> 00:01:20,061
你知道如果想要完成特定的任务，必须运行这些命令序列。
that you know you have to run if you want to do a particular thing. 

22
00:01:20,061 --> 00:01:22,695
例如，有一系列的命令需要按顺序运行，
So, for example, there are a sequence of commands 

23
00:01:22,695 --> 00:01:26,120
以便构建你的论文或论文的 PDF 版本，
so you need to run in order to build your paper or build your thesis 

24
00:01:26,120 --> 00:01:30,100
或者只是运行当前课程的测试。
or just to run the tests for whatever class you're currently in, 

25
00:01:30,100 --> 00:01:36,875
构建系统的想法是，你想把这些规则编码成一个工具，
and a build system sort of idea is that you want to encode these rules for what commands 

26
00:01:36,875 --> 00:01:41,800
这个工具可以为你完成这些任务。
to run in order to build particular targets into a tool that can do it for you.

27
00:01:41,800 --> 00:01:46,375
特别是，你要教这个工具了解
And in particular, you're going to teach this tool about the dependencies

28
00:01:46,375 --> 00:01:49,250
构建不同工件之间的依赖关系。
 between those different artifacts that you might build. 

29
00:01:49,250 --> 00:01:54,975
有许多不同类型的这种工具，
There are a lot of different types of tools of this kind, 

30
00:01:54,975 --> 00:01:58,750
许多是针对特定目的、特定语言构建的。
and many of them are built for particular purposes, particularly languages. 

31
00:01:58,750 --> 00:02:02,200
有些是用于构建论文，
Some of them are built for building papers, 

32
00:02:02,200 --> 00:02:03,875
有些是用于构建软件，
some of them are built for building software, 

33
00:02:03,875 --> 00:02:09,200
有些是用于特定的编程语言，比如 Java 或某些其他的语言。
some of them are built for particularly programming languages like Java or some. 

34
00:02:09,200 --> 00:02:13,025
有些工具甚至内置了构建工具，
Some tools even have built-in tools for builds. 

35
00:02:13,025 --> 00:02:17,100
例如 NPM，如果你做过 Node.js 开发，
So, NPM, for example, you might be aware if you've done Node.js development, 

36
00:02:17,100 --> 00:02:22,250
可能就知道它具有跟踪依赖项
has a bunch of built-in tools for doing tracking of dependencies and building them 

37
00:02:22,250 --> 00:02:24,325
和构建依赖项的内置工具。
and building all of the dependent stuff of your software.

38
00:02:24,325 --> 00:02:27,825
但更一般地说，这些被称为构建系统，
But more generally, these are known as build systems, 

39
00:02:27,825 --> 00:02:32,300
在它们的核心中，它们都有一些共同的功能。
and at their core, they all function in a very similar way. 

40
00:02:32,300 --> 00:02:35,300
它们有许多目标，
And that is, you have a number of targets. 

41
00:02:35,300 --> 00:02:37,750
这些目标是你想要构建的东西，
These are the things that you want to build. 

42
00:02:37,750 --> 00:02:40,400
比如 paper.pdf，
These are things like paper dot PDF, 

43
00:02:40,400 --> 00:02:46,575
但它们也可以是更抽象的东西，比如运行测试套件或构建程序的二进制文件。
but they can also be more abstract things like run the test suite or build the binary for this program. 

44
00:02:46,575 --> 00:02:48,400
然后，你有一堆依赖项，
Then you have a bunch of dependencies, 

45
00:02:48,400 --> 00:02:53,150
依赖项是需要构建的东西，以便构建这个目标
and dependencies are things that need to be built in order for this thing to be built. 

46
00:02:53,200 --> 00:02:56,820
然后你有一些规则，
And then you have rules that define how do you go from 

47
00:02:56,820 --> 00:02:59,950
规定如何从完整的依赖项列表中得到目标文件。
a complete list of dependencies to the given target. 

48
00:03:00,000 --> 00:03:04,325
举个例子，如果要构建我的paper.pdf，
So, an example of this might be, in order to build my paper.pdf, 

49
00:03:04,325 --> 00:03:08,100
我需要一些绘图图像，
I need a bunch of like plot images. 

50
00:03:08,100 --> 00:03:09,200
它们将被嵌入到论文中，
They're gonna go into the paper, 

51
00:03:09,200 --> 00:03:10,400
因此需要构建它们。
so they need to be built. 

52
00:03:10,400 --> 00:03:14,875
但是一旦它们被构建，如何使用这些文件来构建论文呢？
But then once they have been built, how do I construct the paper given those files?

53
00:03:14,900 --> 00:03:16,225
这就是规则的作用。
So that is what a rule is. 

54
00:03:16,225 --> 00:03:19,000
它是一系列命令，你需要运行它们才能完成从一个文件到另一个文件的转换。
It's a sequence of command, so you run to get from one to the other. 

55
00:03:19,100 --> 00:03:23,525
如何编码这些规则因不同的工具而异。
How you encode these rules differs between different tools. 

56
00:03:23,525 --> 00:03:26,725
在这门课程中，我们将关注一种叫做make的工具。
In this particular class, we're gonna focus on a tool called make. 

57
00:03:26,725 --> 00:03:31,925
make是一种几乎可以在今天登录的任何系统上找到的工具。
Make is a tool that you will find on almost any system that you log in today. 

58
00:03:31,925 --> 00:03:36,650
比如，它会在Mac OS上，基本上所有的Linux和BSD系统上找到，
Like, it'll be on Mac OS, it'll be on basically every Linux and BSD system, 

59
00:03:36,650 --> 00:03:39,100
而且你也可以很容易地在Windows上获取它。
and you can pretty easily get it on Windows. 

60
00:03:39,100 --> 00:03:42,425
它不适用于非常复杂的软件，
It's not great for very complex software, 

61
00:03:42,425 --> 00:03:47,225
但对于任何简单到中等复杂度的东西都可以很好地工作。
but it works really well for anything that's sort of simple to medium complexity.

62
00:03:47,225 --> 00:03:52,250
当你在命令行上运行make命令时，
Now, when you run make to make user command, you can run on the command line, 

63
00:03:52,250 --> 00:03:55,700
如果目录为空
and when you type make and this is an empty directory,

64
00:03:55,700 --> 00:04:00,600
并且没有指定目标并且找不到makefile，它就会停止。
if I type make, it just has no target specified and no make file found, stop. 

65
00:04:01,375 --> 00:04:04,100
它会告诉你已经停止运行，
And so it helpfully tells you that it stopped running, 

66
00:04:04,100 --> 00:04:07,500
但也会告诉你找不到makefile。
but also tells you that no make file was found. 

67
00:04:07,500 --> 00:04:12,125
make将在当前目录中查找一个名为Makefile的文件，
Make will look for a file literally called Makefile in the current directory, 

68
00:04:12,125 --> 00:04:15,675
这就是你编码这些目标、依赖项和规则的地方。
and that is where you encode these targets, dependencies,  and rules.  

69
00:04:15,700 --> 00:04:17,650
所以，让我们试着写一个makefile吧。
So, let's try to write one. 

70
00:04:17,650 --> 00:04:20,825
假设我正在写这篇假想的论文，
Let's imagine that I'm writing this hypothetical paper, 

71
00:04:20,825 --> 00:04:22,800
所以我要创建一个Makefile，
and so I'm gonna make a Makefile, 

72
00:04:22,800 --> 00:04:26,100
在这个Makefile中，我将声明我的paper.pdf
and then in this Makefile, I'm going to say that my paper.pdf, 

73
00:04:26,100 --> 00:04:28,600
是由paper.tex、
the hands-on, that's what the colon here indicates. 

74
00:04:28,600 --> 00:04:33,200
plotdata.png
paper.tex was going to be a little attack file, 

75
00:04:33,200 --> 00:04:37,050
这两个文件构建而来，
and plot-data.png, 

76
00:04:37,100 --> 00:04:44,200
构建这个文件的命令是使用PDF latex命令。
and the command in order to build this is going to be pdflatex paper.tex.

77
00:04:44,500 --> 00:04:48,425
对于那些不熟悉这种构建文档的方式的人来说，
So, for those of you who are not familiar with this particular way of building documents, 

78
00:04:48,425 --> 00:04:53,300
TeX是一种非常方便的文档编程语言。
the tex is a really handy programming language for documents. 

79
00:04:53,325 --> 00:04:55,900
它是一种非常难看的语言，
It's a really ugly language, 

80
00:04:55,900 --> 00:04:57,175
使用起来很麻烦，
and it's a pain to work with, 

81
00:04:57,175 --> 00:04:58,900
但它可以产生很好的文档。
but it produces pretty nice documents. 

82
00:04:58,900 --> 00:05:05,325
而将TeX文件转换成PDF的工具就是PDF latex。
And the tool you use to go from a tech file to PDF is pdf latex. 

83
00:05:05,325 --> 00:05:12,005
这里我需要用到一个plot数据的PNG文件，
And here, I'm saying that I also depend on this plot-data.png 

84
00:05:12,005 --> 00:05:13,775
这个文件将会被包含在我的文档中。
that's gonna be included in my document. 

85
00:05:13,900 --> 00:05:18,675
我想要表达的是，如果这两个依赖关系中的任意一个发生了变化，
And what I'm really saying here is if either of those two dependencies change, 

86
00:05:18,675 --> 00:05:20,575
我希望生成paper PDF文件。
I want you to build paper.pdf. 

87
00:05:21,075 --> 00:05:25,175
这两个文件都需要存在，如果它们发生了变化，我希望重新生成。
They both need to be present,  and should they ever change, I wanted to rebuild it.  

88
00:05:25,350 --> 00:05:29,375
但我并没有告诉它如何生成这个plot数据的PNG文件，
But I haven't really told it how to generate this plot-data.png, 

89
00:05:29,375 --> 00:05:31,400
因此我可能还需要一个规则。
so I might want a rule for that as well.

90
00:05:31,400 --> 00:05:34,250
因此，我在这里定义了另一个目标，
So, I'm gonna define another target here, 

91
00:05:34,250 --> 00:05:40,975
它的样子是这样的：plot - %，
and it's gonna look like this: plot - % ,and % means make, 

92
00:05:40,975 --> 00:05:42,825
然后%代表任意字符串，
and make is any string, 

93
00:05:42,825 --> 00:05:44,550
可以理解为通配符模式。
sort of a wildcard pattern. 

94
00:05:44,550 --> 00:05:49,450
但是，很酷的一点是，当你在依赖关系中重复这个模式时，
But the cool thing is as you go and repeat this pattern in the dependencies, 

95
00:05:49,450 --> 00:05:58,040
我可以说，plot - %.png将依赖于%.data或debt，
so I can say that plot - %.png is going to depend on %.data or debt, 

96
00:05:58,040 --> 00:06:02,125
这是一种常见的数据文件后缀。
that is a common sort of suffix for data files.

97
00:06:03,375 --> 00:06:07,750
它还将依赖于一些脚本，这个脚本将实际为我绘制这个图形，
And it's also going to depend on some script that's gonna actually plot this for me, 

98
00:06:07,750 --> 00:06:11,100
而从一个文件格式到另一个文件格式的规则可以是多行的，
and the rules for to go from one to the other, these can be multiple lines, 

99
00:06:11,100 --> 00:06:13,650
但在我这个特定的例子中，只有一行。
but in my particular case, they're just one line. 

100
00:06:13,650 --> 00:06:19,400
我会在接下来的时候解释这是什么意思。
I'm gonna explain what this is in a little second. 

101
00:06:19,400 --> 00:06:22,727
好的，所以在这里，我们要说的是，
Alright,  so here we're gonna say that in order to

102
00:06:22,727 --> 00:06:27,525
为了从通配符点点文件（与目标中的通配符匹配）
 go from a wildcard dot dot file that matches the wildcard in the target  

103
00:06:27,525 --> 00:06:33,341
和plot.py文件转换，运行python文件，并且使用-i参数，
and a plot.py file, run the python file with - i 

104
00:06:33,341 --> 00:06:37,050
这类似于我们在python文件中标记输入的方式。
which is going to be like the way we take the mark what the input is in our python file. 

105
00:06:37,050 --> 00:06:38,175
稍后我会向您展示它。
I'll show it to you later. 

106
00:06:38,175 --> 00:06:43,135
$*是一个为您定义的特殊变量，
$* is a special variable that is defined for you 

107
00:06:43,135 --> 00:06:46,800
可以匹配任何百分号。
and make file rules that matches whatever the percentile was. 

108
00:06:47,025 --> 00:06:51,727
因此，如果我做plot/.foo.png，那么它将查找foo.dat，
So, if I do plot/.foo.png, then it's going to look for foo.dat

109
00:06:51,727 --> 00:06:54,300
它的星号可以扩展为foo。
and it $* can expand to foo. 

110
00:06:54,325 --> 00:06:57,900
所以，这将产生与我们在此处匹配的文件名相同的文件名，
So, this will produce the same file name as the one we matched here 

111
00:06:57,900 --> 00:07:02,550
而$@是一个特殊变量，表示目标的名称，对吧？
and $@ as a special variable that means the name of the target, right? 

112
00:07:02,550 --> 00:07:03,900
所以，输出文件，
So, the output file, 

113
00:07:04,575 --> 00:07:07,425
希望plotter py会获取这里的任何数据，
 and hopefully what plot.py will do 

114
00:07:07,425 --> 00:07:11,950
它将以某种方式生成PNG文件，
is that it will take whatever the data is here, it will produce a PNG somehow, 

115
00:07:11,950 --> 00:07:16,700
并将其写入由dollar all指示的文件中，对吧？
and it will write it into the file indicated by the $@, right? 

116
00:07:17,075 --> 00:07:18,850
现在我们有了一个make文件。
So now we have a make file. 

117
00:07:18,850 --> 00:07:23,050
让我们看看如果这个目录中唯一的文件是make文件，而我们运行make会发生什么。
Let's see what happens if the only file in this directory is the make file,  and we run make.  

118
00:07:23,050 --> 00:07:29,114
它会说："no rule to make target paper.tex needed by paper.pdf，stop。"
One says no rule to make target paper.tex needed by paper.pdf, stop. 

119
00:07:29,114 --> 00:07:35,925
所以，它在这里所表达的是，首先，它查看了我们文件的第一条规则，也就是第一个目标，
So, what it's saying here is, first of all, it looked at the first rule of our file, the first target, 

120
00:07:35,925 --> 00:07:40,100
当你没有给make任何参数时，它会尝试构建第一个目标。
and when you give make no arguments, it tries to build whatever the first target is. 

121
00:07:40,100 --> 00:07:42,150
这被称为默认目标。
This is known as the default goal. 

122
00:07:42,150 --> 00:07:45,700
因此，在这种情况下，它试图为我们有用地构建paper.pdf文件，
So, in this case, it tried to helpfully build paper.pdf for us, 

123
00:07:45,700 --> 00:07:47,400
然后查找它的依赖关系，
and then it looked up the dependencies, 

124
00:07:47,400 --> 00:07:51,525
它说：“为了构建paper.pdf，我需要paper.tex
and it said, well, in order to build paper.pdf, I need paper.tex, 

125
00:07:51,525 --> 00:07:53,650
和这个PNG文件。
and I need this PNG file. 

126
00:07:53,650 --> 00:07:55,300
我找不到paper.tex的文件，
And I can't find paper.tex 

127
00:07:55,300 --> 00:07:59,425
也没有生成paper.tex的规则，
and I don't have a rule for generating paper.tex, 

128
00:07:59,450 --> 00:08:00,750
因此我要退出。
and therefore I'm gonna exit. 

129
00:08:00,750 --> 00:08:02,875
我无能为力了。
This isn't nothing more I can do. 

130
00:08:05,275 --> 00:08:07,675
所以，让我们尝试在这里创建一些文件。
So, let's try to make some files here. 

131
00:08:07,675 --> 00:08:12,850
我们可以创建一个空的paper.X文件，然后输入make命令。
Let's just make like an empty paper.tex and then type make. 

132
00:08:12,850 --> 00:08:17,950
现在它会显示“paper to PDF”需要plot-data.PNG文件，但是没有相关规则。
So now it says no rule to make target plot-data.png needed by paper to PDF, right? 

133
00:08:17,950 --> 00:08:20,200
现在它知道它有一个依赖项，
So now it knows that it has one dependency, 

134
00:08:20,200 --> 00:08:21,575
但它不知道如何获取另一个依赖项。
but it doesn't know how to get the other one. 

135
00:08:21,575 --> 00:08:24,000
它知道有一个与之匹配的目标，
It knows it as a target that matches, 

136
00:08:24,000 --> 00:08:26,600
但实际上找不到依赖项，
but it can't actually find its dependencies, 

137
00:08:26,600 --> 00:08:28,500
所以它最终什么都没有做。
and so it ends up doing nothing at all. 

138
00:08:29,400 --> 00:08:35,000
它仍然需要我们为PNG的输入生成这个PNG文件。
It still needs us to generate this PNG for the input for the PNG. 

139
00:08:35,000 --> 00:08:38,600
因此，让我们实际上在这些文件中添加一些有用的内容。
So, let's actually put some useful stuff into these files. 

140
00:08:38,600 --> 00:08:48,425
幸运的是，我之前从plot.da.py中获得了一个，
Let's say that luckily I have one from earlier plot.py to here, 

141
00:08:48,725 --> 00:08:49,875
所以很好。
so let's so good. 

142
00:08:49,875 --> 00:08:51,950
那么，这个文本文件是文本的样子。
Well, this text file is what text looks like. 

143
00:08:51,950 --> 00:08:53,025
它不是很漂亮，
It's not very pretty, 

144
00:08:53,025 --> 00:08:55,275
但是我定义了一个空文档。
but see, I'm defining an empty document. 

145
00:08:55,275 --> 00:08:59,725
我将包含图形，这是包含图像文件的方式。
I'm going to include graphics, which is the way you include an image file. 

146
00:08:59,725 --> 00:09:01,875
我将包含plot-data.PNG，
I'm going to include plot-data.png, 

147
00:09:01,875 --> 00:09:07,450
这当然是为什么我们希望paper.PDF的依赖项是PNG文件。
and this is of course why we want a dependency of paper.pdf to be the PNG file. 

148
00:09:07,450 --> 00:09:11,050
plot.py也不是很有趣。
plot.py is also not very interesting. 

149
00:09:11,050 --> 00:09:13,475
它只是导入了一堆库。
It just imports a bunch libraries. 

150
00:09:13,475 --> 00:09:16,125
它解析了-i和-o参数。
It parses the - i and - o arguments. 

151
00:09:16,200 --> 00:09:19,800
它从-i参数中加载数据。
It loads data from the -i argument. 

152
00:09:19,800 --> 00:09:26,825
它使用了一个称为matplotlib的库，这对于快速绘制数据非常方便。
It uses library called matplotlib, which is very handy for just quickly plotting data. 

153
00:09:26,825 --> 00:09:33,300
它将数据的第一列绘制为X轴，第二列绘制为Y轴。
And it's going to plot the first column of the data as X's and the second column of the data as Y's. 

154
00:09:33,300 --> 00:09:37,375
因此，我们只需要一个每行都有两列X和Y的数据文件，
So, we're just going to have a data file that's two columns, X and Y on every line, 

155
00:09:37,375 --> 00:09:44,000
然后将其保存为给定的-oh值的图像。
and then it saves that as a figure into whatever the given - o values. 

156
00:09:45,975 --> 00:09:54,175
因此，我们需要一个命名为data.dat的数据文件，因为我们需要plot-data.png，
So we need a data file that's going to be data.dat because we want plot-data.png, 

157
00:09:54,175 --> 00:09:57,364
而我们的规则指定了从该模式到点文件的方式，
and our rules said that the way you go from that pattern to

158
00:09:57,364 --> 00:10:01,600
即按照plot之后的内容来确定点文件的名称。
 the .file, the . that file is just by whatever follows plot. 

159
00:10:01,650 --> 00:10:05,600
因此，如果我们需要plot-data，则我们需要data.dat文件。
So if we want plot-data, then we want data.dat

160
00:10:05,600 --> 00:10:09,050
然后这个文件，我们只是要把它放入一些线性坐标，因为为什么不呢？
And then this file, we're just gonna put in some linear coordinates because why not? 

161
00:10:09,050 --> 00:10:12,300
那不是线性的。好的。
That's not linear.  All right.  

162
00:10:12,875 --> 00:10:20,950
现在，如果我们要做什么，嗯，好的，
And now, what happens if we're gonna make, well, mmm, okay, 

163
00:10:20,950 --> 00:10:31,275
那么刚刚发生了什么？嗯，make首先用正确的文件运行plot.py生成PNG文件，
so what just happened? Well, make first ran plot.py with the correct files to generate the PNG file, 

164
00:10:31,275 --> 00:10:34,400
然后它运行pdf latex paper.tex，
and then it ran pdf latex paper.tex, 

165
00:10:34,400 --> 00:10:37,625
我们下面看到的所有内容都是该工具的输出。
and all the stuff we see below is the output from that tool. 

166
00:10:37,625 --> 00:10:40,200
如果你想的话，我们可以消除这个工具的输出，
If you wanted to, we silence the effort from this tool, 

167
00:10:40,200 --> 00:10:42,800
这样我们就不必让它干扰我们的所有输出，
so we don't have to like have it mess with all our output, 

168
00:10:42,800 --> 00:10:46,490
但是通常情况下，你会注意到它运行了两个命令，
but in general, you notice that it ran the two commands, then it wrote the random, 

169
00:10:46,490 --> 00:10:48,850
然后以正确的顺序写入了随机值。
perhaps unsurprisingly, in the right order. 

170
00:10:49,000 --> 00:10:52,727
如果我们现在在当前目录下运行ls，我们会发现我们有一堆文件
And if we now do ls in the current directory, we see that we have a bunch of files 

171
00:10:52,727 --> 00:10:55,300
是由pdf latex生成的，
that were generated by pdf latex, 

172
00:10:55,350 --> 00:10:59,500
但特别的是，我们有生成的PNG文件
but in particular, we have the PNG file which was generated, 

173
00:10:59,500 --> 00:11:01,100
和paper.pdf。
and we have the paper.pdf. 

174
00:11:01,100 --> 00:11:06,325
如果我们打开paper.pdf文件，我们会看到它有一个图像，其中有一条直线，
And if we open the paper.pdf file, we see that it has one image which has the straight line, 

175
00:11:06,325 --> 00:11:10,175
也许本身并不是一个非常令人惊讶或有趣的结果，
perhaps in and of itself not a very surprising or interesting result, 

176
00:11:10,175 --> 00:11:18,600
但这真的非常方便，我可以做一些像如果我再次输入make，make只是说paper.pdf是最新的。
but where this gets really handy is I can do things like if I type make again, make just says paper.pdf is up to date. 

177
00:11:18,600 --> 00:11:20,300
它不做任何工作。
It does no work. 

178
00:11:20,300 --> 00:11:26,500
每当你运行make时，它尝试以最小的工作量来产生你要求的任何东西。
Whenever you run make, it tries to do the minimal amount of work in order to produce whatever you ask it to produce. 

179
00:11:26,500 --> 00:11:29,725
在这种情况下，没有任何依赖项发生变化，
In this case, none of the dependencies have changed, 

180
00:11:29,725 --> 00:11:33,625
因此没有重建paper或重建图。
so there's no reason to rebuild the paper or to rebuild the plot. 

181
00:11:33,625 --> 00:11:39,222
现在假设我要编辑paper.tex，
If I now let's say I'm gonna edit paper.tex, 

182
00:11:39,222 --> 00:11:44,150
我要在这里添加hello，现在做make，
I'm gonna add hello here and now make, 

183
00:11:44,150 --> 00:11:49,700
然后如果我们向上滚动，我们会看到它没有再次运行plot.py，因为我不需要它。
then if we scroll up, we'll see it didn't run plot.py again because I didn't need to. 

184
00:11:49,700 --> 00:11:50,875
没有依赖项发生变化，
None of the dependencies changed, 

185
00:11:50,875 --> 00:11:52,750
但它确实再次运行了pdf latex。
but it did run pdf latex again. 

186
00:11:52,750 --> 00:11:56,600
如果我们打开paper，分析hello在那里。
And indeed, if we open the paper, analysis hello over there. 

187
00:11:56,600 --> 00:12:05,319
另一方面，如果我改变数据文件，然后把这个点改为每小时8美元，
On the other hand, if I were to change say the data file and make this point 8 an hour and make,

188
00:12:05,319 --> 00:12:08,525
然后再做，那么现在它会重新绘制图形，因为数据发生了改变，
 then now it plots again because the data changed, 

189
00:12:08,525 --> 00:12:12,025
并且它会重新生成PDF，因为图形发生了改变。
and it regenerates the PDF because the plot changed. 

190
00:12:12,025 --> 00:12:15,775
确实，这篇论文的结果是我们预期的。
And indeed, the paper turns out the way we expected it to. 

191
00:12:15,775 --> 00:12:21,725
所以这并不是说这个特定的管道非常有趣，因为它不是。
So that's not to say that this particular pipeline is very interesting because it's not. 

192
00:12:21,725 --> 00:12:25,725
它只对非常非常简单的目标和规则有效。
It's only true very, very straightforward targets and rules. 

193
00:12:25,725 --> 00:12:28,048
但是当你开始构建更大的软件或可能存在依赖关系时，
But this can come in really handy 

194
00:12:28,048 --> 00:12:31,625
这会非常有用。
when you start building larger pieces of software or there might be dependencies. 

195
00:12:31,700 --> 00:12:33,850
你甚至可以想象，如果你在写论文，
You might even imagine that if you're writing a paper, 

196
00:12:33,850 --> 00:12:39,800
你的一个目标可能是首先生成这个数据文件，对吧？
one of your targets might be producing this data file in the first place, right? 

197
00:12:39,800 --> 00:12:45,325
因此，其中一个makefile目标可能是运行我的实验，对吧？
So one of the makefile targets might be run my experiment, right? 

198
00:12:45,325 --> 00:12:50,450
运行我的基准测试并将输出的数据点放入此文件中，
Run my benchmark and stick the data points that come out into this file 

199
00:12:50,450 --> 00:12:51,975
然后绘制结果，
and then plot the results 

200
00:12:51,975 --> 00:12:56,025
一直到最终论文完成。
and then and then and then and then all the way until you end up with a final paper. 

201
00:12:56,025 --> 00:13:01,250
这样做的好处是，首先你不必记住运行所有命令的方式，
And what's nice about this is, first of all, you don't have to remember all the commands to run. 

202
00:13:01,250 --> 00:13:02,925
也不必在任何地方写下来，
You don't have to write them down anywhere, 

203
00:13:02,925 --> 00:13:07,450
工具会处理最少量的工作量。
but also the tool takes care of doing the minimal amount of work needed. 

204
00:13:08,350 --> 00:13:10,850
通常情况下，你会发现有些事情也太麻烦了。
Often you'll find things like they'll be too. 

205
00:13:10,850 --> 00:13:14,325
例如，还有子命令需要执行，如 make tests，
There'll be sub-commands to make, like make tests, right? 

206
00:13:14,325 --> 00:13:18,588
它会编译整个软件并运行测试。
Which is going to compile your entire piece of software and also run the tests. 

207
00:13:18,675 --> 00:13:20,700
还可能有像 make release 这样的东西，
There might be things like make release, 

208
00:13:20,700 --> 00:13:23,800
它会打开优化并创建一个 tarball 
which builds it with optimizations turned on

209
00:13:23,800 --> 00:13:27,375
并将其上传到某个地方。
 and creates a tarball and uploads that somewhere, right? 

210
00:13:27,375 --> 00:13:29,300
因此，它会为你完成整个流程。
So it's gonna do the whole pipeline for you. 

211
00:13:29,300 --> 00:13:34,500
这样做的目的是减少构建过程中你必须做的工作量。
The idea is to reduce the effort that you have to do as any part of your build process.

212
00:13:37,350 --> 00:13:43,900
现在我们看到了一个非常简单的依赖示例，对吧？
Now what we saw here was a very straightforward example of dependencies, right? 

213
00:13:43,900 --> 00:13:46,775
我们看到了你可以将文件声明为依赖项，
So we saw here that you could declare files as dependencies, 

214
00:13:46,775 --> 00:13:49,450
但你也可以声明传递依赖项。
but you can also declare sort of transitive dependencies. 

215
00:13:49,450 --> 00:13:52,450
当你在更大的软件领域中处理依赖项时，
I depend on this thing which is generate by the other targer

216
00:13:52,550 --> 00:13:57,775
通常会发现你的系统最终会有许多不同类型的依赖项。
Very often when you work with dependencies in the larger area of software, 

217
00:13:57,775 --> 00:14:03,343
其中一些是
you'll find that your system ends up having many different types of dependencies. 

218
00:14:03,343 --> 00:14:05,450
像我们在这里看到的文件，
Some of these are files like we saw here, 

219
00:14:05,450 --> 00:14:08,958
有些是程序，
some of them are programs, like this 

220
00:14:08,958 --> 00:14:12,975
比如这个程序隐含依赖于 Python 在我的机器上安装。
sort of implicitly depends on Python being installed on my machine. 

221
00:14:13,000 --> 00:14:14,535
有些可能是库，
Some of it might be libraries, 

222
00:14:14,535 --> 00:14:19,375
比如你可能依赖于像 matplotlib 这样的东西，我们在这里也依赖于它。
like you might depend on something like matplotlib, which we depend on here. 

223
00:14:19,375 --> 00:14:22,090
有些可能是系统库，如 OpenSSL
Some of them might be system libraries like OpenSSL 

224
00:14:22,090 --> 00:14:25,750
 或 OpenSSH 或低级密码库，
or OpenSSH or like low-level crypto libraries, 

225
00:14:26,550 --> 00:14:29,250
你不一定要声明所有这些依赖项。
and you don't necessarily declare all of them.

226
00:14:34,026 --> 00:14:38,425
通常情况下，
what you find it that for most places where you have dependences 

227
00:14:38,425 --> 00:14:40,850
有一些工具可以帮助你管理这些依赖项。
there are tools for managing denpendences for you

228
00:14:40,850 --> 00:14:46,900
而且，这些你可能依赖的系统通常存储在所谓的存储库中。
And very often, these systems you might depend on are stored in what are known as repositories. 

229
00:14:47,075 --> 00:14:54,050
存储库只是一组通常相关的事物，你可以安装它们。
So a repository is just a collection of things usually related that you can install. 

230
00:14:54,050 --> 00:14:56,450
这基本上就是存储库的全部内容，
That's basically all a repository is, 

231
00:14:56,450 --> 00:14:59,250
你可能已经熟悉其中的一些，对吧？
and you might be familiar with some of them already, right? 

232
00:14:59,250 --> 00:15:02,100
存储库的一些示例包括 PyPI，
So some examples of repositories are PyPI, 

233
00:15:02,100 --> 00:15:06,125
这是一个众所周知的 Python 包存储库，RubyGems，
which is a well-known repository for Python packages, RubyGems, 

234
00:15:06,125 --> 00:15:11,750
这是 Ruby 的类似存储库，crates.io 是 Rust 的存储库，NPM 是 Node.js 的存储库，
which is similar for Ruby, crates.io for Rust, NPM for Node.js, 

235
00:15:11,750 --> 00:15:14,700
但其他东西也有存储库，对吧？
but other things have repositories too, right? 

236
00:15:14,750 --> 00:15:18,675
例如，有加密密钥的存储库，如 Keybase，
Like there are repositories for cryptographic keys like Keybase, 

237
00:15:18,675 --> 00:15:22,671
有系统安装包的存储库，
there are repositories for system-installed packages 

238
00:15:22,671 --> 00:15:26,700
如果你在 Ubuntu 或 Debian 中使用 apt 工具，
like if you ever use the apt tool in Ubuntu or in Debian, 

239
00:15:26,725 --> 00:15:29,038
则正在与一个包存储库交互，
you are interacting with a package repository 

240
00:15:29,038 --> 00:15:32,586
人们上传他们编写的程序和库，
where people who have written programs and libraries upload them 

241
00:15:32,586 --> 00:15:34,425
以便你可以安装它们。
so that you can then install them. 

242
00:15:34,900 --> 00:15:38,925
同样地，你可能会有完全开放的仓库，
Similarly, you might have repositories that are entirely open, 

243
00:15:38,925 --> 00:15:44,150
比如说 Ubuntu 仓库通常由 Ubuntu 开发人员提供，
so the Ubuntu repositories, for example, are usually provided by the Ubuntu developers, 

244
00:15:44,175 --> 00:15:48,375
但是在 Arch Linux 中，可能会有一个叫做 Arch 用户仓库的地方，
but in Arch Linux, there might be something called the Arch User Repository 

245
00:15:48,375 --> 00:15:52,725
用户可以自己共享他们自己的库和软件包。
where users can just share their own libraries and their own packages themselves.

246
00:15:52,725 --> 00:15:57,875
仓库往往要么是受管理的，要么完全开放的，
Very often, repositories are either sort of managed or they are just entirely open, 

247
00:15:57,875 --> 00:16:02,200
你应该经常意识到这一点，因为如果你使用完全开放的仓库，
and you should often be aware of this because if you're using an entirely open repository, 

248
00:16:02,200 --> 00:16:07,100
你从中得到的安全保证可能会比从受控制的仓库中得到的少。
maybe the security guarantees you get from that are less than what you get in a controlled repository. 

249
00:16:08,000 --> 00:16:13,800
如果你开始使用仓库，你会注意到一个问题，那就是很多软件都有版本号。
One thing you'll notice if you start using repositories is that very often software is versioned. 

250
00:16:13,800 --> 00:16:19,375
我所说的版本，你可能已经在像浏览器这样的东西中看到过了，对吧？
And what I mean by version, well, you might have seen this for stuff like browsers, right? 

251
00:16:19,375 --> 00:16:21,200
其中可能有一些像 
Where there might be something like 

252
00:16:21,200 --> 00:16:35,775
Chrome 版本 64.0.2019.0324 这样的东西，
starting like Chrome version 64.0.2019o324, right? 

253
00:16:36,650 --> 00:16:38,450
这是一个版本号。
This is a version number. 

254
00:16:38,450 --> 00:16:45,175
它可能有一个点，这是一种版本号。
It might, there's a dot here, this is one kind of version number. 

255
00:16:45,250 --> 00:16:50,225
但有时候，如果你开始使用 Photoshop 
But sometimes, if you start, I don't know, like Photoshop, 

256
00:16:50,225 --> 00:16:57,475
或其他工具，可能会有其他种类的版本号，比如 8.1.7，
or you start any other tool, there might be other kinds of versions that are, like, 8.1.7, right? 

257
00:16:57,525 --> 00:17:00,375
这些版本号通常是数字的，但并不总是这样。
These version numbers are usually numerical,  but not always.  

258
00:17:00,475 --> 00:17:03,475
有时候它们会在其中添加哈希值，例如为了引用 Git 提交。
Sometimes they have hashes in them, for example, to refer to Git commits. 

259
00:17:03,525 --> 00:17:05,650
你可能会问，为什么我们需要这些版本号？
But you might wonder, why do we have these? 

260
00:17:05,725 --> 00:17:09,425
为什么在发布软件时添加版本号如此重要呢？
Why is it even important that you add a number to software that you release? 

261
00:17:09,425 --> 00:17:13,525
主要原因是它让我们能够知道
The primary reason for this is because it enables me 

262
00:17:13,525 --> 00:17:17,625
软件是否会出现故障。
 to know whether my software would break. 

263
00:17:17,625 --> 00:17:22,925
想象一下，我依赖于Jose编写的一个库，
Imagine that I have a dependency on a library that Jose has written, right? 

264
00:17:22,925 --> 00:17:27,700
而Jose一直在对他的库进行更改以使它更好。
And Jose is constantly doing changes to his library because he wants to make it better. 

265
00:17:27,700 --> 00:17:31,700
他发现库中公开的一个函数的名称很烂，
And he decides that one of the functions that his library exposes has a bad name, 

266
00:17:31,700 --> 00:17:32,875
他决定更改。
so he renames it. 

267
00:17:32,875 --> 00:17:37,100
我的软件突然停止工作，
My software suddenly stops working, right? 

268
00:17:37,100 --> 00:17:40,512
因为我的库调用了Jose库中的一个函数，
Because my library calls a function on Jose's library, 

269
00:17:40,512 --> 00:17:42,050
但是该函数不再存在。
but that function no longer exists. 

270
00:17:42,050 --> 00:17:46,125
取决于人们安装的Jose库的版本，
Depending on which version people have installed of Jose's library, 

271
00:17:46,175 --> 00:17:51,900
版本号有助于我指定我依赖于Jose库的哪个版本，
version helps solve this because I can say I depend on this version of Jose's library, 

272
00:17:51,900 --> 00:17:57,725
并且必须有一些规则来规定在给定版本中Jose可以做什么。
and there have to be some rules around what is Jose allowed to do within a given version. 

273
00:17:57,725 --> 00:18:03,325
如果他做了一个我不能再依赖的更改，他的版本必须以某种方式更改。
If he makes a change that I can no longer rely on, his version has to change in some way. 

274
00:18:03,325 --> 00:18:08,325
关于这是如何工作的存在许多想法，例如
There are many thoughts on exactly how this should work, 

275
00:18:08,325 --> 00:18:11,250
关于版本发布的规则，
like what are the rules for publishing new versions,

276
00:18:11,250 --> 00:18:13,300
版本号如何更改
 how do they change the version numbers. 

277
00:18:13,300 --> 00:18:17,650
其中一些仅受时间约束。
Some of them are just dictated by time. 

278
00:18:17,650 --> 00:18:22,500
例如，如果您看一下浏览器，它们通常具有类似于时间版本的版本号。
So for example, if you look at browsers, they very often have time versions that look like this. 

279
00:18:22,500 --> 00:18:27,150
它们在最左侧有一个版本号，表示哪个发布版，
They have a version number on the far left that's just like which release, 

280
00:18:27,150 --> 00:18:30,825
然后有一个通常为零的增量号，
and then they have sort of an incremental number that is usually zero, 

281
00:18:30,825 --> 00:18:33,925
最后有一个日期。
and then they have a date at the end, right? 

282
00:18:33,925 --> 00:18:37,875
因此，这是2019年3月24日的某个版本
So this is March 24th, 2019, for some reason. 

283
00:18:37,875 --> 00:18:47,200
通常这，可以从这些信息中得知，这是第64个版本的Firefox。
And usually, that will indicate that this is version 64 of Firefox from this date. 

284
00:18:47,275 --> 00:18:51,250
如果他们发布针对安全漏洞的补丁或热修复，
And then, if they release sort of patches or hot fixes for security bugs, 

285
00:18:51,250 --> 00:18:55,475
他们可能会增加日期但保持左侧版本不变。
they might increment the date but keep the version of the left the same. 

286
00:18:57,325 --> 00:19:02,075
人们对方案的具体内容有着强烈的意见，
And people have strong, strong opinions on exactly what the scheme should be, 

287
00:19:02,075 --> 00:19:06,575
而你需要了解其他人使用的方案。
and you sort of depend on knowing what schemes other people use, right? 

288
00:19:06,625 --> 00:19:09,850
如果我不知道Jose用于更改版本的方案，
If I don't know what scheme Jose is using for changing his versions,

289
00:19:09,850 --> 00:19:14,650
也许我只能说，你必须运行Jose软件的817版本，
 maybe I just have to say, you have to run like 817 of Jose's software, 

290
00:19:14,700 --> 00:19:17,000
否则我无法构建我的软件。
otherwise, I cannot build my software. 

291
00:19:17,000 --> 00:19:19,250
但这也是一个问题。
But this is a problem, too, right? 

292
00:19:19,250 --> 00:19:22,962
想象一下，Jose作为他的库的负责开发人员，
Imagine that Jose, as a responsible developer of his library, 

293
00:19:22,975 --> 00:19:25,925
他发现安全漏洞并修复了它，
and he finds the security bug and he fixes it, 

294
00:19:25,925 --> 00:19:29,625
但它没有改变库的外部接口。
but it doesn't change the external interfaces library. 

295
00:19:29,625 --> 00:19:31,950
没有函数改变，没有类型改变。
No functions change, no types change. 

296
00:19:31,950 --> 00:19:36,450
然后我希望人们使用他的新版本来构建我的软件，
Then I want people to be building my software with his new version,

297
00:19:36,450 --> 00:19:41,000
恰好构建我的软件可以使用他的新版本，
and it just so happens that building mine works just fine with his new version 

298
00:19:41,000 --> 00:19:44,550
因为那个特定版本没有改变我所依赖的任何东西。
because that particular version didn't change anything I depended on. 

299
00:19:45,100 --> 00:19:50,400
因此，对此的一种尝试解决方案是称为语义版本控制。
So one attempted solution to this is something called semantic versioning. 

300
00:19:50,400 --> 00:19:53,525
在语义版本控制中，我们为版本号中
In semantic versioning, we give each of the numbers 

301
00:19:53,525 --> 00:19:56,700
由点分隔的每个数字赋予特定的含义，
separated by dots in a version number a particular meaning. 

302
00:19:56,775 --> 00:20:01,150
并为不同数字的增加制定合同。
And we give a contract for when you have to increment the different numbers. 

303
00:20:01,150 --> 00:20:18,075
特别是在语义化版本控制中，我们称这个为主要版本，这个为次要版本，
In particular, in semantic versioning, we call this the major version, we call this the minor version, 

304
00:20:18,725 --> 00:20:22,350
这个为补丁版本。
and we call this the patch version. 

305
00:20:24,275 --> 00:20:26,950
其规则如下：
The rules around this are as follows: 

306
00:20:27,475 --> 00:20:31,712
如果你对你的软件进行了完全向后兼容的更改，
if you make a change to your software 

307
00:20:31,712 --> 00:20:36,475
例如不添加任何东西，
and the change you made is entirely backwards compatible, 

308
00:20:36,575 --> 00:20:42,300
不删除任何东西，不在外部重命名任何东西，就像什么也没有改变一样，
like it does not add anything, it does not remove anything, it does not rename anything 

309
00:20:42,375 --> 00:20:49,750
那么你只增加补丁号，不做其他更改。
externally, it is as if nothing changed, then you only increment the patch number, nothing else. 

310
00:20:49,750 --> 00:20:53,575
通常，例如安全修复会增加补丁号。
Usually, security fixes, for example, will increment the patch number. 

311
00:20:54,250 --> 00:20:57,725
如果你添加了库中的某些内容
If you add something to your library 

312
00:20:57,750 --> 00:21:01,969
（我只是称其为库，因为通常库是这种情况下需要考虑的内容），
(I'm just gonna call them libraries because usually libraries are the things where this matters), 

313
00:21:01,980 --> 00:21:05,275
所以对于库，如果你添加了一些东西
So to library, if you add some thing to library

314
00:21:05,275 --> 00:21:09,100
则增加次要版本并将补丁设置为零。
you increment the minor version and you set the patch to zero. 

315
00:21:09,200 --> 00:21:12,250
在这种情况下，如果我们要进行一个次要发布，
In this case, if we were to do a minor release, 

316
00:21:12,250 --> 00:21:16,325
则下一个次要发布版本号将为 8-0。
the next minor release version number would be eight to zero. 

317
00:21:17,050 --> 00:21:19,274
我们这样做的原因是，
And the reason we do this is because

318
00:21:19,274 --> 00:21:25,226
我可能对 José 在 2.0 中添加的某个特性有依赖性，
 I might have a dependency on a feature that José added in a 2-0, 

319
00:21:25,226 --> 00:21:29,200
这意味着你不能使用 8-1-7 构建我的软件。
which means you can't build my software with 8-1-7. 

320
00:21:29,225 --> 00:21:31,327
这可能不太行，尽管...
That would not be okay, even though 

321
00:21:31,327 --> 00:21:35,300
如果你已经将其编写为 8-1-7，你可以在 2-0 上运行它。
if you had written it towards 8-1-7, you could run it with a 2-0. 

322
00:21:35,375 --> 00:21:39,375
反之则不是这样，因为它可能尚未添加。
The reverse is not true because it might not have been added yet. 

323
00:21:39,375 --> 00:21:45,825
最后，如果进行了向后不兼容的更改，则增加主要版本。
And then, finally, the major version you increment if you make a backwards incompatible change. 

324
00:21:45,825 --> 00:21:51,525
如果我的软件以前可以使用你所拥有的任何版本，
Where if my software used to work with whatever version you had, 

325
00:21:51,525 --> 00:21:55,225
然后你做出了一些改变，这意味着我的软件可能不再工作，
and then you make a change that means that my software might no longer work, 

326
00:21:55,225 --> 00:21:57,300
例如删除或重命名函数，
such as removing a function or renaming it, 

327
00:21:57,325 --> 00:22:01,075
则增加主要版本并将次要和补丁设置为零。
then you increment the major version and set minor and patch to zero. 

328
00:22:01,075 --> 00:22:04,475
因此，下一个主要版本将是 9-0-0。
So, the next major version here would be 9-0-0. 

329
00:22:05,375 --> 00:22:11,825
综合在一起，这些使我们能够在设置我们的依赖项时做很好的事情。
Taken together, these allow us to do really nice things when setting what our dependencies are. 

330
00:22:11,825 --> 00:22:16,200
特别是，如果我依赖于某个人的库的特定版本，
In particular, if I depend on a particular version of someone's library, 

331
00:22:16,200 --> 00:22:19,375
而不是说它必须完全是这个版本，
rather than saying it has to be exactly this version, 

332
00:22:19,450 --> 00:22:23,450
我真正想表达的是它必须是相同的主要版本，
what I'm really saying is it has to be the same major version 

333
00:22:23,450 --> 00:22:27,425
至少是相同的次要版本，
and at least the same minor version, 

334
00:22:27,425 --> 00:22:29,475
并且补丁可以是任何内容。
and the patch can be whatever. 

335
00:22:29,475 --> 00:22:33,575
这意味着，如果我依赖于 José 的软件，
This means that if I have a dependency on José's software, 

336
00:22:33,575 --> 00:22:38,300
则仍在同一主要版本内的任何后续版本都可以。
then any later release that is still within the same major is fine. 

337
00:22:38,300 --> 00:22:45,025
请记住，这包括较早的版本，假设次要版本相同。
That includes, keep in mind, an earlier version, assuming that the minor is the same.

338
00:22:45,025 --> 00:22:50,125
想象一下，你在某台装有 8.1.3 版本的旧计算机上。
Imagine that you are on some older computer that has version 8.1.3. 

339
00:22:50,125 --> 00:22:54,350
理论上，我的软件也应该可以正常工作在 8.1.3 版本上。
In theory, my software should work just fine with 8.1.3 as well. 

340
00:22:54,350 --> 00:22:58,700
它可能有 José 在其中修复的任何漏洞，例如任何安全问题。
It might have whatever bug that José fixed in between, like whatever security issue. 

341
00:22:58,700 --> 00:23:02,425
但这具有很好的特性，现在你可以
But this has the nice property that now you can share dependencies 

342
00:23:02,425 --> 00:23:05,025
在计算机上的许多不同软件之间共享依赖关系。
between many different pieces of software on your machine. 

343
00:23:05,025 --> 00:23:08,541
如果您已经安装了8.3.0版本，
If you have version 8.3.0 installed 

344
00:23:08,541 --> 00:23:13,121
并且有许多不同的软件需要8.1.7、8.2.4
and there are bunch of different software that one requires 8.1.7, one requires 8.2.4, 

345
00:23:13,125 --> 00:23:18,257
和8.0.1版本中的一个，那么它们都可以使用同一个依赖版本。
and one requires 8.0.1, all of them can use the same version of that dependency. 

346
00:23:18,257 --> 00:23:19,750
您只需要安装一次即可。
You only need to install it once.

347
00:23:20,850 --> 00:23:27,385
这种语义化版本控制中最常见或最熟悉的例子之一
One of the most common or most familiar, perhaps, 

348
00:23:27,385 --> 00:23:32,225
是Python版本控制。
examples of this kind of semantic versioning is if you look at the Python versioning. 

349
00:23:32,225 --> 00:23:34,485
你们中的许多人可能已经遇到过这个问题，
Many of you may have come across this, 

350
00:23:34,485 --> 00:23:38,675
Python 3和Python 2彼此不兼容。
where Python 3 and Python 2 are not compatible with one another. 

351
00:23:38,675 --> 00:23:40,475
它们不向后兼容。
They're not backwards compatible. 

352
00:23:40,475 --> 00:23:45,825
如果你在Python 2中编写代码并尝试在Python 3中运行它，它可能不起作用。
If you write code in Python 2 and try to run it in Python 3, it might not work. 

353
00:23:45,825 --> 00:23:47,825
有些情况下会起作用，
There are some cases where it will, 

354
00:23:47,825 --> 00:23:50,500
但那更多的是偶然而非其他。
but that is more accidental than anything else. 

355
00:23:51,375 --> 00:23:54,950
Python实际上遵循语义化版本控制，至少大部分是这样。
Python actually follows semantic versioning, at least mostly. 

356
00:23:54,950 --> 00:24:03,200
如果你编写运行在Python 3.5上的软件，那么它也应该在3.6、3.7和3.8上运行。
If you write software that runs on Python 3.5, then it should also work in 3.6, 3.7,  and 3.8.  

357
00:24:03,300 --> 00:24:09,025
它不一定会在Python 4上运行，虽然那可能还需要很长一段时间。
It will not necessarily work in Python 4, although that will hopefully be a long time away. 

358
00:24:09,025 --> 00:24:16,000
但如果你为Python 3.5编写代码，它可能不会在Python 3.4上运行。
But if you write code for Python 3.5, it will possibly not run on Python 3.4.

359
00:24:16,000 --> 00:24:19,775
因此，你会看到许多软件项目
So, one thing you will see many software projects do is 

360
00:24:19,775 --> 00:24:24,575
尽可能降低它们的版本要求。
they try to bring the version requirements they have as low as possible. 

361
00:24:24,600 --> 00:24:29,175
如果你可以依赖主版本和次版本以及修补版本0.0，
If you can depend on major and then minor in patch 0.0, 

362
00:24:29,175 --> 00:24:31,900
那么这是你可以拥有的最好的依赖关系，
that is the best possible dependency 

363
00:24:31,900 --> 00:24:37,200
因为它完全自由地依赖于你正在依赖的主要版本的哪个版本。
you can have because it is completely liberal as to which version of that major you're depending on. 

364
00:24:37,300 --> 00:24:38,425
有时这很难。
Sometimes this is hard. 

365
00:24:38,425 --> 00:24:41,075
有时你确实需要添加一个特性，
Sometimes you genuinely need a feature that was added, 

366
00:24:41,075 --> 00:24:46,600
但你可以把版本要求降到最低，这对于那些想要依赖你的软件的人来说是最好的。
but the lower you can get, the better it is for those who want to depend on your software in turn

367
00:24:48,375 --> 00:24:54,053
反过来，在处理这些依赖管理系统或一般版本控制时，
when working with these sort of dependency management systems or in with versioning in general,

368
00:24:54,053 --> 00:24:57,075
你经常会遇到锁定文件的概念。
 you'll often come across this notion of lock files. 

369
00:24:57,075 --> 00:25:00,650
你可能已经看到过这个问题，当你尝试做某事时，
You might have seen this where you try to do something 

370
00:25:00,675 --> 00:25:03,175
它会说“无法协调版本”，
and it says, "Cannot reconcile versions" 

371
00:25:03,175 --> 00:25:05,950
或者你会收到像“锁定文件已经存在”这样的错误。
or you get an error like, "Lock file already exists." 

372
00:25:05,950 --> 00:25:08,375
这些通常是有些不同的主题，
These are often somewhat different topics, 

373
00:25:08,375 --> 00:25:12,050
但总的来说，锁定文件的概念是为了
but in general, the notion of a lock file is to make sure that

374
00:25:12,050 --> 00:25:14,450
确保你不会意外地更新某些东西。
 you don't accidentally update something. 

375
00:25:14,450 --> 00:25:19,450
锁定文件本质上只是一个列出你依赖关系
The lock file, at its core, is really just a list of your dependencies 

376
00:25:19,450 --> 00:25:22,225
及其当前使用版本的列表。
and which version of them you are currently using. 

377
00:25:22,225 --> 00:25:25,525
我的版本字符串可能是8.1.7，
My version string might be 8.1.7, 

378
00:25:25,525 --> 00:25:30,825
而最新版本可能是3.0，
and the latest version, like on the internet somewhere, might be 3.0, 

379
00:25:30,825 --> 00:25:35,275
但在我的系统上安装的版本不一定是其中的一个。
but whatever is installed on my system is not necessarily one of those two. 

380
00:25:35,275 --> 00:25:37,600
它可能是8.2.4或类似的版本，
It might be like 8.2.4 or something like that, 

381
00:25:37,925 --> 00:25:43,475
锁定文件会说“依赖José的8.2.4版本”。
and the lock file will then say, "Dependency José version 8.2.4." 

382
00:25:43,475 --> 00:25:46,900
你想要一个锁定文件的原因有很多。
The reason you want a lock file, there can be many. 

383
00:25:46,900 --> 00:25:52,250
其中一个原因是您可能希望构建速度快。
One of them is that you might want your builds to be fast.

384
00:25:52,250 --> 00:25:56,575
如果每次尝试构建项目时，
if every single time you try to build your project, 

385
00:25:56,575 --> 00:25:59,600
您使用的任何工具都会下载最新版本，
whatever tool you were using download the latest version 

386
00:25:59,600 --> 00:26:01,825
然后编译它，再编译您的项目，
and then compile it and then compile your thing, 

387
00:26:01,825 --> 00:26:04,225
那么每次等待时间可能会很长，
you might wait for a really long time each time, 

388
00:26:04,225 --> 00:26:06,750
具体取决于依赖项的发布周期。
depending on the release cycle of your dependencies. 

389
00:26:06,750 --> 00:26:10,425
如果您使用锁文件，
If you use a lock file, then unless the version, 

390
00:26:10,425 --> 00:26:12,925
除非您已在锁文件中更新了版本，
unless you've updated the version in your lock file, 

391
00:26:12,925 --> 00:26:16,200
否则它将仅使用之前为该依赖项构建的内容，
it'll just use whatever it built previously for that dependency 

392
00:26:16,200 --> 00:26:20,150
您的开发周期可以更快。
and your sort of development cycle can be a lot faster. 

393
00:26:20,150 --> 00:26:25,075
使用锁文件的另一个原因是为了获得可重复的构建。
Another reason to use lock files is to get reproducible builds. 

394
00:26:25,075 --> 00:26:29,075
假设我生产了一些与安全相关的软件，
Imagine that I produce some kind of security-related software, 

395
00:26:29,075 --> 00:26:32,375
我非常仔细地审查了我的依赖关系，
and I very carefully audited my dependencies, 

396
00:26:32,450 --> 00:26:35,450
并生成了一个签名的二进制文件，
and I produce, like, a signed binary of, like,

397
00:26:35,450 --> 00:26:41,050
例如“这是我的宣誓声明，证明这个版本是安全的”。
 'Here is, thus, like a sworn statement for me that this version is secure.' 

398
00:26:41,375 --> 00:26:47,325
如果我没有包含锁文件，那么当其他人安装我的程序时，
If I didn't include a lock file, then by the time someone else installs my program, 

399
00:26:47,325 --> 00:26:49,775
他们可能会得到一个更晚的依赖版本，
they might get a later version of their pendency, 

400
00:26:49,775 --> 00:26:52,525
而这个版本可能已被黑客攻击
and maybe that later version as I've been hacked somehow 

401
00:26:52,525 --> 00:26:54,775
或存在其他安全漏洞，
or just has some other security vulnerability 

402
00:26:54,775 --> 00:26:57,825
而我还没有机会查看。
that I haven't had a chance to look at yet, right? 

403
00:26:57,825 --> 00:27:04,300
锁文件基本上允许我冻结生态系统，因为它是我已检查的版本。
And a lock file basically allows me to freeze the ecosystem as of this version that I have checked. 

404
00:27:04,675 --> 00:27:08,200
这种做法的极端版本是一种称为“vendoring”的东西。
The extreme version of this is something called 'vendoring.

405
00:27:08,200 --> 00:27:12,725
当您对依赖项进行vendoring时，实际上就是将它们复制/粘贴到项目中。
When you vendor your dependencies, it really just means you copy/paste of them. 

406
00:27:12,725 --> 00:27:16,175
Vendoring意味着将您关心的任何依赖项
Vendoring means take whatever dependency you care about 

407
00:27:16,175 --> 00:27:20,125
复制到您的项目中，
and copy it into your project because that way, 

408
00:27:20,125 --> 00:27:25,150
因为这样您就完全确定了将获得该依赖项的版本。
you are entirely sure that you will get that version of that dependency. 

409
00:27:25,150 --> 00:27:28,525
这也意味着您可以自己修改它，
It also means that you can, like, make modifications to it on your own, 

410
00:27:28,525 --> 00:27:33,175
但它的缺点是您将不再获得版本控制的好处。
but it has the downsides that now you no longer get these benefits of versioning, right? 

411
00:27:33,175 --> 00:27:38,025
当一个新的发行版出现时，
You no longer have the advantage that if there are newer releases of that software, 

412
00:27:38,025 --> 00:27:40,425
您将无法自动获取软件的新版本，
your users might get them automatically, like, 

413
00:27:40,425 --> 00:27:45,025
例如当Hosea修复其安全问题时（当然他没有安全问题）。
for example, when Hosea fixes his security issues, not that he has any of course. 

414
00:27:48,575 --> 00:27:52,075
您会注意到，当谈论这个问题时，我一直在谈论系统中的一些更大的过程。
One thing you'll notice is that when talking about this, 

415
00:27:52,075 --> 00:27:56,350
我已经说了很多关于系统的大的过程
I've been talking about sort of bigger processes around your systems. 

416
00:27:56,350 --> 00:27:58,725
这些过程包括测试，
These are things like testing. 

417
00:27:58,725 --> 00:28:01,875
检查依赖关系版本
They're things like checking your dependency versions. 

418
00:28:01,875 --> 00:28:05,175
以及设置构建系统等。
They're also things that are just setting up build systems, 

419
00:28:05,175 --> 00:28:08,600
通常，您不只想要一个本地构建系统，
and often you don't just want a local build system. 

420
00:28:08,600 --> 00:28:12,200
您希望构建过程包括其他类型的系统，
You want to build process that includes other types of systems, 

421
00:28:12,200 --> 00:28:15,925
即使您的计算机不一定开着，它们也可以运行。，
or you want them to run even when your computer is not necessarily on, 

422
00:28:15,925 --> 00:28:19,450
因此，随着您开始处理越来越大的项目，
and this is why, as you start working a larger and larger project, 

423
00:28:19,450 --> 00:28:23,525
您会看到人们使用持续集成的概念，
you will see people use this idea of continuous integration, 

424
00:28:23,525 --> 00:28:29,650
持续集成系统本质上是一个云构建系统。
and continuous integration systems are essentially a cloud build system. 

425
00:28:29,650 --> 00:28:33,900
这意味着您的项目存储在互联网的某个地方，
The idea is that you have your project stored on the internet somewhere, 

426
00:28:33,900 --> 00:28:37,125
并且您已经使用某种服务
and you have set it up with some kind of service 

427
00:28:37,125 --> 00:28:42,100
为您的项目运行持续集成，无论它是什么。
that is running an ongoing thing for your project, whatever it might be, 

428
00:28:42,100 --> 00:28:45,425
持续集成可以是各种各样的东西。
and continuous integration can be all sorts of stuff. 

429
00:28:45,425 --> 00:28:49,179
它可以是像将您的库自动发布到PyPI一样简单，
It can be stuff like releasing your library to PyPI automatically 

430
00:28:49,179 --> 00:28:51,275
每次提交到特定分支时。
whenever you push to a particular branch. 

431
00:28:51,275 --> 00:28:56,450
它可以是类似于每当有人提交拉取请求时运行测试套件，
It could be things like run your test suite  whenever someone submits a pull request,  

432
00:28:56,450 --> 00:29:01,675
或者可以是每次提交代码时检查您的代码风格。
or it could be check your code style every time you commit. 

433
00:29:01,675 --> 00:29:04,450
您可以通过持续集成实现各种各样的事情，
There all sorts of things you could do with continuous integration, 

434
00:29:04,450 --> 00:29:09,575
最简单的方法是将它们视为事件触发的操作。
and the easiest way to think about them is that they're sort of event-triggered actions. 

435
00:29:09,575 --> 00:29:13,375
因此，每当某个事件发生时，可能会针对您的项目发生特定的操作，
So, whenever a particular event happens for your, possibly for your project,

436
00:29:13,375 --> 00:29:17,675
其中操作通常是某种脚本、一系列要调用的程序，
a particular action takes place, where the action is usually some kind of script, 

437
00:29:17,675 --> 00:29:23,200
它们将执行某些操作。
some sequence of programs that are going to be invoked,  and they're going to do something.  

438
00:29:25,375 --> 00:29:30,925
这实际上是一个涵盖了许多不同类型的服务的大伞术语。
This is really an umbrella term that encapsulates a lot of different types of services.

439
00:29:30,925 --> 00:29:38,350
一些持续集成服务是非常通用的东西，比如Travis CI、Azure pipelines
Some continuous integration services are very general things like Travis CI or Azure pipelines, 

440
00:29:38,350 --> 00:29:43,825
或GitHub actions都是非常广泛的CI平台。
or GitHub actions are all very broad CI platforms. 

441
00:29:43,825 --> 00:29:47,225
它们旨在让您编写
They're built to let you write what you want to happen 

442
00:29:47,225 --> 00:29:51,775
在您定义的任何事件发生时要发生的操作，非常广泛的系统。
whenever any event that you define happens, very broad systems. 

443
00:29:51,775 --> 00:29:59,650
还有一些更专业的系统，处理诸如持续集成覆盖测试之类的事情。
There are some more specialized systems that deal with things like continuous integration coverage testing. 

444
00:29:59,650 --> 00:30:04,275
所以，像注释你的代码并展示你没有测试这段代码，
So, like annotate your code and show you have no tests that test this piece of code, 

445
00:30:04,275 --> 00:30:06,175
它们仅用于这个目的，
and they're built only for that purpose, 

446
00:30:06,175 --> 00:30:12,125
或者它们仅用于测试基于浏览器的库之类的东西。
or they're built only for testing browser-based libraries or something like that. 

447
00:30:12,125 --> 00:30:16,975
因此，通常你可以找到为你正在工作的特定项目构建的CI工具，
And so, often you can find CI tools that are built for the particular project you're working on, 

448
00:30:16,975 --> 00:30:19,125
或者你可以使用其中的一个更广泛的提供者。
or you can use one of these broader providers. 

449
00:30:19,125 --> 00:30:24,075
而且，其中一个好处是，许多CI工具实际上是免费的，特别是针对开源软件，
And one thing that's nice is that many of them are actually free,  especially for open source software,  

450
00:30:24,075 --> 00:30:26,775
或者如果你是学生，你也经常可以免费获得它们。
or if you're a student,  you can often get them for free as well. 

451
00:30:27,750 --> 00:30:34,725
一般来说，你使用CI系统的方式是向你的代码库添加一个文件，
In general, the way you use the CI system is that you add a file to your repository, 

452
00:30:34,725 --> 00:30:37,075
这个文件通常称为“recipe”。
and this file is often known as a recipe. 

453
00:30:37,075 --> 00:30:41,375
而这个recipe指定的内容是这种依赖循环，
And what the recipe specifies is this sort of dependency cycle again, 

454
00:30:41,375 --> 00:30:45,182
就像我们在make文件中看到的那样，但并不完全相同。
sort of what we saw with make files, it's not quite the same. 

455
00:30:45,182 --> 00:30:50,425
事件，而不是文件，可能是这样的，比如当有人推送提交时，
The events, instead of being files, might be something like when someone pushes a commit 

456
00:30:50,425 --> 00:30:53,375
当提交包含特定的消息时，
or when a commit contains a particular message 

457
00:30:53,375 --> 00:30:59,325
或者当有人提交pull request或持续写入时。
or when someone submits a pull request or continuously write. 

458
00:30:59,325 --> 00:31:02,537
一个不与你的代码的任何特定更改相关的
One example of a continuous integration service

459
00:31:02,537 --> 00:31:06,825
持续集成服务的例子是Dependabot。
 that's not tied to any particular change to your code is something called the Dependabot. 

460
00:31:06,825 --> 00:31:08,725
你可以在GitHub上找到它，
You can find this on GitHub, 

461
00:31:08,725 --> 00:31:12,825
而Dependabot是你连接到你的代码库中的一个东西，
and the Dependabot is something that you hook up to your repository, 

462
00:31:12,825 --> 00:31:19,125
它将只扫描你没有使用的依赖项中是否有更新的版本。
and it will just scan whether there are newer versions available of your dependencies that you're not using.

463
00:31:19,125 --> 00:31:25,625
因此，例如，如果我依赖于8.1.7，并且我有一个锁定文件将它锁定在8.2.4上，
So, for example, if I was depending on 8.1.7 and I had a lock file that locked it to 8.2.4, 

464
00:31:25,625 --> 00:31:28,950
然后8.3.0发布了，Dependabot会说：
and then 8.3.0 is released, the Dependabot will go, 

465
00:31:29,000 --> 00:31:30,625
“你应该更新你的锁定文件”，
"You should update your lock file," 

466
00:31:30,625 --> 00:31:33,700
然后向你的代码库提交该更新的pull request。
and then submit the pull request to your repository with that update. 

467
00:31:33,700 --> 00:31:36,125
这是一个持续集成服务。
This is a continuous integration service. 

468
00:31:36,125 --> 00:31:40,550
它不是与我改变任何东西相关，而是与生态系统的整体变化相关。
It's not tied to me changing anything but to the ecosystem at large changing. 

469
00:31:42,325 --> 00:31:47,275
这些CI系统通常也会与你的项目集成。
Often these CI systems integrate back into your project as well. 

470
00:31:47,275 --> 00:31:51,525
因此，这些CI服务经常会提供一些小徽章之类的东西。
So, very often, these CI services will provide things like little badges.

471
00:31:51,525 --> 00:31:53,175
让我举个例子。
Let me give an example. 

472
00:31:53,175 --> 00:32:02,450
例如，这是我最近参与的一个设置了持续集成的项目。
So, for example, here's a project I've worked on recently that has continuous integration set up. 

473
00:32:02,450 --> 00:32:05,950
所以，这个项目，你会注意到它的README。
So, this project, you'll notice it's README. 

474
00:32:07,250 --> 00:32:14,825
如果我可以用那个Chrome bean放大它，不，不，那比我想要的大得多。
If I can zoom in here with that Chrome bean, nope, nope, that's much larger than I wanted. 

475
00:32:14,825 --> 00:32:22,450
在这里，你会看到在代码库页面的顶部有一堆这样的徽章，
Here, you'll see that at the top of the repositories page, there are a bunch of these badges, 

476
00:32:22,450 --> 00:32:25,275
它们显示各种类型的信息。
and they display various types of information. 

477
00:32:25,275 --> 00:32:27,975
你会注意到我正在运行Dependable，对吧？
You'll notice that I have dependable running, right? 

478
00:32:27,975 --> 00:32:29,450
所以依赖项当前是最新的。
So the dependencies are currently up to date. 

479
00:32:29,450 --> 00:32:33,775
它告诉我主分支上的测试套件是否正在通过。
It tells me about whether the test suite is currently passing on the master branch. 

480
00:32:33,775 --> 00:32:37,600
它告诉我代码中有多少被测试覆盖了，
It tells me how much of the code is covered by tests, 

481
00:32:37,600 --> 00:32:41,725
并告诉我这个库的最新版本
and it tells me what is the latest version of this library 

482
00:32:41,725 --> 00:32:46,200
和在线可用的文档版本。
and what is the latest version of the documentation of the library that's available online. 

483
00:32:46,200 --> 00:32:51,175
所有这些都由各种持续集成服务管理。
And all of these are managed by various continuous integration services. 

484
00:32:51,175 --> 00:32:55,617
另一个你们中有些人可能会发现有用甚至熟悉的例子
Another example that some of you might find useful or might even be familiar with is

485
00:32:55,617 --> 00:32:59,650
是GitHub Pages。
 the notion of GitHub Pages. 

486
00:32:59,675 --> 00:33:03,900
GitHub Pages是GitHub提供的一个非常好的服务，
So GitHub Pages is a really nice service the GitHub provides 

487
00:33:03,900 --> 00:33:15,450
它允许你设置一个CI操作，将你的存储库构建为博客。
which lets you set up a CI action that builds your repository as a blog essentially. 

488
00:33:15,450 --> 00:33:19,125
它运行一个静态站点生成器称为Jekyll，
It runs a static site generator called Jekyll, 

489
00:33:19,125 --> 00:33:26,050
Jekyll只需要一堆Markdown文件，然后生成一个完整的网站。
and Jekyll just takes a bunch of markdown files and then produces a complete website. 

490
00:33:26,050 --> 00:33:30,975
作为GitHub Pages的一部分，它们还会将其上传到GitHub服务器
And that, as a part of GitHub Pages, they will also upload that to GitHub servers 

491
00:33:30,975 --> 00:33:33,950
并在特定域名下提供。
and make it available at a particular domain. 

492
00:33:33,950 --> 00:33:36,975
这实际上是课堂网站的工作方式。
And this is actually how the class website works. 

493
00:33:36,975 --> 00:33:41,250
课堂网站不是一堆我们管理的HTML页面。
The class website is not a bunch of like HTML pages that we manage. 

494
00:33:41,250 --> 00:33:46,475
相反，有一个名为'Missing Semester'的存储库。
Instead, there's a repository 'Missing Semester.'

495
00:33:46,575 --> 00:33:53,075
如果你查看Missing Semester存储库，你会看到，
 So if you look at the Missing Semester repository, you will see, 

496
00:33:53,075 --> 00:33:59,675
如果我在这里缩小一下，它只有一堆Markdown文件。
if I zoom out a little here, that this just has a bunch of markdown files. 

497
00:33:59,675 --> 00:34:06,825
这里有'Saket 20/20 - Metaprogramming.md'，
Right? It has 'Saket 20/20 - Metaprogramming.md,' 

498
00:34:06,825 --> 00:34:12,975
所以这是今天讲座的原始Markdown。
so this is the raw markdown for today's lecture. 

499
00:34:12,975 --> 00:34:16,175
这是我编写讲座笔记的方式，
So this is the way that I write the lecture notes, 

500
00:34:16,175 --> 00:34:20,375
然后我将其提交到我们的存储库，并将其推送。
and then I commit that to the repository we have,  and I push it.  

501
00:34:20,375 --> 00:34:22,350
每当发生推送时，
And whenever a push happens, 

502
00:34:22,350 --> 00:34:28,150
GitHub Pages CI将运行GitHub Pages的构建脚本，
the GitHub Pages CI is gonna run the build script for GitHub Pages 

503
00:34:28,150 --> 00:34:32,941
并为我们的课程生成网站，
and produces the website for our class 

504
00:34:32,941 --> 00:34:36,675
而无需我执行任何其他步骤来完成这一过程。
without me having to do any additional steps to make that happen. 

505
00:34:36,925 --> 00:34:38,800
所以，是的。
And so, yeah, 

506
00:34:45,350 --> 00:34:51,075
所以Jekyll，它使用一个称为Jekyll的工具，
So Jekyll, it's using a tool called Jekyll, which is a tool that

507
00:34:51,075 --> 00:34:57,625
它是一个将包含Markdown文件的目录结构转换成网站的工具。
 takes a directory structure that contains markdown files and produces a website. 

508
00:34:57,625 --> 00:34:59,475
它会生成像HTML文件这样的文件，
It produces like HTML files, 

509
00:34:59,475 --> 00:35:01,716
然后作为操作的一部分，
and then as a part of the action, 

510
00:35:01,716 --> 00:35:06,775
它会将这些文件上传到GitHub服务器的一个特定域名下，
it takes those files and uploads them to GitHub servers at a particular domain, 

511
00:35:06,775 --> 00:35:11,450
通常是他们控制的'github.io'域名下。
and usually, that's the domain under like 'github.io' that they control. 

512
00:35:11,450 --> 00:35:16,025
然后我将Missing Semester设置为指向GitHub域名。
And then I have set Missing Semester to point to the GitHub domain. 

513
00:35:22,350 --> 00:35:25,875
我想给大家一个关于测试的旁白，
I want to give you one aside on testing 

514
00:35:25,875 --> 00:35:30,550
因为这是你们中很多人以前可能熟悉的东西，
because it's something that many of you may be familiar with from before, right? 

515
00:35:30,550 --> 00:35:32,350
对测试有一个大致的概念。
You have a rough idea of what testing is. 

516
00:35:32,350 --> 00:35:33,875
你会在之前运行测试。
You run the test before. 

517
00:35:33,875 --> 00:35:35,350
你曾经看过测试失败。
You've seen a test fail. 

518
00:35:35,350 --> 00:35:39,150
你知道基础知识，或者你从来没有见过测试失败。
You know, like the basics of it, or maybe you've never seen a test fail. 

519
00:35:39,150 --> 00:35:40,475
如果你已经掌握了这些知识，那么恭喜你，
In case congratulations, 

520
00:35:40,475 --> 00:35:45,425
但是当你开始涉及更高级的项目时，
but as you get to more advanced projects, though, 

521
00:35:45,425 --> 00:35:49,600
你会发现人们对于测试有很多专业术语。
you'll find that people have a lot of terminology around testing.

522
00:35:49,600 --> 00:35:52,420
测试是一个非常深入的主题，
and testing is a pretty deep subject 

523
00:35:52,420 --> 00:35:56,475
你可能需要花费许多时间来理解其中的细节。
that you could spend many many hours trying to understand the ins and outs of, 

524
00:35:56,500 --> 00:35:59,250
虽然我不会详细介绍所有的内容，
and I'm not going to go through it in excruciating detail, 

525
00:35:59,250 --> 00:36:02,625
但是有几个词汇我认为是有用的，你需要知道它们的含义。
but there are a couple of words that I think it's useful to know what mean. 

526
00:36:02,625 --> 00:36:05,275
第一个是测试套件。
And the first of these is a test suite. 

527
00:36:05,275 --> 00:36:10,375
测试套件是程序中所有测试的简单名称。
So a test suite is a very straightforward name for all of the tests in a program. 

528
00:36:10,375 --> 00:36:16,400
它只是一组测试，通常作为一个整体运行，
It's really just a suite of tests, it's a large collection of tests that usually are run as a unit, 

529
00:36:16,400 --> 00:36:22,225
通常由不同类型的测试组成。
and there are different types of tests that often make up a test suite. 

530
00:36:22,225 --> 00:36:25,275
第一个类型是单元测试。
The first of these is what's known as a unit test. 

531
00:36:25,275 --> 00:36:34,000
单元测试是一种通常比较小的、自包含的测试，用于测试一个单一的功能。
A unit test is a, often usually fairly small, test of self-contained tests that tests a single feature. 

532
00:36:34,000 --> 00:36:38,250
什么是一个功能可能有点取决于项目，
What exactly a feature might mean is a little bit up to the project, 

533
00:36:38,250 --> 00:36:43,575
但是这个想法是应该有一个微型测试，只测试一个非常特定的东西。
but the idea is that should be sort of a micro test that only tests a very particular thing. 

534
00:36:43,575 --> 00:36:47,625
然后你有更大的测试，称为集成测试。
Then you have the larger tests that are known as integration tests. 

535
00:36:47,625 --> 00:36:53,600
集成测试尝试测试程序的不同子系统之间的交互。
Integration tests try to test the interaction between different subsystems of a program. 

536
00:36:53,600 --> 00:36:59,025
所以这可能是这样一个例子：
So this might be something like, an example of a unit test might be

537
00:36:59,025 --> 00:37:07,575
如果你正在编写一个 HTML 解析器，单元测试可能是测试它是否能够解析 HTML 标记。
if you're writing an HTML parser, the unit test might be test that it can parse an HTML tag. 

538
00:37:07,575 --> 00:37:12,475
而集成测试可能是这样一个例子：这是一个 HTML 文档，请解析它。
An integration test might be, here's an HTML document, parse it. 

539
00:37:13,050 --> 00:37:17,500
这将是解析器的多个子系统的集成。
So that is going to be the integration of multiple of the subsystems of the parser. 

540
00:37:18,575 --> 00:37:21,625
你还有一个称为回归测试的概念。
You also have a notion of regression tests. 

541
00:37:21,625 --> 00:37:26,750
回归测试是测试过去出现过问题的东西。
Regression tests are tests that test things that were broken in the past. 

542
00:37:26,750 --> 00:37:31,584
假设有人向你提交了一个问题，
So imagine that someone submits some kind of issue to you 

543
00:37:31,584 --> 00:37:37,175
并说如果我给它一个跑马灯标记，
and says your library breaks if I give it a marquee tag, 

544
00:37:37,225 --> 00:37:40,175
你的库就会出现问题，这让你很难过，所以你想要修复它。
and that makes you sad,  so you want to fix it.  

545
00:37:40,175 --> 00:37:43,525
因此，你将修复解析器以支持我的标记，
So you fix your parser to now support my key tags, 

546
00:37:43,525 --> 00:37:49,125
并在测试套件中添加一个检查是否可以解析跑马灯标记的测试。
but then you want to add a test to your test suite that checks that you can parse marquee tags. 

547
00:37:49,125 --> 00:37:52,186
这样做的原因是为了
The reason for this is so that in the future, 

548
00:37:52,186 --> 00:37:55,300
将来不会再次引入该错误。
you don't accidentally reintroduce that bug. 

549
00:37:55,775 --> 00:37:57,575
因此，回归测试非常有用，
So that is what regression tests are for, 

550
00:37:57,575 --> 00:38:00,325
随着时间的推移，你的项目将会积累越来越多这样的测试，
and over time your project is gonna build up more and more of these, 

551
00:38:00,325 --> 00:38:05,825
它们非常好，因为它们可以防止项目退回到早期的 bug。
and they're nice because they prevent your project from regressing to earlier bugs. 

552
00:38:06,100 --> 00:38:11,200
我想要提及的最后一个概念是模拟。
The last one I want to mention is a concept called mocking. 

553
00:38:11,275 --> 00:38:18,425
"mocking"是指能够用一种虚拟的方式替换掉系统的某些部分，
So mocking is the idea of being able to replace parts of your system 

554
00:38:18,425 --> 00:38:26,225
这种虚拟版本的行为是由你控制的。
with a sort of dummy version of itself that behaves in a way that you control. 

555
00:38:26,225 --> 00:38:31,950
一个常见的例子是，你正在编写一个
A common example of this is you're writing something that does, oh I don't know, 

556
00:38:31,950 --> 00:38:35,025
emm..用ssh拷贝文件？
file copying over SSH. 

557
00:38:35,025 --> 00:38:39,050
是的，通过SSH进行文件拷贝的工具。
Right? This is a tool that you've written that does file copying over SSH. 

558
00:38:39,050 --> 00:38:41,425
在这里，你可能想要模拟许多东西。
There are many things you might want to mock here. 

559
00:38:41,425 --> 00:38:45,950
例如，在运行测试套件时，
For example, when running your test suite, you probably don't actually care that there's a network there. 

560
00:38:45,950 --> 00:38:49,975
你可能并不关心是否有网络存在。
Right? You don't need to have to like set up TCP ports and stuff, 

561
00:38:49,975 --> 00:38:52,350
所以，你可以模拟网络。
so instead you're gonna mock the network. 

562
00:38:52,350 --> 00:38:55,900
通常的做法是，在你的库中，
The way this usually works is that, somewhere in your library,

563
00:38:55,900 --> 00:39:00,800
有一些东西打开连接，从连接中读取数据，或者向连接中写入数据。
 you have something that like opens a connection, or reads from the connection, or writes to the connection, 

564
00:39:00,800 --> 00:39:05,275
你会在你的库内部覆盖这些函数，
and you're gonna overwrite those functions internally in your library 

565
00:39:05,275 --> 00:39:08,925
使用你专门为测试而编写的函数。
with functions that you've written just for the purposes of testing, 

566
00:39:08,925 --> 00:39:11,775
例如，读取函数只会返回数据，
where the read function just like returns the data, 

567
00:39:11,775 --> 00:39:15,550
写入函数只会将数据丢弃。
and the write function just drops the data on the floor, or something like that. 

568
00:39:15,550 --> 00:39:19,750
同样，你可以为SSH功能编写一个模拟函数。
Similarly, you can write a mocking function for the SSH functionality. 

569
00:39:19,750 --> 00:39:22,425
你可以编写一个不实际进行加密和与网络通信的函数。
You could write something that does not actually do encryption, 

570
00:39:22,425 --> 00:39:24,150
这跟网络无关
it doesn't talk to the network: 

571
00:39:24,150 --> 00:39:27,450
这个函数只是接收字节，然后在另一端神奇地将它们弹出来。
it just like takes bytes in here and just magically they pop out the other side, 

572
00:39:27,475 --> 00:39:29,950
你可以忽略其中的一切，
and you can ignore everything that's between, 

573
00:39:29,950 --> 00:39:34,475
因为对于文件拷贝的目的，如果你只是想测试该功能，
because for the purpose of copying a file, if you just wanted to test that functionality, 

574
00:39:34,475 --> 00:39:37,325
那么下面的内容对于该测试并不重要。
the stuff below doesn't matter for that test, 

575
00:39:37,325 --> 00:39:39,725
你可能会嘲笑它。
and you might mock it away. 

576
00:39:39,725 --> 00:39:46,000
通常情况下，在任何一种语言中，都有工具可以很容易地构建这些模拟抽象。
Usually, in any given language, there are tools that let you build these kind of mocking abstractions pretty easily. 

577
00:39:46,825 --> 00:39:52,550
这就是我想讨论元编程的全部内容，
That is the end of what I wanted to talk about metaprogramming, 

578
00:39:52,550 --> 00:39:55,225
但这是一个非常广泛的主题。
but this is a very, very broad subject. 

579
00:39:55,225 --> 00:39:58,175
像持续集成、构建系统这样的东西，
Things like continuous integration, build systems, 

580
00:39:58,175 --> 00:40:03,000
有很多可以让你对你的项目做很多有趣的事情，
 there are so many out there that can let you do so many interesting things with your projects, 

581
00:40:03,000 --> 00:40:06,125
所以我强烈建议你稍微了解一下。
so I highly recommend that you start looking into it a little. 

582
00:40:06,125 --> 00:40:11,975
这些练习内容比较散，
The exercises are sort of all over the place, 

583
00:40:11,975 --> 00:40:13,625
但这是件好事。
and I mean that in a good way. 

584
00:40:13,625 --> 00:40:18,375
它们旨在尝试向你展示构建
They're intended to try to just show you the kind of possibilities that exist 

585
00:40:18,375 --> 00:40:21,700
和处理这些过程的各种可能性。
for building and working with these kind of processes. 

586
00:40:21,700 --> 00:40:28,050
例如，最后一个练习让你自己编写一个持续集成操作，
So, for example, the last exercise has you write one of these continuous integration actions yourself  

587
00:40:28,050 --> 00:40:33,575
你可以决定事件和操作是什么，
where you decide what the event be and you decide what the action be, 

588
00:40:33,575 --> 00:40:35,200
但要尝试真正地构建一个。
but try to actually build one. 

589
00:40:35,200 --> 00:40:38,450
这可能是你在项目中会发现有用的东西。
And this can be something that you might find useful in your project. 

590
00:40:38,475 --> 00:40:41,300
我在练习中给出的示例是
The example I gave in the exercises is 

591
00:40:41,300 --> 00:40:48,775
尝试构建一个操作，对你的存储库运行英语语言的语法检查，例如RightGood或Proselint。
to try to build an action that runs like write good or

592
00:40:48,800 --> 00:40:53,925
如果你真的这样做了，我们可以在课堂存储库中启用它，
And if you do like, we could enable that for the class repository 

593
00:40:53,925 --> 00:40:58,325
这样我们的讲义就会写得很好。
so that our lecture notes are actually well written. Right？

594
00:40:58,325 --> 00:41:02,475
这种持续集成测试的另一个好处是，
and this is one other thing that's nice about this kind of continuous integration testing, 

595
00:41:02,475 --> 00:41:05,875
你可以在项目之间进行协作。
is that you can collaborate between projects. 

596
00:41:05,875 --> 00:41:07,900
如果你编写了一个，我可以在我的项目中使用它，
If you write one, I can use it in my project, 

597
00:41:07,900 --> 00:41:13,050
如果你编写了一个，我可以在我的项目中使用它，
and there's a really handy feature where you can build this ecosystem of improving everything. 

598
00:41:13,050 --> 00:41:17,700
今天录制的任何内容有任何问题吗？是的，
Any questions about any of the stuff we recorded today? Yeah, 

599
00:41:31,225 --> 00:41:36,378
问题是，为什么我们既有make又有CMake？它们都是做什么的？
so the question is, why do we have both make and CMake? What do they do, 

600
00:41:36,378 --> 00:41:39,975
它们之间有交流的原因吗？
and is there a reason for them to talk together? 

601
00:41:40,100 --> 00:41:46,475
所以，CMake，我实际上不知道CMake的标语是什么，
So, CMake, I don't actually know what the tagline for CMake is anymore, 

602
00:41:46,475 --> 00:41:49,100
但它有点像C语言的更好的make。
but it's sort of like a better make for C. 

603
00:41:49,150 --> 00:41:54,250
顾名思义，
As the name implies, CMake generally 

604
00:41:54,250 --> 00:41:58,925
CMake通常比make文件更好地了解C项目的布局。
understands the layout of C projects a little bit better than make files do. 

605
00:41:58,925 --> 00:42:04,375
它们的建立是为了尝试解析您的依赖项结构是什么，
They're sort of built to try to parse out what the structure of your dependencies are, 

606
00:42:04,375 --> 00:42:06,000
从一个规则到另一个规则的转换。
what the rules are from going to one to the other. 

607
00:42:06,000 --> 00:42:10,850
它还与像系统库这样的东西集成得更好，
It also integrates a little bit nicer with things like system libraries, 

608
00:42:10,850 --> 00:42:14,900
因此CMake可以执行诸如检测计算机上的给定库是否可用，
so CMake can do things like detect given libraries available on your computer 

609
00:42:14,900 --> 00:42:17,425
或者如果该库在多个不同的路径上可用，
or if it's available at multiple different paths, 

610
00:42:17,425 --> 00:42:23,175
它会尝试找到其所在的路径，然后进行适当的链接。
it tries to find which of those paths it's present on on this system and then link it appropriately. 

611
00:42:23,175 --> 00:42:25,800
因此，CMake比make更智能。
So CMake is a little bit smarter than make. 

612
00:42:25,800 --> 00:42:29,300
make将只执行您在make文件中放置的任何内容。
Make will only do whatever you put in the make file. 

613
00:42:29,325 --> 00:42:34,975
这不是完全正确的，有称为隐式规则的东西，它们是make中的内置规则，
Not entirely true, there are things called implicit rules that are like built-in rules in make, 

614
00:42:35,050 --> 00:42:39,925
但它们非常简单，而CMake则尝试成为一个大型构建系统，
but they're pretty dumb, whereas CMake tries to be able to be a larger build system that is 

615
00:42:39,925 --> 00:42:42,875
它默认针对C项目工作。
 opinionated by default to work for C projects. 

616
00:42:42,925 --> 00:42:49,500
同样，还有一个名为Maven和Ant的工具，这是另一个项目。
Similarly, there's a tool called Maven and Ant, which is another project. 

617
00:42:49,525 --> 00:42:52,025
它们都是为Java项目构建的。
They are both built for Java projects. 

618
00:42:52,025 --> 00:42:57,250
它们了解Java代码如何相互交互，如何构造Java程序，
They understand how Java code interacts with one another, how you structure Java programs, 

619
00:42:57,300 --> 00:42:59,525
并为此而构建。
and they're built for that task. 

620
00:42:59,525 --> 00:43:02,025
通常，当我使用make时，
Very often, at least when I use make, 

621
00:43:02,025 --> 00:43:07,650
我会在顶部使用make，然后使其他工具
I use make sort of at the top and then make my call other tools that build 

622
00:43:07,650 --> 00:43:09,800
构建的任何你知道的子系统。
 whatever subsystem they know how to build. 

623
00:43:09,800 --> 00:43:11,525

right,like my make file,

624
00:43:14,444 --> 00:43:17,719

and then call cmake to build like c dependency of that 

625
00:43:19,575 --> 00:43:21,575

I'm gonna do some stuff at the end of 

626
00:43:29,925 --> 00:43:33,050
对我来说，make是我可能编写的顶部粘合剂。
For me, make is sort of the glue at the top that I might write. 

627
00:43:33,050 --> 00:43:39,425
通常，如果您的make文件变得非常大，有更好的工具。
Usually, if your make file gets very large, there's a better tool. 

628
00:43:40,100 --> 00:43:42,850
您会发现在大公司，例如谷歌，
What you'll find at big companies, for example, 

629
00:43:42,850 --> 00:43:47,100
他们通常有一个构建系统来管理其所有软件。
is they often have one build system that manages all of their software. 

630
00:43:47,100 --> 00:43:51,250
因此，如果您看看谷歌，他们有这个名为Basil的开源系统，
So if you look at Google, for example, they have this open-source system called Basil, 

631
00:43:51,250 --> 00:43:56,100
我不认为谷歌在谷歌内部直接使用Basil，
and I don't think Google literally uses Basil inside of Google, 

632
00:43:56,100 --> 00:43:59,275
但它基于他们在内部使用的构建系统。
but it's sort of based on what they use internally. 

633
00:43:59,275 --> 00:44:04,825

And it's really just intended to manage the entire build of everything Google has. 

634
00:44:04,825 --> 00:44:12,300
Basil实际上是建立为一种多语言构建框架，
And Basil, in particular, is built to be, I think they call it, like a polyglot build framework. 

635
00:44:12,300 --> 00:44:15,400
因此，这个想法适用于许多不同的语言。
So the idea is that it works for many different languages. 

636
00:44:15,400 --> 00:44:20,875
有像这种语言和那种语言的Basil模块，
There's like an implement, there's a module for Basil for this language and that language in that language, 

637
00:44:20,875 --> 00:44:23,875
但它们都与相同的Basil框架集成，
but they all integrate with the same Basil framework, 

638
00:44:23,875 --> 00:44:29,500
然后该框架知道如何在不同库和不同语言之间集成依赖项。
which then knows how to integrate dependencies between different libraries and different languages.

639
00:44:30,225 --> 00:44:31,400
你有问题吗？
Got a question? Sure.

640
00:44:39,150 --> 00:44:44,150
当你说表达式时，你是指这个文件中的东西吗？
So when you say expressions, you mean the things in this file? Or yeah, 

641
00:44:44,150 --> 00:44:46,375
是的，
so these are ...

642
00:44:49,050 --> 00:44:53,137
所以make文件是它们自己的语言。
so make files are their own language

643
00:44:53,137 --> 00:44:57,375
这是一种相当奇怪的语言。
They are...It's a pretty weird language. 

644
00:44:57,375 --> 00:45:00,250
就像Bash一样，它有很多奇怪的例外。
Like, it has a lot of weird exceptions. 

645
00:45:00,250 --> 00:45:03,225
在很多方面，它就像Bash一样奇怪，
In many ways, it's weird just like bash is weird, 

646
00:45:03,225 --> 00:45:05,300
但在不同的方面更糟糕。
but in different ways, which is even worse. 

647
00:45:05,300 --> 00:45:07,500
当你编写makefile时，
Like, when you're writing a make file, you sort of, 

648
00:45:07,500 --> 00:45:09,700
你可能会认为自己正在编写Bash，
you can sort of think like you're writing bash, 

649
00:45:09,700 --> 00:45:11,950
但实际上它有不同的错误。
but you're not because it's broken in different ways. 

650
00:45:11,950 --> 00:45:14,475
但是，它确实是一种独立的语言。
but it is its own language. 

651
00:45:14,500 --> 00:45:18,050
makefile通常的结构是你有一系列的指令，
And the way that make files are generally structured 

652
00:45:18,050 --> 00:45:22,450
我想他们称之为指令。
is that you have a sequence of, I think they call them directives. 

653
00:45:22,500 --> 00:45:28,525
所以，每一个喜欢，这个东西（哎呀）这个东西是一个指令，
So, every like, this thing (oops) this thing is a directive, 

654
00:45:28,525 --> 00:45:30,050
这是一个指令。
and this is a directive. 

655
00:45:30,050 --> 00:45:33,175
每个指令都有一个冒号，
And every directive has a colon somewhere, 

656
00:45:33,175 --> 00:45:35,775
在冒号左侧的是一个目标，
and everything to the left of the colon is a target, 

657
00:45:35,775 --> 00:45:42,050
在冒号右侧的是一个依赖项。
and everything to the right of the colon is right of the colon is a dependency. 

658
00:45:42,050 --> 00:45:45,850
然后，下面的所有行都是操作序列，
And then all of the lines below that line 

659
00:45:45,875 --> 00:45:52,250
也称为规则，用于一旦你有了依赖项，
are the sequence of operations known as the rules for once you have the dependencies. 

660
00:45:52,250 --> 00:45:53,725
如何构建这些目标？
How do you build these targets?

661
00:45:53,725 --> 00:45:59,725
注意，makefile非常注重你必须使用制表符来缩进规则。
 Notice that make is very particular that you must use a tab to indent the rules. 

662
00:45:59,800 --> 00:46:02,325
如果不这样做，make就不会工作。
If you do not, make will not work. 

663
00:46:02,325 --> 00:46:05,525
它们必须是制表符，不能是4或8个空格，
If they must be tabs, they cannot be four eight spaces. 

664
00:46:05,525 --> 00:46:06,250
必须是制表符。
Must be tabs. 

665
00:46:06,375 --> 00:46:09,650
你可以在这里有多个操作。
And like, you can have multiple operations here. 

666
00:46:09,650 --> 00:46:11,675
我可以做echo hello或其他什么，
I like I can do echo hello or whatever, 

667
00:46:11,675 --> 00:46:15,125
然后它们将首先运行这个，然后运行这个。
and then they would first run this and then run this. 

668
00:46:15,225 --> 00:46:19,000
今天的讲座中有一个练习，
There's a there's an exercise for today's lecture that

669
00:46:19,000 --> 00:46:22,750
让你尝试扩展这个makefile，加入一些其他有趣的目标，
 has you try to extend this make file with a couple of other targets that

670
00:46:22,750 --> 00:46:25,625
更详细地介绍一下。
 you might find interesting that goes into a little bit more detail. 

671
00:46:26,650 --> 00:46:31,675
还有一些能力来执行外部命令，
There's also some ability to execute external commands 

672
00:46:31,675 --> 00:46:35,000
以确定依赖项可能是什么，
to like determine what the dependencies might be

673
00:46:35,000 --> 00:46:38,250
如果你的依赖项不是静态文件列表，
  if your dependencies are not like a static list of files, 

674
00:46:38,250 --> 00:46:39,350
但是它有一点限制。
but it's a little limited. 

675
00:46:39,350 --> 00:46:42,650
通常，一旦你开始需要这种东西，
Usually, once you've started needing that sort of stuff, 

676
00:46:42,650 --> 00:46:45,900
你可能需要转移到更高级的构建系统。
you might want to move to a more advanced build system. 

677
00:46:48,975 --> 00:46:49,750
是的，
Yeah, 

678
00:46:58,050 --> 00:47:09,900
问题是，如果我有，假设我有库a和库b，
so the question is what happens if I have, let's say that I have library a and library b, 

679
00:47:10,025 --> 00:47:13,300
它们都依赖于库c，
and they both depend on library c, 

680
00:47:13,300 --> 00:47:18,875
但库a依赖于4.0.1，
but library a depends on like 4.0.1, 

681
00:47:18,875 --> 00:47:24,150
库b依赖于3.4.7，
and library b depends on 3.4.7. 

682
00:47:24,725 --> 00:47:26,775
所以它们都依赖于 c，
So they both depend on c, 

683
00:47:26,775 --> 00:47:28,750
理想情况下，我们希望重用 c，
and so ideally, we'd like to reuse c, 

684
00:47:28,750 --> 00:47:31,425
但它们依赖于不同的主要版本的 c。
but they depend on different major versions of c. 

685
00:47:31,425 --> 00:47:32,475
我们该怎么办？
What do we do? 

686
00:47:32,725 --> 00:47:37,675
这种情况下发生的情况完全取决于您正在使用的系统和语言。
Well, what happens in this case depends entirely on the system that

687
00:47:37,675 --> 00:47:39,825
呃呃呃
 you're using, the language that you're using. 

688
00:47:39,825 --> 00:47:43,800
在某些情况下，工具会选择其中一个版本，
In some cases, the tool would just be like, well, I'll just pick for 

689
00:47:43,800 --> 00:47:47,175
这暗示它们实际上没有使用语义化版本控制。
which sort of implies that they're not really using semantic versioning. 

690
00:47:47,175 --> 00:47:52,725
在某些情况下，工具会显示“不可能”。
In some cases, the tool will say, this is not possible. 

691
00:47:52,725 --> 00:47:54,700
如果这样做，会导致错误，
Like, if you do this, it's an error, 

692
00:47:54,700 --> 00:47:58,850
并且工具将告诉您需要升级 b，
and the tool will tell you you either need to upgrade b , 

693
00:47:58,850 --> 00:48:03,225
例如使 b 使用 c 的较新版本，或者降级 a。
like have b use a newer version of c, or you need to downgrade a. 

694
00:48:03,225 --> 00:48:04,700
你不能这样做，
You do not get to do this, 

695
00:48:04,700 --> 00:48:06,350
编译将失败。
and compilation will fail. 

696
00:48:06,350 --> 00:48:10,700
有些工具将构建两个版本的 c，
Some tools are gonna build two versions of c, 

697
00:48:10,700 --> 00:48:17,850
然后在构建 a 时使用 c 的主要版本 4，
and then like when it builds a, it will use the major four version of c, 

698
00:48:17,850 --> 00:48:21,450
在构建 b 时使用 c 的主要版本 3。
and when it builds b, it will use the major three version of c. 

699
00:48:21,600 --> 00:48:25,900
你最终会遇到一些非常奇怪的情况，
One thing you end up with is really weird conditions here were like

700
00:48:25,900 --> 00:48:27,558
例如如果 c 有依赖项，
你可能会遇到特别奇怪的情况。
 if c has dependencies, 

701
00:48:27,558 --> 00:48:31,900
则现在必须将所有 c 的依赖项都构建两次，一次用于 3，一次用于 4，
then now you have to build all of c's dependencies twice to 1 for 3 and 1 for 4, 

702
00:48:31,950 --> 00:48:34,550
也许它们共享，也许它们不共享。
and maybe they share and maybe they don't. 

703
00:48:34,550 --> 00:48:37,250
最后这将会大寄特寄
You can end up in particularly weird situations. 

704
00:48:37,250 --> 00:48:44,375
如果想象一下库 c，
If imagine that the library c, like... 

705
00:48:44,400 --> 00:48:56,975
比如说库 c 写入一个文件，比如说写入磁盘上的一些缓存。
imagine that library c  , like rights to a file, like rights to some like file on disk, some cache stuff.

706
00:48:57,075 --> 00:49:02,975
如果现在运行您的应用程序，a 做了一些调用，比如调用 c.save，
If you run your application now and like a does something to call like c. save 

707
00:49:02,975 --> 00:49:05,725
而 b 做了一些调用，比如调用 c.adult load，
and b to something like c.adult load, 

708
00:49:05,725 --> 00:49:11,500
那么底层的应用程序就不会工作，因为格式是不同的，对吧？
then suddenly your application of the bottom is not going to work because the format is different, right? 

709
00:49:11,500 --> 00:49:13,850
因此，这些情况通常非常棘手，
So, these situations are often very problematic, 

710
00:49:13,875 --> 00:49:20,325
大多数支持语义化版本控制的工具会因为这个原因拒绝这种配置。
and most tools that support semantic versioning will reject this kind of configuration for exactly that reason. 

711
00:49:20,325 --> 00:49:22,850
但是，要自己搞砸是很容易的。
But it's so easy to shoot yourself in the foot. 

712
00:49:25,850 --> 00:49:29,300
好了，我们明天再见，进行安全方面的学习。
All right, we will see you again tomorrow for security. 

713
00:49:29,300 --> 00:49:32,200
请记住，如果您还没有填写问卷调查，请务必参加。
Keep in mind, again, if you haven't done the survey, 

714
00:49:32,200 --> 00:49:35,300
在问卷调查中，我最关心的问题是
the question I care the most about in the survey 

715
00:49:35,300 --> 00:49:39,050
您希望我们在最后两节课中涵盖什么内容。
is what you would like us to cover in the last two lectures. 

716
00:49:39,050 --> 00:49:43,576
因此，请选择您想要我们讨论的主题
So, the last two lectures are for you to choose what you want us to talk about 

717
00:49:43,576 --> 00:49:46,350
并提出任何问题。
and to give any questions you want us to answer. 

718
00:49:46,350 --> 00:49:48,375
如果可以，请填写问卷调查。
So please, like, add that if you can. 

719
00:49:48,375 --> 00:49:49,900
就这样，
And that's it. 

720
00:49:49,900 --> 00:49:50,675
明天见。
See you tomorrow.  

