好的，让我们开始今天的讲座吧。
在开始之前，我有一个关于办公时间的小提示。
根据调查，有些人误认为每次讲座后的办公时间只是针对当天的讲座主题，但实际上不是这样的。
你可以在办公时间来问我们任何问题，无论是关于前一天还是前一周的讲座，甚至是这门课程没有完全涵盖但你感到好奇的内容。
因此，如果你有关于任何事情的问题，都可以来办公时间问我们。
办公时间在32 g9休息室，这是32号楼，也称为Stata中心，有两座塔楼，G塔和D塔。
我们在Gates塔的第九层，所以如果你乘电梯一直上去，休息室就在你面前。
好的，很棒。
今天，我们将谈论版本控制系统。
我想了解一下你们是否有使用过版本控制系统。
所以，如果你有使用过git或任何其他版本控制系统，如subversion或mercurial等，能否举手呢？哦，太好了，有很多人。
因此，我就不会过多地谈论版本控制系统了，而是会很快地进入git及其数据模型和内部细节的详细讨论。
但是，简单地概括一下，版本控制系统是用于跟踪源代码或其他文件或文件夹集合的更改的工具。
正如名称所示，这些工具帮助跟踪某些文档的更改历史。
除了这些，它们还有助于协作，因此它们在软件项目团队中非常有用。
版本控制系统通过一系列快照跟踪文件夹及其内容的更改。
因此，你可以捕捉文件夹和其中的所有内容（例如软件项目），并在一系列快照中拥有多个版本。
每个快照都封装了某个顶级目录中包含的所有文件和文件夹的完整状态。
版本控制系统还会保存一些元数据，以及实际内容的更改。
这是为了方便确定某个人对特定文件的更改，或者何时进行了特定的更改。
因此，版本控制系统维护作者和提交时间戳等元数据，你也可以将额外的消息附加到这些快照上等。
那么，为什么版本控制很有用呢？即使你在独自完成项目，也很有用。
因此，您可以使用它查看您编写的旧版本代码，通过查看提交信息找出为什么更改了某些内容，使用不同的开发分支并行处理不同的事情而不会发生冲突，或者能够在保持不同功能独立的情况下修复错误，等等。
因此，即使您只是在小规模项目上工作，它也是一种非常有用的工具。
就像我认为这门课的讲师们即使在作业或班级项目等小规模事物上也使用git一样。

除了我们的研究或较大的软件项目外，版本控制还是一个非常强大的与他人合作的工具。
因此，它对于传递代码补丁，当不同人同时在同一代码块上工作时解决冲突等方面非常有用。
因此，无论是独自工作还是与他人合作，它都是一个非常强大的工具。
此外，它还具有一些非常实用的功能，可以帮助回答某些比较困难的问题，例如软件项目中编写了特定模块的人是谁，或者编辑了特定行的人是谁，为什么更改了这个特定的行，它是什么时候更改的，由谁更改的等等。
版本控制系统还具有一些非常强大的功能，我们可能会在今天的讲座结束时介绍，或者您可以在讲座笔记中找到。
例如，假设您已经在某个项目上工作了几年，然后注意到项目有些奇怪的地方已经损坏了，比如您有一些单元测试不再通过，而这不是刚刚才坏了，而是在一段时间前损坏了，您不知道这个回归是什么时候引入的。
精心编写的控制系统有一种自动识别这种情况的方式，比如您可以将其拿出来并给它一个单元测试，该测试目前失败，但您知道在过去的某个时候它是通过的，它可以二分搜索您的历史记录并确定到底是哪个代码更改导致了它的失败。
因此，如果您知道如何正确使用这些工具，就会有很多非常强大和高级的功能。
市面上有许多版本控制系统，Git已成为版本控制的事实标准，因此我们将在今天的讲座中介绍它。
我想向您展示一张漫画，之前已经放在屏幕上了，让我把它拿回来。
这是一部xkcd漫画，说明了Git的声誉。
我念给你们听。
'Git通过美丽的分布式图论树模型尝试协同工作。
很酷。
我们如何使用它？没想到。
只需记住这些shell命令并输入它们以同步。
如果出现错误，请将您的工作保存在其他地方，删除项目并下载新的副本。
'也许有些人可能不想举手，但如果你以前做过这件事，请举手。
我学习这个工具的时候也曾经这样做过，我想你们中的许多人也尝试过。
所以，本讲座的目标是让你们不必再这样做。
不幸的是，正如这个漫画所描绘的那样，Git的界面设计相当糟糕。
它是一个泄漏的抽象层，因此出于这个原因，我们认为自上而下地学习Git，从界面开始，可能不是最好的方式，它会导致一些混乱。
就像这个漫画所示，你可以记住几个命令，并将它们视为魔法咒语，认为一切都正常工作。
这样做还算可以，但是一旦出了问题，你就必须像这个漫画中描述的那样处理。
虽然Git有一个丑陋的界面，但它的基本设计和思想实际上非常优美。

一个丑陋的界面需要被记忆，但是Git下面美妙的理念却可以被真正理解。
一旦你理解了Git的内部结构和数据模型（实际上并不那么复杂），你就能学会Git的界面。
你需要记住一些东西，但是通过理解它们是如何操作底层数据模型的，你可以理解某些命令的确切作用。
所以，我们今天教授Git的方式是，首先抽象地讲述数据模型，讨论如何对文件和文件夹进行建模、历史快照以及它们之间的关系。
然后，我们将介绍一些Git命令，最后，在资源和练习中，我们将链接到教程，让你学会所有具体的命令，因为你最终需要学习很多不同的命令。
关于我们今天的教学方法，你们有什么问题吗？好的，那我们开始吧。
可能有很多临时方法可以用于版本控制，我猜你们中的一些人可能以前就这样做过。
比如说，你有一些文件或文件夹，对应于一个系统软件项目，你想追踪变化。
你可以每天复制整个文件夹，并给它加上一个时间戳。
当你想与其他人合作时，你可以将整个文件夹转换成一个zip压缩文件，并将其发送给某个人。
然后，当你和你的朋友在软件项目的两个不同特性上工作时，你们可以并行地工作。
然后，其中一个人将zip文件发送给另一个人，然后你手动复制并粘贴适当的代码片段到你的代码中，以便最终得到一个具有你们两个特性的代码。
这种方法可能会有所作用。
如果你曾经这样做过，请举手。
我肯定做过。
尽管如此，还有一些人认为我们不应该这样做。
Git有一个经过深思熟虑的模型，可以促进这些交互，例如跟踪你项目的历史记录、协作等等。
Git将历史记录建模为一组文件和文件夹，位于某个顶层目录中。
因此，你可能已经从自己计算机上的文件和文件夹的抽象概念中熟悉这种建模方法。
这里是一个例子：你可能有一个顶层目录，我会称之为根目录，这个目录中可能有一个名为foo的文件夹，这个文件夹中可能有一个名为bar.txt的文件，其中可能有一些内容，比如“Hello world”。

然后，也许这个最高层目录中有一个文件夹，它也可以有另一个文件。
比如说，还有一些其他的文件，这个文件也有一些内容。
很简单。
Git用于这些不同内容的术语是这样的：最高级的东西称为树。
所以这是一个文件夹，然后我们通常称为文件的东西称为blob。
好的，现在我们有了一个文件和文件夹的模型，这是一种递归数据结构。
树可以包含其他树，然后树可以包含树和文件。
显然，文件不能包含树。
好的，现在我们有了一个文件和文件夹的模型，而这个东西的顶级，我刚刚标记的“根”，是正在被跟踪的目录。
就像您可能在计算机上有一些文件夹对应于软件项目一样。
现在，如何建立历史模型呢？一旦你有了文件和文件夹的模型，你可以想象一种方法，就是你对整个东西进行快照，然后历史就是一系列的快照。
就像你可以想象它，你几乎可以认为你有日期和时间戳的文件夹副本。
嗯，它不使用这样简单的线性模型。
它使用的是一种稍微复杂的东西。
你可能听过这个术语，但是Git使用有向无环图来模拟历史。
这听起来像一堆花哨的数学词，但实际上并不是很复杂。
在Git中，每个快照都有一些父节点，基本上，我们想知道哪个变化先于另一个变化。
所以假设这里，我将使用圆圈来表示单独的快照。
这是这个树中的所有内容，所以是我的项目中的所有文件和文件夹。
我的整个项目可能处于某种状态，然后我编辑了一些文件，现在它处于某种其他状态。
然后我添加了一些文件，它又处于另一种状态。
每个状态都指向先前的状态。
到目前为止，这是一个线性历史，但它让我们能够做一些稍微花哨的事情。
你还可以从某个快照分叉你的历史，并说，“我想基于这个版本做出一些更改，并创建一个新的快照。
”这种建立历史的方式允许您做一些像“好的，我正在开发我的项目。
这是我的主要开发线路。
我到这里了，现在我有两个不同的任务要完成。”
假设一方面，我有一些想要添加到我的项目中的新特性，所以我要花几天的时间去工作。
但另一方面，有人向我报告了一个 bug，我需要去找出这个 bug 并修复它。
那么，与其同时在同一条开发线上并发地工作在所有这些事情上，Git 有其将历史记录分支成两个独立的分支的方式，并以一种不相关的方式同时处理不同的事情。
因此，我可以使用这个基本快照，例如我的项目处于一种可工作的状态，然后从这里开始实现一个新的特性来创建一个新的快照。
因此，这个快照包括基本项目和一个新的特性。
同样地，与此同时，我可以回到这个原始快照，因为我不想在实现新特性时进行 bug 修复，所以我可以回到这里，然后进行 bug 修复并创建一个不同的快照。
因此，这个快照只有 bug 修复，而没有特性。
最后，一旦我并行地完成了这两件不同的事情，最终，我想将它们全部合并到我的共同源代码中，既包括特性，也包括 bug 修复。
因此，最终，我可以通过合并这两个不同快照中存在的更改来创建一个新的快照。
因此，这个新的快照将具有这两个快照作为父节点，这个版本将同时包括特性和 bug 修复。
所以，是否理解了 Git 以一种比文件和文件夹的序列更为复杂的方式来模拟历史记录的原因？为什么要支持分支以并行工作，然后再合并来自不同并行开发分支的更改呢？问题：是的，这是一个很好的观点。
似乎当您合并时，可能会创建意外的错误。
您可以想象这里的特性实际上更改了某些使这个 bug 修复变得无关紧要的东西，或者您可以想象这个 bug 修复破坏了这个特性或其他类似的情况。
答案：哦，这是一个非常好的观点。
这就是所谓的合并冲突，Git 在合并并行开发分支时会尝试自动以保留所有重要更改的方式来合并这些更改。
但如果它变得混乱了，它会报告一个合并冲突，然后让程序员自己决定如何将并发的更改组合到同一文件或其他类似的地方。
然后Git有一些工具来帮助解决这个问题。
还有其他问题吗？太好了。
现在我们有了文件和文件夹的模型，还有一个关于历史的模型，它描述了我们代码的不同快照之间的关系。
这里有一个小细节，每个圆圈都对应一个快照，就像一个带有文件和文件夹的树一样，但它们还有一些元数据。
例如，在这里，我们可能会看到提交的作者是我，还有其他元数据，例如与此提交相关的消息。
我可以描述我所做的更改类型，这些更改在该快照中存在但在上一个快照中不存在。
这不是椅子类，所以下一步我们要谈论比这更低一层的内容，即Git内部如何表示这个数据结构。
因此，我将写下伪代码，因为我认为这是最容易理解的方式。

首先我们有文件。
所以一个blob只是一堆字节，我会说这是一个字节数组。
好的，那么什么是tree？记住这只是一个文件夹，那么文件夹是什么？它们是从文件名或目录名到实际内容的映射，而内容可以是另一个tree，如子树，或者是文件。
最后，我们有最后一件事情，到目前为止我一直称之为快照，在Git术语中它们被称为提交。
那么提交做了什么？它有一堆东西。
提交有描述它们之前的父项，因此在大多数普通提交的情况下，它们有一个父项，就像它们来自哪里一样。
合并提交可以有多个父项，因此父项是提交的数组，然后我有一些元数据，如作者和可能的消息，最后是实际内容，快照，它是一个树，是对应于特定提交的顶级树。
这是一个非常干净简单的历史模型，这基本上就是Git模型历史的全部内容。
关于这个有问题吗？好的，现在我们深入一些。
让我们谈谈它实际上是如何存储和寻址这些实际数据的。
在某个时候，这实际上必须转换为磁盘上的数据，对吧？因此，Git定义了一个对象，这是一个大型的术语，但是对象可以是其中三个中的任何一个，因此它可以是blob、tree或commit。
然后在Git中，所有对象都是内容寻址的。
所以Git在磁盘上维护的是一组对象，这些对象被维护为这个内容地址存储。
因此，如果你有其中的任何一个对象，你将它放入这个存储的方式是它的键是对象的哈希值。
例如，在伪代码中，我可能会说为了存储特定的对象o，我计算它的ID，通过对o进行SHA-1哈希，然后将其放入我的对象映射中，存储到磁盘上。
一个快速举手的人，谁知道哈希函数是什么？好的，我会快速总结一下。
基本上，哈希函数是你可以把它看作是这个神奇的函数，它将大量数据转换为一个短字符串。
在高层次上，这些被用来，或者说这可能是足够的临床医生，我不会在这里深入讨论太多细节，但是如果你感兴趣，可以在之后问我。
基本上，哈希函数给了我们一种基于所输入的内容，从而以一种确定性的方式为其命名的方法，并为其提供一个简短的名称。
然后，与存储相反，我们可以通过ID来查找和加载存储在存储库中的内容。
这就是我们通过ID从对象存储库中检索内容的方法。
有关此方面的任何问题吗？好问题。
那么它用的是哪种语言编写的？它是用我刚刚编写的伪代码编写的。
Git的实现主要是用C编写的，并包括一些Bash和Perl脚本，我想。

还有其他问题吗？这个虚构的语言是否足够清晰，还需要解释其中的某些方面吗？好的，Blobs、树和提交在Git中是以这种方式统一的。
它们都是对象。
而且，正如您在这里描述的那样，看起来提交包含了许多其他提交和快照等内容。
实际上并不是这样。
相反，所有这些都是指针。
因此，提交将能够通过它们的ID引用许多父对象。
所以这实际上不是提交本身的数组，而是ID。
同样，提交中的快照不是实际的树对象，而是树的ID。
因此，所有这些对象都存储在这个对象存储中，并且所有对不同对象的引用仅通过它们的ID，即它们的SHA-1哈希来实现。
这有意义吗？你几乎可以将其映射到像Java这样的编程语言中的对象，这是对树的引用。
因此，它就像一个指针，而这就是您的领域。
也许这对您有所帮助，也许没有。
是的，确切地说就是这样。
那么，这是Git的磁盘数据存储。
这是一个内容地址存储，其中对象通过其哈希寻址。
对此有任何问题吗？好的，现在我们有一种识别的方法。
我们将所有不同类型的对象统一为称为对象的一种类型，并通过它们的SHA-1哈希方式来标识对象。
这些实际的SHA-1哈希长什么样子？它们是40个字符长的十六进制字符串。
就像SHA-1是一个160位的哈希函数，因此由该SHA-1函数返回的实际ID之一将是一个非常长的字符串。
因此，我们将有识别这些不同事物的方法。
就像对于一个3-2 CEB，我们会有相应的ID，例如某个东西。

现在我们有一种命名提交图中所有内容的方法，但这些名称非常不方便，因为它们非常长，而且像文本字符串一样，对人类来说没有任何意义。
Git解决这个问题的方法是另外一件事情。
Git维护一组对象，然后维护一组引用。
引用是什么？我来擦掉左边的一部分。
引用位于这里。
所以这是Git内部维护的另一个数据部分。
引用是一个从字符串到字符串的映射，你可以将其看作是将人类可读的名称映射到那个长的十六进制字符串。
因此，使用这些引用，你可以想象如何创建新的引用和更新引用等。
有了这个，我现在可以用名称来引用我的提交图中的内容，因此我可能会将其命名为“修复错误”或者我可能会为此处的内容命名等等。
因此，是的，使用这个，Git可以使用人类可读的名称来引用历史中特定的快照，而不是使用这些长长的十六进制字符串。
这里还有一件需要注意的事情是，鉴于Git的历史设计，整个图形实际上是不可变的。
你可以添加新的内容，但你实际上无法操作这里的任何东西。
我不会详细解释为什么或如何，但是请假设这是事实。
然而，引用是不可变的。
因此，在更新历史记录时，假设你继续在这个软件上工作，你创建了一个新的提交，我用圆圈表示它。
这个提交指向前一个提交。
我实际上可以将我的“修复错误”引用指向这里。
我可以更新此引用以现在指向这里。
但是，例如，我不能使其指向这里。
那甚至都没有意义，因为这只是这个对象的哈希值。
要更改此哈希值，我需要更改对象的内容，这并不真实。
好的，有关此方面的任何问题吗？这基本上就是Git的数据模型。

然后我们将进入通过命令行与 Git 进行交互，并看到 Git 命令如何与图形数据结构的操作相对应。
如果关于将历史记录建模为树、子树和快照、这些称为提交的东西如何链接在一起以及如何使用引用指向该图中的特定节点等方面有任何问题，请提出来。
好的，没有问题了？所以基本上，一旦我们拥有了对象和引用，那就基本上是 Git 存储库的全部内容。
这些是它存储的两个数据部分，在高层次上，所有 Git 命令行命令只是对引用数据或对象数据的操作。
所以，在本讲座的剩余部分中，我将介绍一些 Git 命令。
这基本上将是一个交互式演示，类似于 Vim 讲座，然后您可以参考笔记以获取有关这些命令的完整信息。
当然，它是一个非常强大的工具，我们无法在20分钟内覆盖所有内容。
好的，那么我要转到一个名为playground的文件夹，并创建一个名为demo的新目录。
进入demo，该目录将表示我的项目的顶层。
它当前是空的，因为我刚刚创建它。
如果我想将其转换为 Git 存储库，则使用 'git init' 命令。
 'Git init' 代表 Git 初始化，我们看到它说 'initialized empty Git repository in blah blah slash dot Git'。
如果我输入 'ls'，我仍然什么也看不到，但是如果我输入 'ls -a'，这个目录中有一个名为 '.git' 的隐藏文件。
如果我输入 'ls .git'，则会有一些东西显示在这里。
这是磁盘上 Git 存储其所有内部数据的目录，即对象和引用，实际上在这里，对象和引用是两个目录，所有存储库数据将存储在这两个目录的下面。
在我们进行这些操作时需要记住一个字母命令，那就是称为 'git help' 的命令。
'Git help' 将子命令作为参数，它会为您提供有关该命令的帮助。
例如，如果我输入 'git help init'，它将告诉我有关 'git init' 命令的信息。
现在有一些命令可以用于查明 Git 存储库的情况，例如 'git status'。
在高层次上，它说目前的情况是什么，我们在这里看到（现在先忽略第一行），第二行说 '还没有提交'。
这是因为我们刚刚初始化了一个全新的存储库，所以还没有历史记录。
我现在要......还有人需要吗？清晰地擦掉这个黑板的这部分。
随着我们进行Git命令的输入，我会画出底层的对象和引用数据如何变化的图示。
因此，现在这张或者说没有图示代表着我们仓库的当前状态。

它是空的。
没有快照。
那么让我们来修复一下。
让我们添加一些内容到我们的历史记录中。
在这里我们没有文件，所以让我来创建一个文件'hello.txt'，内容为'Hello, world!'。
通常情况下，您会在其中放置实际有用的源代码。
现在我想要做的是，当我输入某些Git命令时，随着我们的进行，绘制底层对象和引用数据发生变化的方式。 
因此，现在，这张图片或缺乏图片代表我们仓库的当前状态。 
您可以想象一个用于此的界面，其中有一个git快照命令或获取其他命令，它将获取当前目录的整个状态的快照。
由于许多原因，Git没有一个完全像那样工作的命令，因为Git希望为您提供一些灵活性，以便包括在您下一个快照中的更改。
这有时对初学者来说有些困惑，因此我现在尝试解释一下。


Git有一个称为staging area的东西，从高层次上讲，这是您告诉Git应包括在您下一个快照中的更改的地方。
如果我们在这里执行git status，我们会看到Git说“尚未提交任何更改”，就像之前一样，并且它说“未跟踪文件hello.txt”。
这意味着Git注意到当前目录中有一个新文件，但是它不会被包括在下一个快照中。
Git现在有点忽略它。
但是，如果我执行git add hello.txt并再次执行git status，它会说“现在提交的更改：新文件hello.txt”，因此，如果我执行git快照命令，实际上是git commit，它会创建一个我在那边画的那些圆圈中的新圆圈，并将该文件包含在我即将要进行的快照中。
所以让我继续运行git commit。
它弹出我的文本编辑器，让我输入与此提交相关联的消息。
编写高质量的提交消息真的很重要，因为以后当您查看项目的版本历史记录时，您会知道为什么进行了某些更改。
我将添加这个相对无用的提交消息，但是我们在讲义中有一个指南，告诉您如何编写高质量的提交消息。
现在我已经这样做了，Git输出一些输出。
主分支，暂时忽略那部分。
这个东西是我刚刚创建的提交的哈希值。
因此，现在我在我的历史记录中有一个单一节点。
这个节点里有一个树形结构，其中包含一个单独的 blob，也就是一个文件 hello.txt，内容是“hello world”。
然后这个节点有一个 SHA-1 哈希值，是2fb等等一些值（实际上在 Git 界面中也被截断了）。

这只是再次输出我的提交消息，并提醒我刚刚添加了hello.txt文件。
如果我现在使用git log命令，它非常有用，因为它可以帮助你可视化历史记录、提交图形，如果我做... 这是一个很好的问题。
那么这个哈希值到底对应什么？这是提交的哈希值。
提交内部包含树的哈希值，以及其他任何信息。
所以我可以使用git cat-file -p这个号码。
这有点像一个Git内部命令，可以打印出这个提交的内容，因此您可以看到它映射到我在那边画的数据结构。
所以这个提交里面有这个树，然后我是作者，这是提交的消息等等，我可以继续往下挖。
所以，您可以取这个树的哈希值，并执行git cat-file -p这里的哈希值。
它说这个树里面有一个名为hello text的条目，那个文件有一个blob，并且有这个哈希值。
我可以做git cat-file -p <哈希值>，它会显示我那个文件的实际内容。
这些都是探索对象存储中对象的内部Git命令。
问题是一个好问题。
那么问题是，为什么我必须使用git add？为什么不能只提交所有更改？答案是，其实有一种方法可以提交所有更改。
如果您执行git commit -a，这会提交所有被Git跟踪的文件所做的更改。
因此，任何包含在先前快照中但自那时起已被修改的内容都不包括在内。
还有git add的变体。
例如，如果您执行git add :/，这将添加存储库顶部自上而下的所有内容。
但是在更高的层面上，我们之所以有git add和git commit之间的这种区分，而不是只快照整个目录，是因为经常有情况您不希望在当前的快照中包含所有内容。
例如，以下是一些示例。
其中之一是，我可能正在处理我的项目，然后实现了两个功能。
也许我不想有一个单独的快照，在这个快照之后，它会像“我实现了功能A和功能B”一样。
也许我想在历史记录中创建两个单独的节点，以便它看起来像我先实现了功能A，然后在此基础上实现了功能B。
因此，我有一个仅包含A的快照，然后下一个包含A和B。
git add是一个工具，像暂存区一样是一个工具，它将允许我做这种事情。

另一个例子是，假设我正在修复一个 bug，我在我的代码中放置了 printf 语句，最终我找到了 bug，发现在某个地方有一个 +1，而那里不应该有 +1。
所以，我去修复了那个问题，然后想要使用我的修复程序创建一个新的快照，但是这个快照可能不应该包括我所有的打印语句。
它只需要包括去掉那个 +1 的修复。
所以，我可以手动删除所有的打印语句，但 Git 有更好的解决方法。
实际上，有一种方法可以指定我只想添加删除那个 +1 的更改，然后我就可以提交它，拍摄新的快照，然后可以丢弃所有其他更改。
有一些命令可以做到这一点，其中一些在讲义中有链接。
这些是使用暂存区帮助你的两种方式，也是为什么没有像“快照全部”这样的命令。
是的，约翰指出另一个例子是，你可能在当前目录中有日志文件，在运行程序时会运行这些日志文件，你可能不想在拍摄快照时包括它们。
还可能有其他一些东西，比如如果编译你的项目，你最终会得到一堆.o和类 ELF 文件。
你可能不想让这些成为你的历史的一部分。
所以，回到之前我给你展示的内容，我将清除终端屏幕，然后向你展示 git log 命令。
所以，git log 允许你可视化版本历史记录，这是一个非常有用的命令。
默认情况下，git log 显示版本历史记录的一个平面化版本。
所以，即使版本历史记录是一个图形，这也会将其线性化，并按顺序显示事物。
我个人觉得这很困惑，所以我几乎从不使用 git log。
相反，git log 接受一些参数，实际上将历史记录显示为一个图形。
所以你现在可以把它看作是一个魔法咒语，如果你想弄清楚每个标志的确切作用，你可以阅读文档。
但现在，这看起来并没有那么不同，因为我们的图形只有一个节点。
所以，将其可视化为一个平面化的东西和一个图形并没有太大的区别。
让我创建一个新的快照，然后我们可以再次运行这个命令，看看它到底做了什么。

那我将在hello.txt中加入另一行，如果我使用cat hello.txt命令，它将显示之前的内容再加上新加的内容。
我可以使用git commit命令，但会发现似乎什么都没有发生。
它只会显示 "no changes added to commit" 或 "no changes staged for commit." 为什么呢？因为我没有将新加的内容加入到staging area（暂存区）。
我没有告诉git，"这是应该包含在下一次快照中的内容"。
因此，如果我运行git add hello.txt命令，git status将显示"好的，这个修改已准备好被提交了。
"现在我可以运行git commit命令了。
我会输入一个无用的提交消息，然后新的更改就完成了。
这样，我的历史记录中就有了另一个节点，这个节点有一个在屏幕上显示的哈希值。
如果我重新运行之前的命令，即带有所有这些参数的git log命令，它实际上开始看起来更像一个图。
在这里，你会注意到这就像那个图被旋转了90度一样。
更近期的提交被垂直地显示在顶部。
这里显示了一个提交，包括提交哈希值、一些元数据和提交消息。
下面我要谈论的是这一部分。
你记得我们之前谈论过对象，如存储库中实际内容，然后谈论了引用，即使用人类可读名称命名存储库中的内容。
当你初始化一个git仓库时，默认情况下会创建一个名为"master"的引用。
根据约定，它通常表示代码中的主开发分支。
所以"master"将代表项目的最新版本。
在这里，你可以将"master"视为指向这个提交的指针。
随着我们添加更多的提交，这个指针将被改变，指向后面的提交。
我们还看到"HEAD"。
这是git中的一个特殊引用。
它类似于"master"引用，但它具有一些特殊的作用。
"HEAD"基本上用于指向你当前正在查看的内容。
有问题吗？是的，问题很好。
问题是，"你以前用过GitHub吗？你必须创建一个账户才能使用它。
GitHub和git有什么关系？"答案是，GitHub是git的一个仓库托管平台。
你可以在GitHub上创建一个账户，并将git仓库存储在那里，以便与其他人进行协作。
但作为命令行工具的git与GitHub是独立的。

所以，你不必使用Github来使用Git。
你也不必使用Github来声明Git，就像其他Git存储库的提供者，例如Bitbucket或GitLab之类的，所以是的，Github是Github存储库的主机。
还有其他问题吗？是的，问题是如果您想要将此存储库放在Github上，该怎么做？是的，有一组单独的命令来完成这个任务。
有一个概念，即将本地版本历史记录副本与另一个副本进行交互，因此另一个副本称为远程副本，然后有一组与Git远程副本交互并将数据从您的副本发送到Git远程副本并将数据从Git远程副本获取到您的本地副本的命令，我们稍后在本讲座或讲义中介绍。
Ron可能会制作一个补充视频来配合这个讲座。
还有其他问题吗？好的，还有几个基本命令要向您展示。
到目前为止，我向您展示了版本历史记录，并且我们已经拿出了一个文件并进行了修改，但我们除了阅读消息之外还没有真正利用历史记录。
一个有用的Git命令是被称为Git checkout，这是一种有点奇怪的命令。
它让您做很多不同的事情，但其中一个是让您在您的版本历史记录中移动。
因此，我可以给Git checkout之前的提交哈希值，而且我不需要输入整个哈希值，我可以给它一个前缀，让它弄清楚我在说什么。
这将改变我的工作目录的状态，使其与该提交时的状态相同。
因此，在这里，如果我运行cat hello.txt，回想一下，我之前只有一个行，而现在我添加了第二行。
现在，如果我运行Git log命令（该命令非常有用，可以显示所有内容），请注意，此输出看起来与之前有些不同。
我的实际历史内容，提交本身以及它们之间的关系等方面都没有改变，但是参考文献已经改变了。
请注意，HEAD在这里，即使是master也在这里。
因此，在高层次上，这告诉我这是我现在正在查看的内容。
如果我想回到这里，我可以键入Git checkout和这个提交哈希值。
有没有人知道我可以在这里输入不同的东西，而不是这个长哈希值，以便返回到这个提交？是的，你可以给它这里以绿色标记的分支名称，并且它引用这个提交。
所以我可以给它一个短名称或可读性更强的名称，现在如果我运行cat hello.txt，注意到它有第二行内容。
是的，是的，为了重复一遍，Git checkout 实际上会改变你的工作目录的内容，因此如果你滥用它，它可能是一个有些危险的命令。
例如，你可以看到如果我修改hello.txt然后尝试从之前的Git checkout 命令，实际上在这里注意到它显示错误。
它说有一个文件已经被修改了，Git checkout 将会销毁你的修改。
你可能想对此做些什么，但是有一些标志，例如Git checkout -f，这样强制执行，现在它正在丢弃我的更改。
所以是的，Git checkout 有可能，嗯，它确实会修改你的工作目录，并且如果你不小心，它可能会实际上销毁更改。

问题：没错，是的，这正是我想让你们思考的，这些类似疯狂的 git 接口命令是如何对应于对图形的变异和对引用或添加到图形中的引用映射的变异的。
所以没错，git checkout 移动了头指针，然后还通过指向的头指针的内容改变了您的工作目录的内容。
当然，这是我对该提交的名称。
还有其他问题吗？好的，所以我想向您展示的另一个基本命令是 git diff 命令。
我要修改这个文件并对其进行一些更改。
git diff 命令可以显示自上次快照以来发生了什么变化。
这对于了解您的项目正在发生什么很有帮助。
git diff 还可以采用额外的参数，例如您可以进行 git diff 并说计算一个差异不是相对于最后一个快照、最后一个提交，而是相对于此时说，“好的，自此时起已添加了两行到 hello.text。
”问题：所以，您的问题是如果没有此处的额外参数，该命令会做什么？这是个好问题。
它是计算与头文件有关的差异，并查看我的 git 日志指向的是什么。
所以它正在相对于此提交进行 git diff，您可以明确指定。
您可以使用 git diff head hello text。
好的，是的，这是一个好问题。
就像您当前的位置一样，头文件是指向的最后一个快照，所以对于 hello.text 文件的变化，可能与头文件不同。
为了澄清，头文件是指向最后一个快照的，就像我这里的图片一样，头文件和主分支都在这里，当前工作目录有点独立于此。
例如，如果您在此处删除了所有文件，则不会更改历史记录图或引用，所以是的，您可以在此处和此处之间存在差异，从高层次来看，这就是您在项目上工作的方式。
例如，您在此处进行了一些更改，将其添加到暂存区，然后进行提交，这将在此处创建一个新的快照。
还有其他问题吗？问题是，Git 是否确实以显而易见的方式保存所有这些东西，还是做了一些花哨的事情？答案是，它确实做了一些更高级的事情，但您可以使用接口来认为它是以那种方式存储的。
实际上，Git 使用 Delta 压缩，还进行了一些其他操作，但是在磁盘上的表示实际上是相当高效的。
问题：这是一个好问题。
所以问题是，我们正在将当前工作目录与过去的特定快照进行比较。
我们能否将两个快照进行比较，例如在历史上的两个不同时间点？是的，git diff可以在此处使用另一个参数。
例如，我可以将head与这里进行比较，我可以比较从这里到head在hello文本中的变化，它会显示我在其中添加了第二行。
还有其他问题吗？

是的，问题是，你正在一个Dropbox文件夹中共同开发一个项目，任何人都可以迁移到Git。
将Dropbox文件夹变成Git仓库是否有意义？不要在Dropbox内部使用Git。
Dropbox会破坏您的Git仓库。
有很好的解决方案。
一个是只使用Github。
否则，在课后与我交谈，有安全使用Dropbox作为Git远程的方法。
还有其他问题吗？接下来，我们将讨论Git的另一个强大功能——分支和合并。
您在自己的项目上工作和与他人合作时，几乎肯定会使用它。
在这一系列演示中，我们将编写一个简单的计算机程序，而不是使用简单的文本文件，因为它将更好地说明分支和合并的概念。
当我们进行演示时，我们将牢记Git界面命令与底层数据模型之间的连接，与对象和引用的连接，以及这些命令如何修改这两个数据结构。
让我执行'git status'来查看我的仓库的当前状态。
在这里，我修改了hello文本。
实际上，我不再关心这个修改。
这是一个随意的文件。
如果我执行'git checkout folio text'，这是'checkout'命令的另一种不同用法，它基本上会丢弃我在工作目录中所做的更改，并将hello文本的内容设置回它指向的快照的状态。
如果我喜欢它，'git log --all --graph --decorate'将显示我在这里添加了初始文本，并在这里添加了单行。
因此，现在，'hello文本'没有我添加的第三行。
它只有原始内容。
下一次，我们应该编写一个非常简单的程序。
我们将称这个程序为'animal.py'，让我写一个程序，当我运行它时，它会输出一点内容。
让我们看看。
[掌声]所以当我运行这个程序时，它运行'main'，调用'default'，然后让我继续定义'default'。
'默认'只会打印'hello'。
所以这是一个向用户打招呼的程序。
如果我运行'animal.py'，我会看到它只是打印'hello'。

那么这将是我们的起点。
如果我执行 "git status"，它会告诉我 "animal.py" 是一个未被跟踪的文件。
开始，我想让它成为我的快照的一部分，所以我要执行 "git add animal.py" 将其添加到暂存区，然后执行 "git commit"。
这里，我将写另一个无用的提交信息。
实际项目中不要写这样的提交信息，但是现在这样做还可以。
所以现在我有了这个基本的 "animal.py"，如果我查看我的 "git" 历史记录，现在我有了这个最新的快照。
这是提交哈希，这是主分支指向的地方。
现在我们实际上是在演示如何使用 Git 分支来实现平行的开发线路。
git branch 命令或分支子命令用于访问与分支相关的功能。
仅运行 git branch 本身会列出本地存储库中存在的所有分支。
它还可以接受一个额外的 -v 参数，以更详细的方式打印一些额外的信息。
如果我们执行 git branch，然后指定新分支的名称，Git 将创建一个新的分支，该分支只是一个指向我们当前正在查看的地方的引用。
所以现在有一个新的引用叫做 "cat"，它指向 HEAD 指向的地方。
如果我再次查看 git log，我会看到 HEAD 指向主分支，主分支在这里，这也是猫分支的位置。
所以现在我有了两个分支，两个引用指向同一次提交。
Git 不仅知道我们当前正在查看历史记录中的哪个快照（所以 HEAD 指向这个提交），而且还知道 HEAD 与分支有点关联。
在这里，HEAD 与主分支关联，如果我创建一个新的快照（如果此时键入 git commit），将创建下一个快照，并将指向该新快照。
主分支也将随着 HEAD 更新。
如果我执行 git checkout cat，它会切换到 cat 分支。
它将工作目录的内容替换为 cat 所指向的内容，这种情况下与之前的内容相同。
但现在，如果我再次查看 git log，现在 HEAD 指向 cat 而不是主分支，然后主分支也指向同一位置，同一次提交。
现在，如果我对当前的工作目录进行更改并进行新的提交，cat 分支指针将被更新以指向新的提交，而主分支将继续指向之前指向的位置。
所以让我修改 animal.py 添加一些与猫相关的功能。
那么我将会这样说，如果sys.argv[1]是“cat”，那么就运行cat()函数，否则运行默认函数。
然后让我继续导入/定义cat()函数。
所以猫不说“hello”，他们说“meow”——非常简单。
现在，如果我运行animal.py并给它cat参数，它会输出“meow”。

如果我给它其他的参数，它就会默认回到"hello"。
所以我做了一个简单的改变。
如果我运行git status，它会显示animal.py已经被修改了。
git diff会显示自上次提交以来的改变。
在这里，我添加了这个绿色高亮显示的cat()函数，然后稍微改变了main()函数。
现在，如果我运行animal.py并给它cat参数，它会说"meow"。
现在，如果我们给它其他的参数，它就会默认回到"hello"。
所以我做了一个简单的改变。
如果我运行git status，它会显示animal.py已经被修改了。
git diff会显示自上次提交以来的改变。
在这里，我添加了这个绿色高亮显示的cat()函数，然后稍微改变了main()函数。
现在，如果我运行git add animal.py，git commit(实际上你应该写一个稍微更有用的提交消息，比如"添加cat功能")，现在如果我查看git log，我会看到更多的内容。
我要向你展示这个git log命令的一个参数——--oneline(一行，正确拼写)，它会显示一个更紧凑的图形表示。
这应该是一个更有用的东西，因为我们现在在屏幕上缩小了很多，没有足够的空间显示一个长的提交历史。
所以在这里，我们看到提交的顺序仍然是线性的，而且我们的主分支(master)仍然指向它之前指向的位置。
在这里，我们只有基本的动物顶级高功能，但现在我们有了这个cat分支，它添加了cat功能。
例如，我们可以使用checkout master来回到主分支，然后在这里查看animal.py，它不再具有cat功能。
如果我们查看git log，我们会看到head指向主分支，因此我们可以在不同的开发分支之间来回跳转。

现在我们有了cat功能，假设我们想同时添加狗功能。
假设在这种情况下，像cat功能一样，狗功能也在开发中，或者可能有其他人在工作，所以我们只想从基本的主分支提交开始，从那里开始构建狗功能。
那么我现在想做什么？我想为添加狗相关功能创建一个新的分支，称为dog，然后稍后将其合并。
所以我可以使用git branch dog命令，然后使用git checkout dog命令创建一个新的dog分支，然后将其检出。
实际上，这有一个简短的形式，git checkout -b dog。
那么现在我用“git branch dog”命令创建了一个新的“dog”分支，然后使用“git checkout dog”命令将其切换到该分支。
如果我现在查看我的图表，就会看到猫在原来的位置，主分支也在原来的位置，但现在HEAD不再指向主分支，而是指向这个新创建的“dog”引用，该引用也指向同一个提交点。
因此，在这个基础提交点上，我将添加我的“dog”功能。
现在，让我去定义我的“dog”函数，因为狗不说“hello”，它们说“woof”。
然后，我将添加一些类似的功能，以决定是运行默认还是狗功能。
因此，如果第一个参数是“dog”，那么我要运行狗功能，否则，哎呀，否则我要运行默认功能。
这是我相对于主分支指向的基础提交点所做的更改。
因此，我已经添加了狗功能，并且稍微修改了主函数，这是对我在猫分支中所做修改的一种并行修改。
让我去执行“git add animal.py”命令，将其添加到暂存区中。

如果我运行 "get status" 命令，我会发现在我进行下一次提交时，这个修改会被提交。
然后我运行 "get commit add functionality" 命令。
现在，当我查看 Git 图形时，与之前我们看过的那些图形相比，它实际上看起来很有趣。
这表明这三个提交与之后的提交是共同的，但是在此之后，历史记录实际上分叉了，在一条开发线上添加了猫功能的一个提交，以及在另一条开发线上添加了狗功能的另一个提交。
然后，使用 "get checkout" 命令，我可以在狗、猫和主线之间来回切换。
这很棒，我可以在不同的功能上并行开发，但只有当我最终将这些内容合并回我的原始开发线时，才真正有用，以便将两个功能合并到我的源代码的单个版本中。
用于执行此操作的命令是 "get merge"。
所以可以认为 "get branch" 和 "get merge" 是相反的。
让我先检出 "get checkout master"，然后我要将猫功能和狗功能合并到主线上。
为了做到这一点，我可以使用 "get merge" 命令。
Git 合并实际上相当高级，我实际上可以同时合并猫和狗。
但是对于这个演示，我们将一次只合并一件事。
所以首先，我将输入 "get merge cat"，然后它会给我们一些内容。
它说“快进”。
那这里发生了什么？嗯，这是 Git 可以做的有趣的一件事。
当你在一个特定的提交上，并将某个其他分支合并到该提交的前任分支时，不需要创建任何新的快照或做任何其他高级操作。
基本上，这个主线分支，在这个提交的指针，可以直接移动到这里，以合并那个猫功能。
所以如果我们再次查看 Git 日志，我们可以看到主线基本上指向与猫功能相同的地方。
好了，现在我们在主线上，并且它有了猫功能。
很好，我们完成了一半。
如果我们查看 "animal.py" 文件，它具有猫功能，但缺少狗功能。
所以接下来让我们尝试 "get merge dog" 命令。
这次发生了一些更有趣的事情。
所以这一次，该分支无法像之前那样快速前进。
这不是一个比另一个严格更旧的东西。

存在一种并行开发方式，可能与当前的一系列变化不兼容。
它会尽力自动合并来自另一个分支的更改，因此它会显示"正在自动合并animal.py"。
但在这种情况下，存在所谓的合并冲突。
因此，它无法自动解决这两个并行开发分支之间的所有冲突。
当您在实际的软件项目中工作时，您会看到这种情况，因为会出现一些复杂的、略有不兼容的并行变化。
因此，现在需要由开发人员来解决此问题。
Git提供了一些功能来帮助解决合并冲突。
有一个叫做git merge tool的程序，在我的特定设置中，这将启动Vimdiff。
实际上，这未配置好。
Vimdiff会启动正确的程序。
让我设置我的Git来实际启动正确的工具。
让我们跳过这部分，手动查看此事件。
有一个叫做Vimdiff的程序，可以在键入"git merge tool"时启动它，这是当您尝试进行git merge时出现合并冲突时使用的工具。
但在这种情况下，我们将手动解决它们。
因此，我执行了"git merge --abort"，这将我放回到我尝试git merge之前的状态。
这是我的仓库当前的状态。
我回到了主分支与猫分支相同的位置，并将狗分支合并到主分支中。
因此，我执行了git merge dog命令，它显示"在animal.py中发生合并冲突"。
因此，让我们直接查看animal.py文件。
看起来顶部部分看起来很合理，它具有我想要的猫和狗函数。
但现在我在main函数中看到一些奇怪的东西，这就是我添加的略有不兼容的更改。
因此，在这里，它会显示在一个位置，即您所在的分支上，您有这个内容。
而在您尝试合并的分支上，它有这个内容。
然后，这些尖括号和等号是冲突标记。
因此，这就是您所在的位置和您正在尝试合并的内容，它基本上是在一个情况下是这个，另一个情况下是那个，它不知道如何解决这两个内容。

这需要程序员来解决这个问题。
在这种情况下，我们可以删除冲突标记，然后发现我们实际上可以将这段代码连接在一起并得到正确的结果。
也许我们想做一个小改变，比如把这个应该是if，这个应该是else-if，这个应该是else。
这样可能更有意义，实际上我认为这是必要的正确性。
因此，程序员需要稍微修改一下代码，使其在合并在一起时变得有意义。
但是一旦程序员解决了合并冲突，解决了冲突标记之间的问题，就可以保存这个文件，然后我们可以执行git merge --continue来告诉git我们已经解决了问题。
需要重新添加animal.py文件以告诉git我们已经解决了这些问题。
然后我们需要git merge --continue。
它会弹出一个编辑器，我们可以为即将创建的新提交提供提交消息。
现在，如果我们查看git历史记录，我们有一个表示我们刚刚创建的合并提交的单个提交，其中包括狗功能。
这里，它的父节点是狗提交和猫提交。
因此，从这一点向后，我们的历史记录中都包含这两个分支，并且当前提交包含了这些分支中开发的所有功能。
因此，如果我们运行animal duck fight with cat，它会执行猫的操作。
如果我们使用狗运行它，则会执行狗的操作。
如果我们使用其他任何东西运行它，则会回退到默认实现。
这是如何在不同分支上进行开发并使用合并命令和git解决这些不同分支并将它们组合成包含所有并行开发的功能的单个快照的演示。
在进行git分支和合并时，可能会出现合并冲突，这些冲突会显示为文本文件中的冲突标记。
您可以手动解决它们，git也有一些工具可以帮助解决这个问题，尽管这些工具有点高级，我们只会在讲义中提到它们，而不是实际演示它们。
所以这就是git分支和合并。
还有什么问题吗？没有吗？好的。
那么接下来，我们将讨论git远程。
这基本上是如何使用git与他人协作。
git仓库中包含的内容，即.git文件夹，代表了历史的完整副本。

它包含对象和引用，包含了所有之前的快照。
使用Git与其他人协作的方式是其他人也可以拥有整个Git仓库的副本。
然后，你的本地仓库可以知道同一仓库的其他克隆副本的存在，这是一个被称为远程仓库的概念。
使用git remote命令可以列出当前仓库所知道的所有远程仓库。
在我们的仓库中，由于我们还没有配置任何远程仓库，所以这个命令什么也不会输出。
它只知道我们正在使用的单个本地仓库的副本。
但是实际上，如果你与其他人合作，你的Git可能会知道GitHub上的代码副本。
然后有一系列的命令将你本地仓库的更改发送到Git所知道的远程仓库，比如将东西从你的电脑发送到GitHub。
还有另一系列命令，用于从本地仓库获取已进行的更改，从GitHub获取更改并将其应用到你的本地副本中。
在这个演示中，我们不会配置GitHub账户，登录并在那里创建新仓库。
你可以找到其他的教程来完成这个任务。
我们将只使用同一台计算机上的另一个文件夹，并将其视为Git远程仓库。
让我来到演示文件夹，在上一级目录中创建一个名为"remote"的新文件夹。
然后使用git init --bare在这里建立仓库。
这些命令在日常使用中可能用不到。
但现在，我已经将"remote"文件夹设置为适合用作Git远程仓库的文件夹。
现在回到我的演示文件夹，我的Git仓库，我可以使用git remote命令列出远程仓库。
暂时还没有任何内容，但是我可以使用git remote add功能让我的本地仓库知道远程仓库的存在。
因此，我可以使用git remote add命令，然后远程仓库具有名称和URL。
在这种情况下，我将使用名称origin，这是约定俗成的远程仓库名称，如果你只使用一个仓库。

然后对于URL，通常这将类似于Github URL或Bitbucket URL或Gitlab URL，如果您使用在线存储库托管服务。
但在这种情况下，它只是指向我本地计算机上的一个文件夹的路径。
在父目录中有一个名为remote的文件夹，它将作为此存储库的git远程操作。
所以现在，一旦我完成这个步骤，就有一组与此远程进行交互的命令。
其中一个有用的命令是git push命令。
此命令可以将更改从您的计算机发送到远程主机。
该命令的格式是git push接受远程名称，然后接受本地分支名称，远程分支名称。
它会创建一个新分支或更新远程上的一个分支，并将其设置为此处指定名称的内容。
所以，具体使用它的方法可能是像git push这样。
我只有一个名为origin的远程，那我应该推送什么呢？让我看看我的历史记录图。
我有一堆东西可以推送。
让我从我的本地计算机master推送到origin。
所以，我想在远程计算机上创建一个名为master的分支，它将与我的本地计算机上的master分支相同。
所以，让我继续运行这个命令。
它会打印一些东西，并说：“在远程上，我创建了一个名为远程master的新分支，它指向我的本地计算机上的master分支的相同位置。
”现在，如果我执行git log，它会显示给我。
蓝色是head，是我当前所在的位置。
绿色是我本地git存储库中的所有分支。
现在，我们看到了一种新的颜色，我们之前没有见过的。
红色是git显示的我本地副本所知道的远程参考。
所以，在remote origin上，还有一个名为master的分支，它恰好指向与我本地master分支相同的位置。
因此，现在，如果我对我的本地副本进行更新，比如说我在这里更改了这些内容的大写，然后运行git add animal.dot.hi，git commit，在这里有一个带有消息的短表单提交，所以它不会弹出编辑器。
我会给它一个晚期提交的消息。
现在，如果我查看git图，现在我看到我创建了这个新的快照，它有这些小写字母的东西，但是origin master仍然停留在这里。
所以，如果其他人查看远程，他们只能看到到此为止的更改，我们可以实际演示这个功能。

好的，让我打开一个新标签页，进入我的 playground 目录。
git clone 命令是一个可以用来从某个存储库的副本开始，并创建自己的本地副本的命令。
因此，当使用 git 存储库时，通常使用这个命令。
例如，可能有一些在 Github 上可用的东西，你想把它全部复制到你的机器上以查看它或开始进行开发。
因此，git clone 的格式是接收一个 URL，然后接收一个文件夹名称作为克隆的位置。
在我们这里，我们只是从这个远程目录克隆。
我们假装这个远程文件夹实际上是一个远程机器，然后我们把它全部克隆到叫做 demo two 的文件夹里。
克隆到 demo 2 完成后，我要 CD 到那个目录。
然后现在，在这里我将重命名底部的标签。
我会说这个是 machine one，这个是 machine two。
因此，你可以将这两个视为位于不同机器上的两个不同的人，他们拥有自己的存储库副本，并与单个远程进行交互。
因此，如果我在 machine one 上执行我一直在做的 git log 命令，我会在 machine two 上看到历史记录的这部分。
因此，machine 2 上的 master 指向的是与 origin master 相同的位置，并且它说：“合并分支 dog”。
因此，如果我在这里查看 animal.dot.pie，即使在 machine one 上我有这个新提交，而这个提交只存在于这个机器上，而不在远程和 machine two 上，它也没有这些更改。
因此，如果我想修复这个问题，如果我想将这些更改发送到远程，例如将其发送到 GitHub 或持有或维护源代码的机器上，我可以使用 git push 命令。
同样，git push origin master : master 可以工作，但是每次想要这样做时键入这个命令有点麻烦。
像这样的操作非常常见，因此 git 有一种方法使它变得更简单。
它有一种方法来维护你自己本地机器上的分支和远程机器上的分支之间的关系。
它有一种方法来知道本地分支对应的远程机器上的分支，这样你就可以输入 git push 的缩写版本，它会知道扩展形式的所有参数是什么。
有几种不同的语法来做到这一点。
一种方法是使用 git branch --set-upstream 命令，它为当前已检出的分支（即 master）设置上游分支，我将输入 origin master。
现在可以看到，它说“分支 master 已设置为跟踪来自 origin 的远程分支 master”。
现在，如果我输入 git branch -VV（记住，这会以详细的方式告诉我所有我知道的分支，这就是 -VV 的含义），我在机器一上的本地机器上有三个分支。
我有 cat、dog 和 master，我的本地机器上的 master 对应于 origin master。
所以现在我只需要输入 git push，而不需要所有额外的参数。
我本来可以用 git push origin master 冒号 master，但这是不必要的。

现在它会显示“设置跟踪远程分支 master from origin 的主分支”。
如果我键入 git branch - VV（记住，这是以非常详细的方式告诉我所有已知分支的信息，这就是 -VV 的含义），我在一台机器上的本地机器上有三个分支。
我有 cat，dog 和 master，本地机器上的 master 对应于 origin master。
因此，现在我可以只键入 git push，而无需添加所有额外的参数。
我可以使用 git push origin master 冒号 master，但这不是必要的。


它会知道我想要推送到 origin master，并进行更改。
所以现在这些更改在远程存在。
我们可以转到机器二，假装我们是与此存储库交互的其他人，如果我执行 git log 命令，我仍然看不到更改。
那么这里发生了什么？嗯，为了运行一个单独的命令，这是必要的。
或者说，为了使这些更改在这里存在，必须运行一个单独的命令。
默认情况下，所有 git 命令都不会与互联网通信。
它全部在本地工作，这意味着它运行非常快，但是需要特殊命令才能说您想要检索在其他地方进行的更改。
用于执行此操作的命令称为 git fetch。
Git fetch 将远程名称作为参数，但如果只有一个，则会直接使用它。
因此，您可以输入 git fetch，然后它将与此远程存储库通信，并表示远程有一些更新，我们可以通过运行 git log 来可视化它。
现在我们看到了另一种以前没有见过的情况。
我们在本地机器上有 master。
主分支不改变。
git fetch 命令不会更改任何本地历史记录，本地引用（例如分支）。
但现在它知道 origin master 已更新为指向此新提交，并且有一个单独的命令，我们可以使用 git merge 来将 master 向上移动到此处。
或者还有一个称为 git pull 的命令，它相当于执行 git fetch，然后执行 git merge。
因此，如果我们在此处只执行 git pull，它将说它正在快进，正在将 origin master 合并到我们的 master 中，现在，如果我们查看 Git 历史图，我们目前已检出 master。
主分支指向我们所知道的 origin master 相同的位置，并且 Machine 2 和 Machine 1 之间的所有更改都已同步。
这些是与 Git 远程交互的基本命令。
因此，有用于列出远程主机并添加和删除它们等的 Git 远程命令。
然后有 Git push 命令用于将本地仓库的更改发送到远程仓库。
然后有 Git fetch 命令，用于检索存在于远程仓库上的更改，并在本地机器上获取这些更改。
一旦检索到这些更改，您可以使用 Git merge 将本地分支更新为指向远程分支所在的位置，或者您可以使用 Git pull 命令，它基本上是 Git fetch 和 Git merge 的组合。
当然，与所有这些命令分开的是我们之前讨论过的克隆命令，用于从远程仓库中获取一份副本并从该副本初始化本地仓库。

这就是与Git远程交互所使用的不同命令的快速概述。
这些命令有点复杂，需要一些时间来掌握所有不同的变体并理解它们在实践中的使用方式，但希望这能作为一个快速介绍，并且您可以看到不同的命令与底层数据模型的关系。
所有这些命令都只是从其他地方获取新对象或将对象从本地传输到其他地方，这些命令会改变引用。
因此，将Git的界面和一些这些设计不良的命令与底层数据模型联系起来，可以帮助您更好地理解它。
我们今天要讨论的最后一个主题是Git可以做的其他事情的概述，我们不会详细介绍如何执行这些操作，但我们只想告诉您，这些功能存在于您需要自己执行这些操作时。
您可以查找文档并找出如何准确执行它。
其中一个是Git config命令。
像我们看过的很多工具一样，例如shell、TMUX等，Git是高度可配置的，并使用纯文本文件进行配置，可以通过命令行界面进行编辑。
因此，Git config可以接受修改此文本文件的标志，或者您可以使用纯文本配置编辑home文件夹中的.gitconfig文件。
因此，对于本课程，我实际上剪切了大部分Git config，只留下了我的用户名和电子邮件，以供提交到Git的提交。
但是，您可以在此处放入很多内容，以使其更好地运作，并且您可以在线查找人们已配置其Git配置的不同方法。
通常，人们在其Git配置中具有文档，可以在GitHub上找到。
还有几个其他可能有用的随机命令。
其中之一是当您想要克隆使用Git clone的一个真正巨大的存储库时。
默认情况下，git clone会复制它正在下载存储库的远程的整个版本历史记录，但是您可以传递一个参数，即--shallow，这将避免这样做。
因此，如果在Github上有一些代码的副本，您想在本地计算机上获取副本，但该存储库真的很大并且具有10亿次提交，那么执行git clone --shallow将更快。
但是，当然，您将不会在本地计算机上拥有版本历史记录，您只会有最新的快照。
我们在实际软件项目开发中发现的另一个非常有用的命令是git add命令的交互式版本。
所以为了演示，我将对我的 animal.py 进行几个不同的更改。
我会在这里进行一些更改，更改一些文本，并在这里放置一个新的打印语句。
假设这第一个更改是我想要进行的真正更改，比如说是一个错误修复，而这里的另一个更改是我添加用于调试的 printf，但实际上我不想在下一个快照中提交它。
如果我执行 git diff，它会显示我已经进行了这两个更改，如果我执行 git add animal.py，它将为提交暂存这两个更改，而这不是我想要的。
我可以手动删除这个调试打印，然后执行 git add animal.py，但有一种更简单的方法。
有一个 git add -p 命令，它允许我交互式地为提交暂存文件的片段，因此有一些用于处理此功能的界面。
这里它问我是否要暂存这两个更改，而我不想。

但我要将它分成两个较小的更改。
这一个我想保留，所以我选择“Y”表示是，而这一个我不想要，所以我选择“n”表示否。
然后如果我执行 git diff --cached，这将显示为提交准备好的更改。
现在它只显示我想要保留的实际更改。
如果我执行 git diff，它仍然会显示我不想要保留的其他更改，这是我不想要的更改。
然后，我可以使用 git commit 命令指定一些提交信息，现在我只剩下这个更改，然后我可以使用 git checkout animal 来丢弃这个更改。
因此，交互式暂存的 git add -p 是一个有用的东西。
还有一些其他的命令，您可以自己查找 git blame 命令，因此该命令有点不祥，但可以用于确定谁编辑了文件的哪一行，您还可以找到负责修改该特定文件行的相应提交，然后您可以查找与其相关的提交消息等等。
因此，在我们当前的玩具存储库中执行此操作并不那么有趣，但我将转到班级网站的存储库，我们可以在此查看某个特定文件。
然后我可以看着这个，'为什么要添加这一行？它是什么意思？'我可以查看这个 git blame。
如果我执行 git blame config.yml，它将以正确的列打印出所有行，然后在左侧，它将显示该更改所做的提交和由谁做的。
然后查看此信息，如我可以查看到 collections 行，它是在此提交中进行的，这是最后一个修改该行的提交，现在我可以使用 git show 命令获取有关该特定提交的信息。
哦，这很有用-重做讲座是一个集合。
那可能与“集合”行有关。
除了显示提交和提交消息之外，它还向我显示了在该特定提交中引入的实际更改，我可以浏览它们并理解发生了什么。
另一个很酷的命令是一个称为 git stash 的命令。
因此，让我们回到我们的演示存储库并在此处演示。
假设有些更改在此处，我想暂时将它们放置，如果我执行 git stash，它将将我的工作目录恢复到上一次提交的状态。
因此，如果我执行 cat hello.txt，该更改已经消失，但它不仅仅被删除-它被保存在某个地方。
如果我执行 git stash pop，它将撤消这个储藏。
如果我执行 cat hello.txt 命令，那个更改就被删除了，但它并没有被彻底删除 - 它被保存在某个地方。
如果我执行 git stash pop 命令，它会撤消存储操作。
现在如果我查看 hello.txt 文件，它就会包含我所做的更改。
这是另一个有用的命令！另一个非常好用的命令是 git bisect，这个命令的界面比较复杂，我们不会详细演示。
但基本上，这是一个可以用来解决一堆需要手动搜索历史记录的问题的工具。

假设你在一个长期进行的项目中工作。
你有很多快照——你已经有了一千个提交——然后你发现某个单元测试不再通过。
但你知道这个单元测试一年前是通过的，而现在你正在尝试找出什么时候出了问题，也就是你的代码中什么地方出现了回归。
你可以手动检查——比如说，回退到前一个提交，看看单元测试是否仍然失败，回退到前一个提交，看看是否仍然失败，最终你会找到第一个测试停止工作的提交，它可能会告诉你什么出了问题。
但这样手动做有点烦人。
git bisect可以自动化这个过程，它实际上是对你的历史进行二分查找，因此它是以最有效的方式来进行查找的。
而且，git bisect可以接收用于尝试确定它正在查看的提交是好还是坏的脚本。
因此它可以是一个完全自动化的过程。
比如说，你可以给git bisect一个单元测试，然后说，“找到这个单元测试停止通过的第一个提交。
”这是一个非常强大的工具。
另一个随机但有用的东西是gitignore文件。
默认情况下，如果在一个目录中有随机的文件，比如说让我创建.DS_Store文件——哎呀，创建.DS_Store文件，然后执行git status。
.DS_Store是Mac OS创建的一些讨厌的文件。
我不知道里面具体有什么内容，但基本上，一旦这个文件在这个目录中，现在每当我执行git status时，它会说，“噢，这里有一个我从未听说过但显然在这里的新文件——你要添加它吗？”这样的东西会让人感到烦恼。
除了特定于操作系统的垃圾之外，可能还有许多其他的东西存在于一个目录中。
例如，如果你正在处理C代码，你可能会编译它并生成.o文件或可执行文件等等，你可能不希望二进制文件成为你提交历史的一部分，你只需要源代码。
因此，Git有一种方法让你告诉工具你不关心特定的一组文件并忽略它们，这就是所谓的gitignore文件。
因此，如果我修改当前目录中名为gitignore的文件，我可以指定特定的文件名或文件名模式，比如说，我可以指定任何以.o结尾的文件，以及.DS_Store。
现在，如果我执行touch food.o，然后执行git status，
我会确保 git 命令显示为“OK”，我已经清空了税务，做了修改，并且我已经在 get ignore 中添加了文件。
所以，你应该使用它来跟踪你的 git ignore 文件。
但是请注意，它没有提到当前目录中存在的我的点 d s store 文件或 my food out o 文件，因为它们已经被忽略了。
这是关于一些高级 git 功能的简要概述，只是为了让你了解这个工具可以做哪些酷炫的事情。
最后，我们还有一些其他主题在讲义中有更详细的介绍。
我会在这里快速列出它们，以便你知道要查找什么。
其中一个是有许多图形化客户端可用于 git。
我们个人不使用它们；我们喜欢 git 命令行工具，但其中一些还不错，你可能想要查看一下，看看你是否喜欢使用它们。
另一个是 shell 集成。
你已经注意到在这个教程中我一直在使用 git status 命令来查看仓库的情况。
好吧，这有点烦人，很多人都会设置他们的 shell 提示，以便在每一行中，它将向我显示一个非常简洁的仓库情况摘要。
因此，它可能会向我显示我当前检出的分支的摘要，以及我是否修改了文件或未跟踪的文件。
因此，我们在讲义中提供了一个链接，介绍了如何获取漂亮的 shell 集成，以便在 shell 提示中显示与 git 相关的信息。
与此类似，你可以获得与你的文本编辑器的集成。
例如，我使用 vim，我有一个 vim 插件，可以做所有有趣的与 git 相关的工作。
我可以使用这个插件查看 git blame 信息。
记住，我们刚刚通过命令行查看了这个信息。
相反，我可以使用这个插件查看它，并且它可以让我更快地工作。
我可以查看 git blame，当我在悬停在特定提交上时按回车键，它会在我的文本编辑器中显示那个特定的提交。
它甚至会隐藏所有其他文件，只显示我正在查看的那个文件，这可能是我关心的内容。
因此，我们在讲义中也提供了链接。
如果你感兴趣，还有其他一些有趣的东西可以查看。
最后，单独这个讲座可能不足以教会你所有需要了解的关于 git 的内容。
这是一个良好的开端。
我们认为学习 Git 的正确方式是先了解底层的数据模型，包括整个对象和引用系统，以及 Git 是如何模拟历史的。
然后我们向你介绍了使用 Git 命令的基础知识。
如果你想真正熟练地掌握这个工具，在今天的讲义资源部分中，我们有一本叫做《Pro Git》的书籍链接。
这是一本免费的书，写得很好，篇幅也不长。
我认为，阅读该书的前几章，你基本上就能掌握使用 Git 进行真实软件项目和贡献的所有知识，包括在 GitHub 上进行项目开发等等。
最后，就像所有其他讲座一样，如果你想找一些有趣而具有挑战性的问题，可以尝试一下我们提供的一些练习。