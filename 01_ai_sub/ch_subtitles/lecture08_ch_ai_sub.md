大家好，让我们开始下一堂课。
今天我们将解决元编程的主题，这个标题有点奇怪。
我们并没有完全清楚元编程的含义。
我们在命名这个讲座时想不出更好的名字，因为这个讲座是关于你在使用软件时所进行的工作周围的过程，不一定是编程本身，而是关于这个过程的内容。
这可能涉及到如何构建你的系统、如何进行测试、如何添加软件依赖等等，这些内容在构建较大的软件时变得非常重要，但它们本身并不是编程。
所以，我们这堂课首先要讨论的是构建系统的概念。
有多少人使用过构建系统或知道它是什么？好的，大约有一半的人。
那么对于其余的人来说，构建系统的核心思想是，你正在编写一篇论文、编写软件、或者在学习某个课程，无论是哪种情况，你都有一堆命令，你可能把它们写在你的 shell 历史记录中，或者在某个文档中记下来，你知道如果想要完成特定的任务，必须运行这些命令序列。
例如，有一系列的命令需要按顺序运行，以便构建你的论文或论文的 PDF 版本，或者只是运行当前课程的测试。
构建系统的想法是，你想把这些规则编码成一个工具，这个工具可以为你完成这些任务。
特别是，你要教这个工具了解构建不同工件之间的依赖关系。
有许多不同类型的这种工具，许多是针对特定目的、特定语言构建的。
有些是用于构建论文，有些是用于构建软件，有些是用于特定的编程语言，比如 Java 或某些其他的语言。
有些工具甚至内置了构建工具，例如 NPM，如果你做过 Node.js 开发，可能就知道它具有跟踪依赖项和构建依赖项的内置工具。
但更一般地说，这些被称为构建系统，在它们的核心中，它们都有一些共同的功能。
它们有许多目标，这些目标是你想要构建的东西，比如 paper.pdf，但它们也可以是更抽象的东西，比如运行测试套件或构建程序的二进制文件。
然后，你有一堆依赖项，依赖项是需要构建的东西，以便构建这个目标
然后你有一些规则，规定如何从完整的依赖项列表中得到目标文件。
举个例子，如果要构建我的paper.pdf，我需要一些绘图图像，它们将被嵌入到论文中，因此需要构建它们。
但是一旦它们被构建，如何使用这些文件来构建论文呢？这就是规则的作用。
它是一系列命令，你需要运行它们才能完成从一个文件到另一个文件的转换。
如何编码这些规则因不同的工具而异。
在这门课程中，我们将关注一种叫做make的工具。
make是一种几乎可以在今天登录的任何系统上找到的工具。
比如，它会在Mac OS上，基本上所有的Linux和BSD系统上找到，而且你也可以很容易地在Windows上获取它。
它不适用于非常复杂的软件，但对于任何简单到中等复杂度的东西都可以很好地工作。
当你在命令行上运行make命令时，如果目录为空并且没有指定目标并且找不到makefile，它就会停止。
它会有益地告诉你已经停止运行，但也会告诉你找不到makefile。
make将在当前目录中查找一个名为Makefile的文件，这就是你编码这些目标、依赖项和规则的地方。
所以，让我们试着写一个makefile吧。
假设我正在写这篇假想的论文，所以我要创建一个Makefile，在这个Makefile中，我将声明我的paper.pdf是由paper.tex、plotdata.png这两个文件构建而来，构建这个文件的命令是使用PDF latex命令。
对于那些不熟悉这种构建文档的方式的人来说，TeX是一种非常方便的文档编程语言。
它是一种非常难看的语言，使用起来很麻烦，但它可以产生很好的文档。
而将TeX文件转换成PDF的工具就是PDF latex。

这里我需要用到一个plot数据的PNG文件，这个文件将会被包含在我的文档中。
我想要表达的是，如果这两个依赖关系中的任意一个发生了变化，我希望生成paper PDF文件。
这两个文件都需要存在，如果它们发生了变化，我希望重新生成。
但我并没有告诉它如何生成这个plot数据的PNG文件，因此我可能还需要一个规则。
因此，我在这里定义了另一个目标，它的样子是这样的：plot - % & %代表任意字符串，可以理解为通配符模式。
但是，很酷的一点是，当你在依赖关系中重复这个模式时，我可以说，plot - % dot PNG将依赖于% dot data或debt，这是一种常见的数据文件后缀。
它还将依赖于一些脚本，这个脚本将实际为我绘制这个图形，而从一个文件格式到另一个文件格式的规则可以是多行的，但在我这个特定的例子中，只有一行。
我会在接下来的时候解释这是什么意思。
好的，所以在这里，我们要说的是，为了从通配符点点文件（与目标中的通配符匹配）和plot dot python文件转换，运行python文件，并且使用-i参数，这类似于我们在python文件中标记输入的方式。
稍后我会向您展示它。
$*是一个为您定义的特殊变量，可以匹配任何百分号。
因此，如果我做plot to PNG，那么它将查找foo.dot，它的星号可以扩展为foo。
所以，这将产生与我们在此处匹配的文件名相同的文件名，而dollar act是一个特殊变量，表示目标的名称，对吧？所以，输出文件，希望plotter py会获取这里的任何数据，它将以某种方式生成PNG文件，并将其写入由dollar all指示的文件中，对吧？现在我们有了一个make文件。
让我们看看如果这个目录中唯一的文件是make文件，而我们运行make会发生什么。
它会说：“no rule to make target paper dot tex needed by paper dot PDF，stop。
”所以，它在这里所表达的是，首先，它查看了我们文件的第一条规则，也就是第一个目标，当你没有给make任何参数时，它会尝试构建第一个目标。
这被称为默认目标。
因此，在这种情况下，它试图为我们有用地构建paper dot PDF文件，然后查找它的依赖关系，它说：“为了构建paper dot PDF，我需要paper Tex和这个PNG文件。

我找不到paper.X的文件，也没有生成paper.X的规则，因此我要退出。
我无能为力了。
所以，让我们尝试在这里创建一些文件。
我们可以创建一个空的paper.X文件，然后输入make命令。
现在它会显示“paper to PDF”需要plot data.PNG文件，但是没有相关规则。
现在它知道它有一个依赖项，但它不知道如何获取另一个依赖项。
它知道有一个与之匹配的目标，但实际上找不到依赖项，所以它最终什么都没有做。
它仍然需要我们为PNG的输入生成这个PNG文件。
因此，让我们实际上在这些文件中添加一些有用的内容。
幸运的是，我之前从plot.da.py中获得了一个，所以很好。
那么，这个文本文件是文本的样子。
它不是很漂亮，但是我定义了一个空文档。
我将包含图形，这是包含图像文件的方式。
我将包含plot data.PNG，这当然是为什么我们希望paper.PDF的依赖项是PNG文件。
plot.da.py也不是很有趣。
它只是导入了一堆库。
它解析了-ion-Oh参数。
它从I参数中加载数据。
它使用了一个称为matplotlib的库，这对于快速绘制数据非常方便。
它将数据的第一列绘制为X轴，第二列绘制为Y轴。
因此，我们只需要一个每行都有两列X和Y的数据文件，然后将其保存为给定的-oh值的图像。
因此，我们需要一个数据文件，它将被命名为data.点，因为我们需要plot_data.dot.png，而我们的规则指定了从该模式到点文件的方式，即按照plot之后的内容来确定点文件的名称。
因此，如果我们需要plot-data，则我们需要data.dot that文件。

然后这个文件，我们只是要把它放入一些线性坐标，因为为什么不呢？那不是线性的。
好的。
现在，如果我们要做什么，嗯，好的，那么刚刚发生了什么？嗯，make首先用正确的文件运行plot.py生成PNG文件，然后它运行PDF latex paper.tex，我们下面看到的所有内容都是该工具的输出。
如果你想的话，我们可以消除这个工具的输出，这样我们就不必让它干扰我们的所有输出，但是通常情况下，你会注意到它运行了两个命令，然后以正确的顺序写入了随机值。
如果我们现在在当前目录下运行LS，我们会发现我们有一堆文件是由PDF latex生成的，但特别的是，我们有生成的PNG文件和paper.pdf。
如果我们打开paper.pdf文件，我们会看到它有一个图像，其中有一条直线，也许本身并不是一个非常令人惊讶或有趣的结果，但这真的非常方便，我可以做一些像如果我再次输入make，make只是说paper.pdf是最新的。
它不做任何工作。
每当你运行make时，它尝试以最小的工作量来产生你要求的任何东西。
在这种情况下，没有任何依赖项发生变化，因此没有重建paper或重建图。
现在假设我要编辑paper.tex，我要在这里添加hello，现在做make，然后如果我们向上滚动，我们会看到它没有再次运行plot.py，因为我不需要它。
没有依赖项发生变化，但它确实再次运行了PDF latex。
如果我们打开paper，分析hello在那里。
另一方面，如果我改变数据文件，然后把这个点改为每小时8美元，然后再做，那么现在它会重新绘制图形，因为数据发生了改变，并且它会重新生成PDF，因为图形发生了改变。
确实，这篇论文的结果是我们预期的。
所以这并不是说这个特定的管道非常有趣，因为它不是。
它只对非常非常简单的目标和规则有效。
但是当你开始构建更大的软件或可能存在依赖关系时，这会非常有用。
你甚至可以想象，如果你在写论文，你的一个目标可能是首先生成这个数据文件，对吧？因此，其中一个makefile目标可能是运行我的实验，对吧？
运行我的基准测试并将输出的数据点放入此文件中，然后绘制结果，一直到最终论文完成。
这样做的好处是，首先你不必记住运行所有命令的方式，也不必在任何地方写下来，工具会处理最少量的工作量。
通常情况下，你会发现有些事情也太麻烦了。
例如，还有子命令需要执行，如 make tests，它会编译整个软件并运行测试。
还可能有像 make release 这样的东西，它会打开优化并创建一个 tarball 并将其上传到某个地方。
因此，它会为你完成整个流程。
这样做的目的是减少构建过程中你必须做的工作量。
现在我们看到了一个非常简单的依赖示例，对吧？我们看到了你可以将文件声明为依赖项，但你也可以声明传递依赖项。
当你在更大的软件领域中处理依赖项时，通常会发现你的系统最终会有许多不同类型的依赖项。
其中一些是像我们在这里看到的文件，有些是程序，比如这个程序隐含依赖于 Python 在我的机器上安装。
有些可能是库，比如你可能依赖于像 matplotlib 这样的东西，我们在这里也依赖于它。
有些可能是系统库，如 OpenSSL 或 OpenSSH 或低级密码库，你不一定要声明所有这些依赖项。
通常情况下，有一些工具可以帮助你管理这些依赖项。
而且，这些你可能依赖的系统通常存储在所谓的存储库中。
存储库只是一组通常相关的事物，你可以安装它们。
这基本上就是存储库的全部内容，你可能已经熟悉其中的一些，对吧？存储库的一些示例包括 PyPI，这是一个众所周知的 Python 包存储库，RubyGems，这是 Ruby 的类似存储库，crates.io 是 Rust 的存储库，NPM 是 Node.js 的存储库，但其他东西也有存储库，对吧？例如，有加密密钥的存储库，如 Keybase，有系统安装包的存储库，如如果你在 Ubuntu 或 Debian 中使用 apt 工具，则正在与一个包存储库交互，人们上传他们编写的程序和库，以便你可以安装它们。
同样地，你可能会有完全开放的仓库，比如说 Ubuntu 仓库通常由 Ubuntu 开发人员提供，但是在 Arch Linux 中，可能会有一个叫做 Arch 用户仓库的地方，用户可以自己共享他们自己的库和软件包。
仓库往往要么是受管理的，要么完全开放的，你应该经常意识到这一点，因为如果你使用完全开放的仓库，你从中得到的安全保证可能会比从受控制的仓库中得到的少。
如果你开始使用仓库，你会注意到一个问题，那就是很多软件都有版本号。
我所说的版本，你可能已经在像浏览器这样的东西中看到过了，对吧？其中可能有一些像 Chrome 版本 64.0.2019.0324 这样的东西，这是一个版本号。
它可能有一个点，这是一种版本号。
但有时候，如果你开始使用 Photoshop 或其他工具，可能会有其他种类的版本号，比如 8.1.7，这些版本号通常是数字的，但并不总是这样。
有时候它们会在其中添加哈希值，例如为了引用 Git 提交。

你可能会问，为什么我们需要这些版本号？为什么在发布软件时添加版本号如此重要呢？主要原因是它让我们能够知道软件是否会出现故障。
想象一下，我依赖于Jose编写的一个库，而Jose一直在对他的库进行更改以使它更好。
他决定将库中公开的一个函数的名称更改。
我的软件突然停止工作，因为我的库调用了Jose库中的一个函数，但是该函数不再存在。
取决于人们安装的Jose库的版本，版本号有助于我指定我依赖于Jose库的哪个版本，并且必须有一些规则来规定在给定版本中Jose可以做什么。
如果他做了一个我不能再依赖的更改，他的版本必须以某种方式更改。
关于版本发布的规则，版本号如何更改等问题存在许多想法。
其中一些仅受时间约束。
例如，如果您看一下浏览器，它们通常具有类似于时间版本的版本号。
它们在最左侧有一个版本号，表示哪个发布版，然后有一个通常为零的增量号，最后有一个日期。
因此，这是2019年3月24日的某个版本64的Firefox。
如果他们发布针对安全漏洞的补丁或热修复，他们可能会增加日期但保持左侧版本不变。
人们对方案的具体内容有着强烈的意见，而你需要了解其他人使用的方案。
如果我不知道Jose用于更改版本的方案，也许我只能说，你必须运行Jose软件的817版本，否则我无法构建我的软件。
但这也是一个问题。
想象一下，Jose作为他的库的负责开发人员，他发现安全漏洞并修复了它，但它没有改变库的外部接口。
没有函数改变，没有类型改变。
然后我希望人们使用他的新版本来构建我的软件，恰好构建我的软件可以使用他的新版本，因为那个特定版本没有改变我所依赖的任何东西。
因此，对此的一种尝试解决方案是称为语义版本控制。
在语义版本控制中，我们为版本号中由点分隔的每个数字赋予特定的含义，并为不同数字的增加制定合同。

特别是在语义化版本控制中，我们称这个为主要版本，这个为次要版本，这个为补丁版本。
其规则如下：如果你对你的软件进行了完全向后兼容的更改，例如不添加任何东西，不删除任何东西，不在外部重命名任何东西，就像什么也没有改变一样，那么你只增加补丁号，不做其他更改。
通常，例如安全修复会增加补丁号。
如果你添加了库中的某些内容（我只是称其为库，因为通常库是这种情况下需要考虑的内容），则增加次要版本并将补丁设置为零。
在这种情况下，如果我们要进行一个次要发布，则下一个次要发布版本号将为 8-0。
我们这样做的原因是，我可能对 José 在 2.0 中添加的某个特性有依赖性，这意味着你不能使用 8-1-7 构建我的软件。
尽管如果你已经将其编写为 8-1-7，你可以在 2-0 上运行它。
反之则不是这样，因为它可能尚未添加。
最后，如果进行了向后不兼容的更改，则增加主要版本。
如果我的软件以前可以使用你所拥有的任何版本，然后你做出了一些改变，这意味着我的软件可能不再工作，例如删除或重命名函数，则增加主要版本并将次要和补丁设置为零。
因此，下一个主要版本将是 9-0-0。
综合在一起，这些使我们能够在设置我们的依赖项时做很好的事情。
特别是，如果我依赖于某个人的库的特定版本，而不是说它必须完全是这个版本，我真正想表达的是它必须是相同的主要版本，至少是相同的次要版本，并且补丁可以是任何内容。
这意味着，如果我依赖于 José 的软件，则仍在同一主要版本内的任何后续版本都可以。
请记住，这包括较早的版本，假设次要版本相同。
想象一下，你在某台装有 8.1.3 版本的旧计算机上。
理论上，我的软件也应该可以正常工作在 8.1.3 版本上。
它可能有 José 在其中修复的任何漏洞，例如任何安全问题。
但这具有很好的特性，现在你可以在计算机上的许多不同软件之间共享依赖关系。

如果您已经安装了8.3.0版本，并且有许多不同的软件需要8.1.7、8.2.4和8.0.1版本中的一个，那么它们都可以使用同一个依赖版本。
您只需要安装一次即可。
这种语义化版本控制中最常见或最熟悉的例子之一是Python版本控制。
你们中的许多人可能已经遇到过这个问题，Python 3和Python 2彼此不兼容。
它们不向后兼容。
如果你在Python 2中编写代码并尝试在Python 3中运行它，它可能不起作用。
有些情况下会起作用，但那更多的是偶然而非其他。
Python实际上遵循语义化版本控制，至少大部分是这样。
如果你编写运行在Python 3.5上的软件，那么它也应该在3.6、3.7和3.8上运行。
它不一定会在Python 4上运行，虽然那可能还需要很长一段时间。
但如果你为Python 3.5编写代码，它可能不会在Python 3.4上运行。
因此，你会看到许多软件项目尽可能降低它们的版本要求。
如果你可以依赖主版本和次版本以及修补版本0.0，那么这是你可以拥有的最好的依赖关系，因为它完全自由地依赖于你正在依赖的主要版本的哪个版本。
有时这很难。
有时你确实需要添加一个特性，但你可以把版本要求降到最低，这对于那些想要依赖你的软件的人来说是最好的。
反过来，在处理这些依赖管理系统或一般版本控制时，你经常会遇到锁定文件的概念。
你可能已经看到过这个问题，当你尝试做某事时，它会说“无法协调版本”，或者你会收到像“锁定文件已经存在”这样的错误。
这些通常是有些不同的主题，但总的来说，锁定文件的概念是为了确保你不会意外地更新某些东西。
锁定文件本质上只是一个列出你依赖关系及其当前使用版本的列表。
我的版本字符串可能是8.1.7，而最新版本可能是3.0，但在我的系统上安装的版本不一定是其中的一个。
它可能是8.2.4或类似的版本，锁定文件会说“依赖项José版本8.2.4”。
你想要一个锁定文件的原因有很多。
其中一个原因是您可能希望构建速度快。
如果每次尝试构建项目时，您使用的任何工具都会下载最新版本，然后编译它，再编译您的项目，那么每次等待时间可能会很长，具体取决于依赖项的发布周期。
如果您使用锁文件，除非您已在锁文件中更新了版本，否则它将仅使用之前为该依赖项构建的内容，您的开发周期可以更快。

使用锁文件的另一个原因是为了获得可重复的构建。
假设我生产了一些与安全相关的软件，我非常仔细地审查了我的依赖关系，并生成了一个签名的二进制文件，例如“这是我的宣誓声明，证明这个版本是安全的”。
如果我没有包含锁文件，那么当其他人安装我的程序时，他们可能会得到一个更晚的依赖版本，而这个版本可能已被黑客攻击或存在其他安全漏洞，而我还没有机会查看。
锁文件基本上允许我冻结生态系统，因为它是我已检查的版本。
这种做法的极端版本是一种称为“vendoring”的东西。
当您对依赖项进行vendoring时，实际上就是将它们复制/粘贴到项目中。
Vendoring意味着将您关心的任何依赖项复制到您的项目中，因为这样您就完全确定了将获得该依赖项的版本。
这也意味着您可以自己修改它，但它的缺点是您将不再获得版本控制的好处。
您将无法自动获取软件的新版本，例如当Hosea修复其安全问题时（当然他没有安全问题）。
您会注意到，当谈论这个问题时，我一直在谈论系统中的一些更大的过程。
这些过程包括测试，检查依赖关系版本以及设置构建系统等。
通常，您不只想要一个本地构建系统，您希望构建过程包括其他类型的系统，即使您的计算机不一定开着，它们也可以运行。
因此，随着您开始处理越来越大的项目，您会看到人们使用持续集成的概念，持续集成系统本质上是一个云构建系统。
这意味着您的项目存储在互联网的某个地方，并且您已经使用某种服务为您的项目运行持续集成，无论它是什么。
持续集成可以是各种各样的东西。
它可以是像将您的库自动发布到PyPI一样简单，每次提交到特定分支时。
它可以是类似于每当有人提交拉取请求时运行测试套件，或者可以是每次提交代码时检查您的代码风格。
您可以通过持续集成实现各种各样的事情，最简单的方法是将它们视为事件触发的操作。
因此，每当某个事件发生时，可能会针对您的项目发生特定的操作，其中操作通常是某种脚本、一系列要调用的程序，它们将执行某些操作。
这实际上是一个涵盖了许多不同类型的服务的大伞术语。
一些持续集成服务是非常通用的东西，比如Travis CI、Azure pipelines或GitHub actions都是非常广泛的CI平台。
它们旨在让您编写在您定义的任何事件发生时要发生的操作，非常广泛的系统。
还有一些更专业的系统，处理诸如持续集成覆盖测试之类的事情。

所以，像注释你的代码并展示你没有测试这段代码，它们仅用于这个目的，或者它们仅用于测试基于浏览器的库之类的东西。
因此，通常你可以找到为你正在工作的特定项目构建的CI工具，或者你可以使用其中的一个更广泛的提供者。
而且，其中一个好处是，许多CI工具实际上是免费的，特别是针对开源软件，或者如果你是学生，你也经常可以免费获得它们。
一般来说，你使用CI系统的方式是向你的代码库添加一个文件，这个文件通常称为“recipe”。
而这个recipe指定的内容是这种依赖循环，就像我们在make文件中看到的那样，但并不完全相同。
事件，而不是文件，可能是这样的，比如当有人推送提交时，当提交包含特定的消息时，或者当有人提交pull request或持续写入时。
一个不与你的代码的任何特定更改相关的持续集成服务的例子是Dependabot。
你可以在GitHub上找到它，而Dependabot是你连接到你的代码库中的一个东西，它将只扫描你没有使用的依赖项中是否有更新的版本。
因此，例如，如果我依赖于8.1.7，并且我有一个锁定文件将它锁定在8.2.4上，然后8.3.0发布了，Dependabot会说：“你应该更新你的锁定文件”，然后向你的代码库提交该更新的pull request。
这是一个持续集成服务。
它不是与我改变任何东西相关，而是与生态系统的整体变化相关。
这些CI系统通常也会与你的项目集成。
因此，这些CI服务经常会提供一些小徽章之类的东西。
让我举个例子。
例如，这是我最近参与的一个设置了持续集成的项目。
所以，这个项目，你会注意到它的README。
如果我可以用那个Chrome bean放大它，不，不，那比我想要的大得多。
在这里，你会看到在代码库页面的顶部有一堆这样的徽章，它们显示各种类型的信息。
“你会注意到我正在运行Dependable，对吧？所以依赖项当前是最新的。
它告诉我主分支上的测试套件是否正在通过。

它告诉我代码中有多少被测试覆盖了，并告诉我这个库的最新版本和在线可用的文档版本。
所有这些都由各种持续集成服务管理。
另一个你们中有些人可能会发现有用甚至熟悉的例子是GitHub Pages。
GitHub Pages是GitHub提供的一个非常好的服务，它允许你设置一个CI操作，将你的存储库构建为博客。
它运行一个静态站点生成器称为Jekyll，Jekyll只需要一堆Markdown文件，然后生成一个完整的网站。
作为GitHub Pages的一部分，它们还会将其上传到GitHub服务器并在特定域名下提供。
这实际上是课堂网站的工作方式。
课堂网站不是一堆我们管理的HTML页面。
相反，有一个名为'Missing Semester'的存储库。
如果你查看Missing Semester存储库，你会看到，如果我在这里缩小一下，它只有一堆Markdown文件。
这里有'Saket 20/20 - Metaprogramming.md'，所以这是今天讲座的原始Markdown。
这是我编写讲座笔记的方式，然后我将其提交到我们的存储库，并将其推送。
每当发生推送时，GitHub Pages CI将运行GitHub Pages的构建脚本，并为我们的课程生成网站，而无需我执行任何其他步骤来完成这一过程。
所以，是的，抱歉，好的，是的。
所以Jekyll，它使用一个称为Jekyll的工具，它是一个将包含Markdown文件的目录结构转换成网站的工具。
它会生成像HTML文件这样的文件，然后作为操作的一部分，它会将这些文件上传到GitHub服务器的一个特定域名下，通常是他们控制的'github.io'域名下。
然后我将Missing Semester设置为指向GitHub域名。
我想给大家一个关于测试的旁白，因为这是你们中很多人以前可能熟悉的东西，对测试有一个大致的概念。
你会在之前运行测试。
你曾经看过测试失败。
你知道基础知识，或者你从来没有见过测试失败。

如果你已经掌握了这些知识，那么恭喜你，但是当你开始涉及更高级的项目时，你会发现人们对于测试有很多专业术语。
"测试是一个非常深入的主题，你可能需要花费许多时间来理解其中的细节。
虽然我不会详细介绍所有的内容，但是有几个词汇我认为是有用的，你需要知道它们的含义。
第一个是测试套件。
测试套件是程序中所有测试的简单名称。
它只是一组测试，通常作为一个整体运行，通常由不同类型的测试组成。
第一个类型是单元测试。
单元测试是一种通常比较小的、自包含的测试，用于测试一个单一的功能。
什么是一个功能可能有点取决于项目，但是这个想法是应该有一个微型测试，只测试一个非常特定的东西。
然后你有更大的测试，称为集成测试。
集成测试尝试测试程序的不同子系统之间的交互。
所以这可能是这样一个例子：如果你正在编写一个 HTML 解析器，单元测试可能是测试它是否能够解析 HTML 标记。
而集成测试可能是这样一个例子：这是一个 HTML 文档，请解析它。
这将是解析器的多个子系统的集成。
你还有一个称为回归测试的概念。
回归测试是测试过去出现过问题的东西。
假设有人向你提交了一个问题，并说如果我给它一个跑马灯标记，你的库就会出现问题，这让你很难过，所以你想要修复它。
因此，你将修复解析器以支持我的标记，并在测试套件中添加一个检查是否可以解析跑马灯标记的测试。
这样做的原因是为了将来不会再次引入该错误。
因此，回归测试非常有用，随着时间的推移，你的项目将会积累越来越多这样的测试，它们非常好，因为它们可以防止项目退回到早期的 bug。
我想要提及的最后一个概念是模拟。

"mocking"是指能够用一种虚拟的方式替换掉系统的某些部分，这种虚拟版本的行为是由你控制的。
一个常见的例子是，你正在编写一个通过SSH进行文件拷贝的工具。
在这里，你可能想要模拟许多东西。
例如，在运行测试套件时，你可能并不关心是否有网络存在。
所以，你可以模拟网络。
通常的做法是，在你的库中，有一些东西打开连接，从连接中读取数据，或者向连接中写入数据。
你会在你的库内部覆盖这些函数，使用你专门为测试而编写的函数。
例如，读取函数只会返回数据，写入函数只会将数据丢弃。
同样，你可以为SSH功能编写一个模拟函数。
你可以编写一个不实际进行加密和与网络通信的函数。
这个函数只是接收字节，然后在另一端神奇地将它们弹出来。
你可以忽略其中的一切，因为对于文件拷贝的目的，如果你只是想测试该功能，那么下面的内容对于该测试并不重要。
通常情况下，在任何一种语言中，都有工具可以很容易地构建这些模拟抽象。
这就是我想讨论元编程的全部内容，但这是一个非常广泛的主题。
像持续集成、构建系统这样的东西，有很多可以让你对你的项目做很多有趣的事情，所以我强烈建议你稍微了解一下。
这些练习内容比较散，但这是件好事。
它们旨在尝试向你展示构建和处理这些过程的各种可能性。
例如，最后一个练习让你自己编写一个持续集成操作，你可以决定事件和操作是什么，但要尝试真正地构建一个。
这可能是你在项目中会发现有用的东西。
我在练习中给出的示例是尝试构建一个操作，对你的存储库运行英语语言的语法检查，例如RightGood或Proselint。
如果你真的这样做了，我们可以在课堂存储库中启用它，这样我们的讲义就会写得很好。
这种持续集成测试的另一个好处是，你可以在项目之间进行协作。
如果你编写了一个，我可以在我的项目中使用它，你可以构建这种提高一切的生态系统。

今天录制的任何内容有任何问题吗？是的，问题是，为什么我们既有make又有CMake？它们都是做什么的？它们之间有交流的原因吗？所以，CMake，我实际上不知道CMake的标语是什么，但它有点像C语言的更好的make。
顾名思义，CMake通常比make文件更好地了解C项目的布局。
它们的建立是为了尝试解析您的依赖项结构是什么，从一个规则到另一个规则的转换。
它还与像系统库这样的东西集成得更好，因此CMake可以执行诸如检测计算机上的给定库是否可用，或者如果该库在多个不同的路径上可用，它会尝试找到其所在的路径，然后进行适当的链接。
因此，CMake比make更智能。
make将只执行您在make文件中放置的任何内容。
这不是完全正确的，有称为隐式规则的东西，它们是make中的内置规则，但它们非常简单，而CMake则尝试成为一个大型构建系统，它默认针对C项目工作。
同样，还有一个名为Maven和Ant的工具，这是另一个项目。
它们都是为Java项目构建的。
它们了解Java代码如何相互交互，如何构造Java程序，并为此而构建。
通常，当我使用make时，我会在顶部使用make，然后使其他工具调用构建它们知道如何构建的任何子系统。
对我来说，make是我可能编写的顶部粘合剂。
通常，如果您的make文件变得非常大，有更好的工具。
您会发现在大公司，例如谷歌，他们通常有一个构建系统来管理其所有软件。
因此，如果您看看谷歌，他们有这个名为Basil的开源系统，我不认为谷歌在谷歌内部直接使用Basil，但它基于他们在内部使用的构建系统。
Basil实际上是建立为一种多语言构建框架，这是我认为他们称之为的想法。
因此，这个想法适用于许多不同的语言。
有像这种语言和那种语言的Basil模块，但它们都与相同的Basil框架集成，然后该框架知道如何在不同库和不同语言之间集成依赖项。
你有问题吗？当你说表达式时，你是指这个文件中的东西吗？是的，所以make文件是它们自己的语言。

他们是。
这是一种相当奇怪的语言。
就像Bash一样，它有很多奇怪的例外。
在很多方面，它就像Bash一样奇怪，但在不同的方面更糟糕。
当你编写makefile时，你可能会认为自己正在编写Bash，但实际上它有不同的错误。
但是，它确实是一种独立的语言。
makefile通常的结构是你有一系列的指令，我想他们称之为指令。
每个指令都有一个冒号，在冒号左侧的是一个目标，在冒号右侧的是一个依赖项。
然后，下面的所有行都是操作序列，也称为规则，用于一旦你有了依赖项，如何构建这些目标？注意，makefile非常注重你必须使用制表符来缩进规则。
如果不这样做，make就不会工作。
它们必须是制表符，不能是4或8个空格，必须是制表符。
你可以在这里有多个操作。
我可以做echo hello或其他什么，然后它们将首先运行这个，然后运行这个。
今天的讲座中有一个练习，让你尝试扩展这个makefile，加入一些其他有趣的目标，更详细地介绍一下。
还有一些能力来执行外部命令，以确定依赖项可能是什么，如果你的依赖项不是静态文件列表，但是它有一点限制。
通常，一旦你开始需要这种东西，你可能需要转移到更高级的构建系统。
是的，问题是，如果我有，假设我有库a和库B，它们都依赖于库C，但库a依赖于4.0.1，库B依赖于3.4.7，会发生什么？
所以它们都依赖于 C，理想情况下，我们希望重用 C，但它们依赖于不同的主要版本的 C。
我们该怎么办？这种情况下发生的情况完全取决于您正在使用的系统和语言。
在某些情况下，工具会选择其中一个版本，这暗示它们实际上没有使用语义化版本控制。
在某些情况下，工具会显示“不可能”。
如果这样做，会导致错误，并且工具将告诉您需要升级 B，例如使 B 使用 C 的较新版本，或者降级 A。
你不能这样做，编译将失败。
有些工具将构建两个版本的 C，然后在构建 A 时使用 C 的主要版本 4，在构建 B 时使用 C 的主要版本 3。
你最终会遇到一些非常奇怪的情况，例如如果 C 有依赖项，则现在必须将所有 C 的依赖项都构建两次，一次用于 3，一次用于 4，也许它们共享，也许它们不共享。
你可能会遇到特别奇怪的情况。
如果想象一下库 C，比如说库 C 写入一个文件，比如说写入磁盘上的一些缓存。
如果现在运行您的应用程序，A 做了一些调用，比如调用 C.dot save，而 B 做了一些调用，比如调用 C.adult load，那么底层的应用程序就不会工作，因为格式是不同的，对吧？因此，这些情况通常非常棘手，大多数支持语义化版本控制的工具会因为这个原因拒绝这种配置。
但是，要自己搞砸是很容易的。
好了，我们明天再见，进行安全方面的学习。
请记住，如果您还没有填写问卷调查，请务必参加。
在问卷调查中，我最关心的问题是您希望我们在最后两节课中涵盖什么内容。
因此，请选择您想要我们讨论的主题并提出任何问题。
如果可以，请填写问卷调查。
就这样，明天见。
