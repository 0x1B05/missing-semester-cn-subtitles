好的，大家都能听到我讲话吗？好的，欢迎回来。
我想谈一些行政事务。
第一周结束后，我们发了一封电子邮件通知你们我们已经上传了第一周的视频，所以你们可以在网上找到它们。
它们有我们做的所有屏幕录像，所以你们可以回头看看，如果你们对我们快速进行的某些事情感到困惑，可以随时问我们任何问题，如果讲义中的任何内容不清楚的话。
我们还发了一份调查问卷，所以你们可以向我们提供反馈，告诉我们哪些地方不清楚，哪些地方需要更详细的解释，或者其他任何问题，如果你们发现练习太难或太容易，请在那个网址里留言，我们会非常感激得到这些反馈，因为这将使课程在剩下的讲座和未来的课程迭代中变得更好。
这些事情说完了，我们将尽量及时上传视频，不想等到一周的结束才上传，所以请持续关注。
这些都说完了，现在我要开始这次讲座了，它叫做命令行环境，我们会涵盖一些不同的话题。
所以我们要涵盖的主要话题，你们可以记住，可能在这里更好，以便跟上我的讲话。
第一个是作业控制，第二个是终端复用器。
然后我会解释什么是点文件以及如何配置你的 shell。
最后，如何高效地与远程机器工作。
所以如果有什么不清楚的地方，请记住这些结构。
它们在某种程度上相互交互，涉及如何使用你的终端，但它们是一些相对独立的话题，所以请记住这一点。
那么我们就来看一下作业控制。
到目前为止，我们一直以一种很单一的方式使用 shell，比如，你执行一个命令，然后命令执行，然后你得到一些输出，这就是你可以做的一切。
如果你想运行几个东西，那就不清楚该怎么做。
或者如果你想停止一个程序的执行，那又该怎么做呢？我们可以用一个叫做 sleep 的命令来演示这一点。
Sleep 是一个带有参数的命令，这个参数将是一个整数，它会睡眠。
它会在后台睡眠这么多秒。
所以如果我们做像 sleep 20 这样的事情
如果我们执行类似于 sleep 20 的命令，该进程将会休眠 20 秒钟。
但我们不想等待 20 秒钟才能完成命令。
因此，我们可以输入 "Ctrl+C"。
通过输入 "Ctrl+C"，我们可以看到，在这里，终端通知我们，这是我们在编辑器 / Vim 讲座中介绍过的语法的一部分，我们输入了 "Ctrl+C"，它停止了进程的执行。
实际上，这里正在使用一种名为信号的 UNIX 通信机制。
当我们键入 "Ctrl+C" 时，终端为我们发送了一个名为 SIGINT 的信号，该信号表示信号中断，告诉程序停止自己。
还有许多这样的信号。
如果你输入 man signal，然后向下滚动一点，你就会看到它们的列表。
它们都有数字标识符，有一种短名称和描述。
例如，我刚刚描述的信号在这里，编号为 2，是 SIGINT。
这是终端在想要中断程序执行时发送给程序的信号。
还有一些信号需要熟悉，例如 SIGQUIT，如果你从终端工作并希望退出程序执行。
对于大多数程序，它们将执行相同的操作，但现在我们将展示一个不同的程序，这是将发送的信号。
有时候可能会有些混淆。
查看这些信号，例如，SIGTERM 在大多数情况下等同于 SIGINT 和 SIGQUIT，但它只是当它不通过终端发送时。
我们将要介绍的其他一些信号包括 SIGHUP，它表示终端出现了问题。
例如，当你在终端中运行程序时，如果你关闭终端，但终端中仍在运行一些程序，那么程序将发送该信号告诉所有进程应该关闭，就像命令行通信中出现了故障，它们现在应该关闭。
信号可以做更多的事情，而不仅仅是停止、中断程序并要求它们完成。
你可以使用 SIGSTOP 暂停程序的执行，然后使用 SIGCONT 命令在稍后的时间点继续执行程序。
由于所有这些可能有些抽象，让我们看一些例子。
首先，让我们展示一个 Python 程序。
我将非常快速地浏览一遍程序。

这是一个Python程序，像大多数Python程序一样，它正在导入这个信号库并在此处定义这个处理程序。
这个处理程序正在写入“哦，我收到了一个SIGINT，但我不会停在这里”。
之后，我们告诉Python，当它收到SIGINT时，我们希望这个程序停止。
程序的其余部分是一个非常愚蠢的程序，只会打印数字。
现在让我们看看它的运行过程。
我们运行Python SIGINT。
它正在计数。
我们尝试使用“Ctrl+C”来停止它，这会发送SIGINT，但程序实际上并没有停止。
这是因为程序在处理此异常的方式上有一个方法，我们不想退出。
如果我们发送SIGQUIT，也就是通过“Ctrl+\”完成的，我们可以看到，由于程序没有处理SIGQUIT的方法，它会执行默认操作，即终止程序。
例如，如果有人Ctrl+C了您的程序，您的程序应该执行某些操作，例如保存程序的中间状态到文件中，以便以后恢复，您可以使用此功能。
这就是您可以编写此类处理程序的方法。
您能再重复一遍问题吗？当它停止时，您输入了什么？所以我...我输入了“Ctrl+C”尝试停止它，但它没有停止，因为SIGINT被程序捕获了。
然后我输入了“Ctrl+”，这会发送一个不同的信号SIGQUIT，而这个信号没有被程序捕获。
值得一提的是，有一些信号是软件无法捕获的。
例如，有一些信号像SIGKILL是不能被捕获的。
如果这样做，它将终止进程的执行，无论如何。
这有时可能是有害的。
因为这可能会留下孤儿进程。
例如，如果一个进程有其他小孩子进程，它会启动，而你SIGKILL它，所有这些进程都会继续在那里运行，但它们将没有父进程，你可能会遇到非常奇怪的行为。
如果我们注销，程序会收到什么信号？如果您注销？那将是...例如，如果您在SSH连接中关闭连接，那就是挂起信号SIGHUP，我将在一个例子中介绍。
这就是会被发送的信号。
您可以编写一个包装器，忽略该信号，以使该进程在关闭时继续工作。

让我们展示一下使用停止和继续功能能做什么。
例如，我们可以启动一个非常长的进程。
让我们睡眠一千秒，这将花费很长时间。
我们可以按"Ctrl+Z"组合键控制进程，如果我们这样做，我们可以看到终端显示"已暂停"。
这实际上意味着该进程被发送了一个SIGSTOP信号，现在仍然在那里，您可以继续执行它，但现在它完全停止了，并且在后台，我们可以启动一个不同的程序。
当我们尝试运行这个程序时，请注意我在末尾包含了一个"&"。
这告诉bash我希望该程序在后台开始运行。
这与在shell中运行程序的所有这些概念有关，但是是后台运行的。
程序将开始运行，但不会接管我的提示符。
如果我只是运行此命令而没有这个符号，我将无法执行任何操作。
在命令完成或我突然结束它之前，我将无法访问提示符。
但如果我这样做，它会说"有一个新的进程是这个"。
这是进程的标识号，我们现在可以忽略它。
如果我键入"jobs"命令，我会得到输出，表示我有一个已暂停的工作，即"sleep 1000"工作。
然后我有另一个正在运行的工作，即"NOHUP sleep 2000"。
假设我想继续第一个工作。
第一个工作已暂停，不再执行。
我可以通过"BG %1"命令继续执行。
"%"是指我想引用这个特定的进程。
现在，如果我这样做并查看工作，现在这个工作再次在运行。
现在两个都在运行。
如果我想停止所有这些，我可以使用"kill"命令。
"kill"命令用于杀死工作，即停止它们，直观地说，但实际上非常有用。
"kill"命令允许您发送任何类型的Unix信号。
例如，在这里，我们不完全杀死它，而是发送一个停止信号。
我将发送一个停止信号，这将再次暂停该进程。
我仍然必须包含标识符，因为没有标识符，shell将不知道是停止第一个还是第二个。
现在它说已被暂停，因为有一个信号被发送。
如果我再次键入"jobs"命令，我们可以看到第二个正在运行，而第一个已被停止。

回到之前的一个问题，如果你关闭终端窗口，会发生什么？为什么有时候人们会建议在远程会话中运行作业之前使用 NOHUP 命令？这是因为如果我们尝试向第一个作业发送挂起命令，类似于其他信号，它会将其挂起，这将终止该作业。
第一个作业不再存在，而第二个作业仍在运行。
然而，如果我们尝试向第二个作业发送信号，如果我们现在关闭终端窗口，它仍将继续运行。
就像 NOHUP 一样，它将所执行的命令封装起来，忽略任何挂起信号，并使其继续运行。
如果我们向第二个作业发送"kill"信号，那么它将无法被忽略，这将杀死该作业，无论如何。
我们就没有任何作业了。
这种情况下的工作控制部分就讲完了。
到目前为止有没有什么问题？有没有什么没有讲清楚的地方？什么是 BG？BG有两个命令。
当你的作业被后台运行并停止时，你可以使用 BG (短语"background") 命令来继续在后台运行该进程。
这相当于向其发送一个继续信号，使其继续运行。
然后还有另一个命令叫做 FG，如果你想将其恢复到前台并重新连接标准输出。
好的，作业控制是很有用的，通常情况下，当你需要在一个窗口中编辑器和另一个窗口中程序，并且可能要监视标签中的资源消耗时，你需要做的实际上是打开更多的窗口。
我们可以一直打开终端窗口。
但事实是，这种情况有更方便的解决方案，这就是终端复用器的作用。
像tmux这样的终端复用器可以让你创建不同的工作空间，让你可以快速地重新排列环境，而且它有很多功能。
它可以让你有不同的会话。
还有一个更...古老的命令，叫做"screen"，它可能更容易获得。

我认为这个概念可以推广到两个方面。
我们推荐学习 tmux，实际上我们有相应的练习。
现在我将展示一个不同的场景。
我讲话时...哦，让我做个简短的笔记。
tmux 有三个核心概念，我会详细讲解。
主要思想是有所谓的“会话(session)”，会话包含“窗口(window)”，而窗口包含“窗格(pane)”。
记住这个层次结构将会很有用。
你可以将“窗口(window)”基本上等同于其他编辑器和浏览器中的“标签(tabs)”。
我将介绍功能，主要是你在不同级别上能做什么。
首先，当我们运行 tmux 时，它会启动一个会话。
在这里，现在似乎什么都没有改变，但现在正在发生的是我们在一个与之前不同的 shell 中。
因此，在我们的 shell 中，我们启动了一个进程，即 tmux，然后 tmux 启动了一个不同的进程，即我们当前所在的 shell。
这个很好的一点是，这个 tmux 进程与原始 shell 进程是分开的。
在这里，我们可以做一些事情。
例如，我们可以执行“ls -la”，查看里面发生了什么。
然后我们可以开始运行我们的程序，它将在其中运行，我们可以使用“Ctrl+A d”来分离会话。
如果我们使用“tmux a”，那么我们会重新连接到会话。
我们离开了计算数字的非常愚蠢的 Python 程序，并且如果我们 tmux...嘿，进程仍然在那里运行。
我们可以关闭这个终端并打开一个新的终端，我们仍然可以重新连接，因为这个 tmux 会话仍在运行。
再次说明，在 tmux 中，与 Vim 不同，它没有模式的概念，而是采用了更类似于 Emacs 的方式，即几乎每个 tmux 命令都可以通过其命令行输入。
但我建议你熟悉键绑定。
一开始可能有点难以理解，但一旦你熟悉了它们...
"Ctrl+C"，是的，当你熟悉了它们之后，你会比使用命令更快地使用键绑定。
关于键绑定的一个注意点：所有的键绑定都有一个形式，就像你输入一个前缀，然后再按一些键。
例如，要分离，我们要按下“Ctrl+A”，然后再按“D”。
这意味着你首先按下“Ctrl+A”，然后松开它，再按“D”来分离。
在默认的tmux中，前缀是“Ctrl+B”，但你会发现大多数人将其重新映射为“Ctrl+A”，因为在键盘上更加人性化。
你可以在练习中了解更多关于如何进行这些操作的信息，我们会链接到基础知识和如何对tmux进行某些生活质量的修改。
回到会话的概念，我们可以通过像“tmux new”这样的命令创建一个新的会话，我们可以给会话命名。
所以我们可以像“tmux new -t foobar”这样做，这是一个完全不同的会话，我们已经开始了。
我们可以在这里工作，我们可以从中分离出来。
“tmux ls”会告诉我们我们有两个不同的会话：第一个是命名为“0”，因为我没有给它命名，第二个被称为“foobar”。
我可以附加到foobar会话，也可以结束它。
这非常好，因为有了这个，你可以在完全不同的项目中工作。
例如，有两个不同的tmux会话和不同的编辑器会话，不同的进程正在运行......当你在一个会话中时，我们从窗口的概念开始。
这里我们有一个单独的窗口，但是我们可以使用“Ctrl+A c”（用于“创建”）来打开一个新窗口。
这里没有执行任何操作。
它的作用是，tmux为我们打开了一个新的shell，我们可以在这里开始运行另一个这些程序之一。
为了快速跳转标签，我们可以按“Ctrl+A”和“previous”、“p”（表示“previous”）来上一个窗口。
“Ctrl+A”和“next”来到下一个窗口。
你也可以使用数字。
所以如果我们开始打开很多这些标签，我们可以使用“Ctrl+A 1”来特定地跳转到编号为“1”的窗口。
最后，也很有用的是有时你可以重新命名它们。
例如，这里我正在执行这个Python进程，但那可能并不是真正有意义的，我想......我可能想要有像“execution”之类的东西，这样就可以重新命名该窗口的名称，以便你可以整理得非常整齐。

这样做并不能满足你想要在终端中同时拥有两个东西的需求，比如在同一个显示屏中。
这就是窗格存在的原因。
现在，我们有一个只有一个窗格的窗口（到目前为止，我们打开的所有窗口都只有一个窗格）。
但是如果我们按下“Ctrl+A"，然后按下引号键，这将把当前显示屏分成两个不同的窗格。
你看，我们打开的下面的那个是与上面的不同的shell，我们可以在这里运行任何进程。
我们可以继续分裂，如果我们按下“Ctrl+A %"，那么就会垂直分裂。
你可以使用许多不同的命令来重新排列这些选项卡。
其中一个我发现非常有用的命令是，当你开始时感到有些沮丧，需要重新排列它们。
在我解释之前，要移动这些窗格，这是你想一直做的事情，你只需按下“Ctrl+A"和箭头键，这样就可以快速浏览不同的窗口并再次执行操作……我正在做很多“ls -a”，我可以做“HTOP”，我们将在调试和分析讲座中解释这个。
我们可以浏览它们，就像重新排列它们一样，还有一堆命令，你可以在练习中学习。
“Ctrl+A" space非常棒，因为它会将当前的选项卡等距分布，并让你通过不同的布局。
有些对于我的当前终端配置来说太小了，但我认为这覆盖了大部分内容。
哦，还有，例如，我们已经开始执行的Vim，对于当前的tmux窗格来说太小了。
因此，相对于拥有多个终端窗口，一个非常方便的事情就是可以在tmux中放大它，你可以通过按下“Ctrl+A z”来要求“缩放”。
它会扩展窗格以占据所有的空间，然后再按下“Ctrl+A z”即可返回。
对于终端多路复用器或tmux具体来说有什么问题吗？是在运行所有相同的东西吗？在不同的窗口中运行是否有任何执行差异？是的，它不会与在计算机中打开两个终端窗口有任何区别。
当然，当它到达CPU时，这将再次进行多路复用。
就像有一个时间共享机制，但没有任何区别。
tmux通过为您提供这个可以快速操作的可视化布局，使使用变得更加方便。

其中一项主要优势将在我们到达远程机器时体现，因为您可以留下其中之一，我们可以从其中一个tmux系统中分离出来，关闭连接，即使我们关闭连接并且终端将发送挂起信号，也不会关闭所有已启动的tmux。
还有其他问题吗？让我禁用按键记录器。
现在我们要进入dotfiles的主题，以及一般如何配置您的shell以执行您想要执行的任务，主要是如何更快地执行它们并以更方便的方式执行。
我将首先使用别名来激励大家。
所谓别名，就是现在，您可能正在开始做很多次的事情，例如，我只想LS一个目录，并将所有内容以列表格式和可读格式显示出来。
这很好。
它不是那么长的命令。
但是，随着您构建越来越长的命令，反复输入它们可能会变得有点麻烦。
这就是别名有用的原因之一。
别名是一个将成为您shell内置的命令，它将重新映射一个短字符序列到一个长序列。
例如，如果我执行alias ll="ls -lah"，这将使用这个参数调用"alias"命令，LS将更新我的shell环境以了解这个映射。
因此，如果我现在执行LL，它将在不必键入整个命令的情况下执行该命令。
它可以非常方便，有很多很多用途。
需要注意的一件事是，这里的alias与其他命令没有什么特殊之处，它只是接受单个参数。
在等号周围没有空格，这是因为别名只接受一个参数，如果您尝试执行类似于这样的操作，那么就会给它更多的参数，那是不起作用的，因为那不是它期望的格式。
除此之外，别名还有其他用例，例如，对于某些事情来说，使用别名可能更方便，比如我的最爱之一就是git status。
它非常长，我不喜欢经常键入那么长的命令，因为您最终会花费很多时间。
因此，GS将替换为执行git status。
您还可以使用别名将经常打错的命令别名为自己，但加上默认标志。
"sl=ls"就是一个例子。

其他有用的映射方式是，你可能想将一个命令别名为带有默认标志的自身。
因此，我现在要创建一个别名，它是对"move"命令的别名，即"MV"，并将其别名为相同的命令，但添加了"-i"标志。
如果你查看man页面，你会发现"-i"标志代表"交互式"。
这将在我覆盖文件之前提示我。
一旦我执行了这个命令，我就可以像这样移动"aliases"到"case"。
默认情况下，"move"命令不会询问，如果"case"已经存在，它将被覆盖。
那很好，我要覆盖那里的任何东西。
但现在，"move"已经被扩展为"move -i"，并使用它来询问我"你确定要覆盖它吗？"我可以选择不覆盖，以避免丢失文件。
最后，你可以使用"alias move"命令来查询这个别名的含义。
这样可以快速确定你实际执行的命令是什么。
例如，有一个不方便的部分是，如果你有别名，那么如何将它们持久化到你当前的环境中呢？如果我现在关闭这个终端，所有这些别名都会消失。
你不想一遍又一遍地重新输入这些命令。
更一般地说，如果你开始配置你的shell，你需要某种方式来引导所有这些配置。
你会发现大多数shell命令程序都使用一些基于文本的配置文件。
由于历史原因，我们通常称其为"dotfiles"，因为它们以点号开头。
所以对于我们的shell，比如bash，我们可以查看bashrc文件。
为了演示目的，在这里我一直在使用ZSH，这是一个不同的shell，我将会配置bash，并启动bash。
所以如果我在这里创建一个条目，我说SL映射到LS，我已经修改了它，现在我启动bash。
Bash现在是完全未配置的，但现在如果我输入SL...嗯，这是意外的。
哦，好的。
那很重要，你的配置文件要放在你的主文件夹中。
因此，bash的配置文件将位于"~"中，它会扩展到你的主目录，然后是bashrc。
在这里，我们可以创建别名，不仅可以使用别名，还可以有很多其他的配置。

现在我们开始一个Bash会话并运行SL。
现在它已经加载了，在Bash程序启动时加载了所有的配置。
例如，在这里，我有一个相当无用的提示符。
它只告诉我使用的shell名称是Bash，版本是5.0。
我不想显示它，而且在您的shell中，像许多其他东西一样，这只是一个环境变量。
因此，“PS1”只是您提示符的提示字符串，我们实际上可以修改它，使其成为一个“>”符号。
现在已经修改过了，我们已经有了这个。
但是，如果我们退出并再次调用Bash，这个修改就会丢失。
但是，如果我们添加这个条目并说，我们希望“PS1”是这样的，然后再次调用Bash，这个修改就会被保留下来。
我们可以继续修改这个配置。
所以也许我们想包含我们正在工作的目录，这告诉我们我们在其他shell中所看到的相同的信息。
还有许多许多选项，Shell是高度可配置的，不仅是通过这些文件配置Shell，还有许多其他程序。
就像我们在编辑器讲座中看到的那样，Vim也是通过这种方式进行配置的。
我们给你这个vimrc文件，并告诉你将它放在home/.vimrc下，这是相同的概念，但只是针对Vim。
它只是在启动时给它一组指令，以便您可以保持所需的配置。
甚至许多非...许多程序也支持这种方式。
例如，我的终端仿真器，这是另一个概念，是运行shell的程序，并将其显示在计算机屏幕上。
它也可以通过这种方式进行配置，因此如果我修改它，我可以更改字体的大小。
例如，现在，我已经为演示目的增加了字体大小，但如果我更改这个条目并使其为28，然后写入这个值，你会发现字体的大小已经改变了，因为我编辑了这个文本文件，它指定了我的终端仿真器应该如何工作。
还有其他问题关于点文件吗？好的，知道有这么多的配置可能会让人感到有些不知所措，是吗？
你如何学习关于哪些内容可以进行配置？好消息是，我们在讲义中已经为你提供了非常好的资源链接。
但是主要思想是很多人喜欢配置这些工具，他们把自己的配置文件上传到了GitHub这样的在线库中。
例如，在GitHub上搜索“dotfiles”，你会发现有成千上万的人分享他们的配置文件。
我们的课程导师也链接了我们的dotfiles。
因此，如果你真的想知道我们设置中的任何部分是如何工作的，你可以查看这些文件并尝试弄清楚。
你也可以随意向我们询问。
例如，如果我们转到这个存储库，我们会发现有很多文件可以配置。
例如，有一个用于bash的文件，前几个用于git，这些可能会在版本控制讲座中进行介绍。
如果我们例如转到bash配置文件，它是一种不同形式的bashrc，它非常有用，因为你可以通过查看手册页来学习，但是手册页通常只是所有不同选项的描述性解释，有时通过看其他人的示例并尝试理解他们为什么这样做以及它如何帮助他们的工作流程更有帮助。
我们可以看到这里的人已经进行了不区分大小写的文件名扩展操作。
我们在shell脚本和工具中介绍了扩展操作。
这里你说不，我不想区分大小写，只需在shell中设置此选项即可使这些操作按照你期望的方式运行。
类似地，还有一些别名。
在这里，你可以看到这个人正在做很多别名。
例如，“d”代表“Dropbox”，因为这样更短。
“g”代表“git”……例如我们来看一下vimrc。
通过查看它并尝试提取有用信息，这实际上可以非常有信息量。
我们不建议只是将一个巨大的配置文件复制到你的文件中，因为可能看起来更漂亮，但你可能真的不了解其中的情况。
最后，关于dotfiles我想提到的一件事是，人们不仅试图将这些文件推送到GitHub中以便其他人阅读，这是其中一个原因。
他们还确保他们可以重现他们的设置。
为此，他们使用了各种不同的工具。
例如GNU Stow，他们将所有的dotfiles放在一个文件夹中，并使用一种名为符号链接的工具欺骗系统，让它们看起来是实际的文件。

我来快速画一下我所说的意思。
通常的文件夹结构可能是这样的：你有你的主文件夹，在这个主文件夹中可能会有你的bashrc，它包含了你的bash配置；你可能会有你的vimrc，如果你能把它们放在版本控制下就太好了。
但是问题是，你可能不想在你的主文件夹中放置一个git仓库（关于git的内容明天会讲到）。
所以人们通常会创建一个dotfiles仓库，然后在这里为他们的bashrc和vimrc创建条目。
这其实就是文件所在的地方，他们只是告诉操作系统，无论何时有人想要读取这个文件或者写入这个文件，都把这个请求转发到另一个文件。
这是一个叫做符号链接的概念，在这种情况下很有用，但是它通常是UNIX中一个非常有用的工具，我们在讲座中还没有涉及到，但是你应该熟悉。
通常情况下，语法是使用“ln -s”指定一个符号链接，然后把你想要创建的文件的路径和你想要创建的符号链接放在一起。
所有这些高级工具，我们在这里列出来的，它们都可以用一些技巧实现，这样你就可以把所有的点文件整齐地放在一个文件夹里，它们可以被版本控制，也可以被符号链接，这样其它程序可以在它们的默认位置找到它们。
关于点文件有什么问题吗？你需要在你的主文件夹和版本控制文件夹中都有点文件吗？例如，bash程序总是会查找"home/.bashrc"。
这就是程序要查找的位置。
当你创建一个符号链接时，你把你的"home/.bashrc"放在一个特殊的UNIX文件中，这个文件只是一个指针，它说：“无论何时你想读取这个文件，都要去找那个文件。
”这个文件没有内容，比如你的别名不是这个点文件的一部分。
通过这样做，你可以把你的其他文件放在那个文件夹中。

如果版本控制没有用处，那么想一想如果你想将它们放到Dropbox文件夹中，这样它们就可以同步到云端，这是另一种情况，这时符号链接可能非常有用，因此你不需要将dotfiles文件夹放在主目录中，对吧？因为你可以使用符号链接，指向其他位置。
只要你有一种方式让默认路径解析到你所在的位置就可以了。
哦，抱歉，有没有其他关于dotfiles的问题？最后我想在讲座中讨论一下与远程计算机的交互，这是你迟早会遇到的情况。
如果你知道一些东西，它们会让你在处理远程计算机时更加轻松。
也许现在因为你在使用Athena集群，但在你的编程生涯中，有一个非常普遍的概念，就是你有你的本地工作环境，然后有一些生产服务器实际上正在运行代码，因此熟悉如何在/与远程计算机一起工作非常重要。
因此，处理远程计算机的主要命令是SSH。
SSH就像一个安全的Shell，它将负责到达我们想要到达的地方或者告诉它去打开一个会话。
这里的语法是：“JJGO”是我想要在远程机器上使用的用户，这是因为该用户与我本地机器上的用户不同，这在很多情况下都是这样，然后“@”告诉终端这个符号分离了用户和地址。
这里我使用的是一个IP地址，因为我实际上在我的计算机中有一个虚拟机，这是远程的。
我将要通过SSH连接它。
这是我使用的URL，抱歉，我使用的IP，但是你也可能会看到类似这样的东西：“我想以‘JJGO’在‘foobar.mit.edu’上SSH”。
如果你使用一些具有DNS名称的远程服务器，这可能是更常见的。
回到常规命令，我们尝试SSH，它会要求我们输入密码，这是非常常见的事情。
现在我们在那里。
我们仍然在我们同一个终端模拟器中，但现在SSH会将整个虚拟显示器转发到显示远程shell正在显示的内容。

我们可以在这里执行命令并查看远程文件。
关于SSH，有一些方便的事情在数据整理讲座中简要介绍过，它不仅仅适用于打开连接，还可以让你远程执行命令。
例如，如果我这样做，它会再次询问我的密码。
它会执行这个命令，然后回到我的终端，并通过当前单元格的标准输出将该命令的输出，也就是远程机器的输出，传输过来。
我可以将其放入管道中，并在本地管道中继续工作。
到目前为止，必须输入密码有点不方便。
有一个很好的技巧可以解决这个问题。
它就是我们可以使用称为“SSH密钥”的东西。
SSH密钥使用公钥加密来创建一对SSH密钥，一个公钥和一个私钥，然后您可以将公钥部分给服务器。
因此，您复制公钥，每当您尝试进行身份验证时，它将使用私钥向服务器证明您实际上是您所说的人。
我们可以快速展示如何做到这一点。
现在我没有任何SSH密钥，所以我要创建一对。
第一件事，它会问我想让这个密钥存储在哪里。
毫不意外，它正在执行这个操作。
这是我的主文件夹，然后它使用这个“.ssh”路径，这是我们之前提到过的点文件的概念。
像“.ssh”是一个包含许多配置文件的文件夹，用于设置SSH的行为方式。
因此，它会要求我们输入一个密码。
这个密码是用来加密密钥的私钥部分的，因为如果有人得到了您的私钥，如果您没有受到密码保护的私钥，如果他们得到了那个密钥，他们可以在任何服务器上冒充您。
而如果您添加了密码，他们必须知道密码才能实际使用密钥。
它创建了一个“keeper”。
我们可以检查这两个文件现在是否在ssh下，并且我们可以看到...我们有这两个文件：我们有25519和公钥。

如果我们通过输出 "cat" 命令查看这个密钥，那么这个密钥实际上不是什么复杂的二进制文件，它只是一个文本文件，里面包含了公钥和一些别名，这样我们就知道这个公钥是什么。
我们可以通过将这个文件复制到 ".ssh/authorized_keys" 文件中来告诉服务器我们有 SSH 授权。
这里我正在使用 "cat" 命令来查看这个文件的输出，它只是一个我们想要复制的文本行，然后将其传输到 SSH 中，然后远程使用 "tee" 命令将标准输入的内容倾倒到 ".ssh/authorized_keys" 中。
如果我们这样做，显然会要求我们输入密码。
复制成功后，我们可以检查一下，如果再次尝试 SSH，它会首先要求我们输入口令，但是您可以安排在会话中保存口令，这样我们就不必为服务器输入密钥。
我可以再次演示一下。
还有更多有用的内容。
哦，我们可以做...如果那个命令看起来有点奇怪，您实际上可以使用专门为此构建的命令，这样您就不必构建这个 "ssh t" 命令了。
这个命令就叫做 "ssh-copy-id"。
我们可以做同样的事情，它会复制密钥。
现在，如果我们尝试 SSH，我们可以在不输入任何密钥或密码的情况下进行 SSH。
还有更多内容。
我们可能想要复制文件。
您不能使用 "CP" 命令，但可以使用 "SCP" 命令，即 "SSH 复制"。
在这里，我们可以指定要复制的本地文件名为 "notes"，语法有些相似。
我们要将它复制到远程位置，然后使用分号分隔要复制到的路径。
然后我们指定要将其复制为 "notes"，但我们也可以将其复制为 "foobar"。
如果我们这样做，它将被执行，并告诉我们所有的内容都已经被复制到那里了。
如果您要复制很多文件，那么您应该使用一个更好的命令，它叫做 "RSYNC"。
例如，在这里仅通过指定这三个标志，我告诉 RSYNC 在可能的情况下保留所有权限，以尝试检查文件是否已经被复制。

例如，SCP将尝试复制已经存在的文件。
例如，如果您在复制过程中断开连接，SCP会从头开始尝试复制每个文件，而RSYNC会从停止的地方继续。
在这里，我们要求它复制整个文件夹，它只需要很快地复制整个文件夹。
关于SSH的另一个需要知道的事情是，“SSH配置”是SSH的点文件的等效文件。
因此，如果我们编辑SSH配置文件，如果我将SSH配置文件编辑成这样，就不必每次都输入“ssh jjgo”这个非常长的字符串，这样我就可以引用特定的远程主机。
我想引用特定的用户名，我可以在这里加上一些内容，例如这是用户名，这是主机名，该主机所指的内容以及你应该使用这个身份验证文件。
如果我将此内容复制到本地文件夹中，我可以将其复制到ssh中。
现在，我只需要说我想要SSH连接到名为VM的主机。
通过这样做，它会从SSH配置中获取所有的配置并将其应用于这里。
这个解决方案比创建SSH别名之类的东西要好得多，因为像SCP和RSYNC这样的其他程序也知道SSH的点文件，并且在有时会使用它们。
关于远程机器，我最后要介绍的是在这里，例如，我们将有tmux，我们可以像之前说的那样开始编辑某个文件并开始运行某个作业。
例如，像HTOP这样的东西。
这正在运行，我们可以从中分离，关闭连接，然后再次SSH。
然后，如果您执行“tmux a”，一切都与您离开的状态一样，就好像什么也没有改变。
如果在后台有执行的事情，它们将继续执行。
我想这就是我要讲的有关这个工具的所有内容。
与远程机器有关的任何问题？这是一个非常好的问题。
我为此做了什么。

哦，是的，抱歉。
问题是，如何在本地机器上使用tmux，同时又要在远程机器上使用tmux？有几个处理这个问题的技巧。
第一个是更改前缀。
例如，我在本地机器上将前缀从“Ctrl+B”更改为“Ctrl+A”，然后在远程机器上仍为“Ctrl+B”。
这样我就可以在本地tmux上执行操作，使用“Ctrl+A”，在远程tmux上执行操作，使用“Ctrl+B”。
另一件事是你可以有不同的配置文件，所以我可以做类似于这样的事情......哦，因为我没有自己的ssh配置文件。
但如果你......嗯，我可以SSH“VM”。
这里，你看到的两个条之间的差异，例如，是因为tmux配置不同。
就像你将在练习中看到的那样，tmux配置在tmux.conf文件中，你可以在tmux.conf中做很多事情，比如根据你所在的主机更改颜色，以便快速获得视觉反馈，或者如果你有一个嵌套会话。
此外，如果你在同一台主机上，并且尝试在一个tmux会话中使用tmux，tmux会阻止你这样做，以避免出现问题。
如果有关我们涵盖的所有主题的其他问题，请随意问。
对于那个问题的另一个答案是，如果你将前缀键击两次，它会将其发送一次到底层shell。
因此，本地绑定是“Ctrl+A”，远程绑定是“Ctrl+A”，你可以键入“Ctrl+A”、“Ctrl+A”，然后键入“D”，例如从远程分离。
我想今天的课程到此结束了，有很多与所有这些主要主题相关的练习，我们今天也将进行办公时间。
所以随时来问我们任何问题。
