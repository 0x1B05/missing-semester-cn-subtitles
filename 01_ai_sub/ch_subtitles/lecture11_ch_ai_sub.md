我想我们应该先介绍一下这个问题，这是一个自由问答的讲座，你们两个可以问问题，但也包括在家里的所有人。
我们事先收到了一些问题，但你们也可以在讲座期间提出其他问题。
对于在场的两位，你们可以举手提问，也可以匿名地在论坛上提交问题，这取决于你们自己。
无论如何，我们将会回答一些已经被问到的问题，尽可能给出有用的答案，虽然我们没有做过任何准备。
好的，这就是我们的计划。
我们将按照问题的受欢迎程度来回答。
开始吧！第一个问题是：有没有关于学习操作系统相关主题，比如进程、虚拟内存、中断、内存管理等的建议？我认为这是一个有趣的问题，因为这些都是非常低层的概念，除非你必须在某些情况下处理这些问题，否则通常并不重要，对吧？比如你正在编写非常低层的代码，比如实现内核或者想要对Linux内核进行修改。
否则，你很少需要自己处理这些问题，尤其是像虚拟内存和中断这样的问题。
进程是一个更一般的概念，我们在这门课程中也稍微谈到了一些，并且工具如htop、pgrep、kill、信号等也是相关的。

关于学习这个问题，也许最好的方法之一是尝试参加这个主题的入门课程。
例如，麻省理工学院有一个称为6.828的课程，你可以根据给定的代码构建和开发自己的操作系统，所有实验和课程资源都是公开的。
通过亲自动手去实践，这是学习的好方法。
此外，还有各种在线教程，可以指导你从零开始编写内核。
这不一定是一个非常精细的内核，不能运行任何真正的软件，但它可以教你基本知识。
你可以搜索如何使用你选择的编程语言编写内核，你可能找不到可以在Python中编写内核的教程，但是在C、C++、Rust等语言中，有许多这样的教程。
关于操作系统的另一个注释，正如Jon提到的，麻省理工学院有一个6.828的课程，但如果你想了解更高层次的概述，不一定是关于编程或操作系统，而是学习概念，另一个好的资源是Andy Tannenbaum写的《现代操作系统》一书。
实际上还有一本名为《FreeBSD操作系统》的书也非常好。
它并没有涉及Linux，而是介绍了FreeBSD，BSD内核的组织和文档可能比Linux更好，因此它可能是比尝试理解Linux更温和的介绍一些主题的方式。

下一个问题，你会优先学习哪些工具？也许我们都可以分享一下我们的看法？好的。
首先优先学习哪些工具？我认为熟练掌握编辑器可以在各个方面为你提供帮助，例如高效地编辑文件，这基本上就是你会花费大部分时间做的事情。
而且总体来说，尽量使用键盘而不是鼠标，这意味着你可以花更多时间做有用的事情，而不是浪费时间在移动上。
我认为这应该是我的首要任务，所以我会说，优先学习哪些工具取决于你正在做什么。
我认为核心思想是要尝试找到你正在反复执行的任务类型，例如，如果你正在执行某种机器学习工作量，并且发现自己经常使用我们昨天介绍的Jupyter笔记本，那么使用鼠标可能不是最好的选择，你需要熟悉键盘快捷键。
几乎任何事情都是如此，你最终会发现有一些重复的任务，你正在运行一台计算机，而只是试图找出，“哦，可能有更好的方法来做这件事”，无论是终端还是编辑器。
学习使用我们涉及的一些主题可能非常有趣，但如果它们在日常工作中不是非常有用，那么可能不值得优先考虑它们。

在我看来，本课程所涵盖的主题中，我认为最有用的两个是版本控制和文本编辑器。
我认为它们有点不同，因为文本编辑器非常有用，但在我们开始使用Vim和它所有的花式键盘快捷键之前，你可能已经在使用其他文本编辑器，并且可以很好地编辑文本，只是可能有点低效。
而我认为版本控制是另一个非常有用的技能，如果你不真正了解该工具，它实际上可能会导致一些问题，例如数据丢失或与人无法有效合作。
因此，我认为版本控制是值得好好学习的第一件事。
是的，我同意这一点。
我认为学习像Git这样的工具将在以后为你节省很多心酸。
此外，它还有助于你与他人合作。
安尼什在上一堂课中提到了GitHub，学会使用这个工具可以在参与其他人正在进行的大型软件项目时帮助你。
这是一项非常宝贵的技能。

关于"何时使用Python, 何时使用Bash脚本或其他编程语言"这个问题,这很难回答,因为正如Jose之前所说的,这取决于你要做什么.对于我来说,特别是对于Bash脚本来说,它是用于自动运行一堆命令的.你不想在Bash脚本中编写其他的业务逻辑.比如说,'我想按这个顺序运行这些命令...也许带一些参数?' 但是,即使这样,一旦你开始传递参数,你也不确定是否需要一个Bash脚本.同样的,一旦你开始进行任何类型的文本处理或配置,就要使用比Bash更专业的编程语言. Bash只适用于短小的单次脚本或在终端、shell上有一个非常明确的使用案例. 对于稍微具体的指导方针,可以说,"如果代码行数不到一百行,可以编写一个Bash脚本",但一旦超过这个点,Bash就变得不灵活,并且可能值得转向一个更为专业的编程语言,比如Python.此外,我想补充的是,有时候我发现自己在Python中编写脚本,因为如果我已经在Python中解决了某些子问题,我发现使用之前在Python中找到的解决方案比尝试重复使用Bash代码更容易。

同样的，很多人写了像Python库或Ruby库这样的东西来完成很多这样的任务，这种方式是非常好的。
而在Bash中，很难进行代码重用。
事实上，如果你在某种语言中找到一个帮助你完成任务的库，通常应该使用该语言来处理这项任务。
在Bash中，没有库，只有计算机上的程序。
Bash很难写对。
对于你现在要解决的特定用例，很容易写对，但是，例如“如果一个文件名中有一个空格怎么办？”这种问题在Bash脚本中会导致很多错误和问题。
如果使用真正的编程语言，那么这些问题就会消失。
是的！检查过了。
接下来，我们来回答一个问题，那就是“源脚本”和“执行脚本”的区别是什么？这个问题我们在一段时间前的办公时间也曾提到过，就是“它们不是一样的吗？它们不都只是运行Bash脚本吗？”的确，这两者都会执行脚本中的代码行。

它们之间的区别在于，"source"脚本是告诉你当前的Bash脚本会话来执行该程序，而另一个是"启动一个新的Bash实例，并在那里运行程序。
"这对于像......想象一下，"script.sh"试图更改目录的情况是很重要的。
如果你像第二个调用"./script.sh"那样运行脚本，那么新的进程将更改目录。
但是，当脚本退出并返回到你的shell时，你的shell仍然保持在原地。
然而，如果你在脚本中执行"cd"并"source"它，你当前的Bash实例就会运行它，所以它会"cd"到你所在的地方。
这也是为什么，如果你定义函数，例如，你可能想在你的shell会话中执行它们，你需要"source"脚本而不是运行它，因为如果你运行它，那个函数将被定义在启动的Bash进程中，但它将不会在你当前的shell中被定义。
我认为这是它们之间最大的两个区别。

下一个问题是... "各种软件包和工具存储的位置在哪里，引用它们的方式是怎样的？ /bin或/lib到底是什么？" 正如我们在第一次讲座中提到的那样，有一个名为PATH的环境变量，它是一个以分号分隔的字符串，其中包含您的Shell查找二进制文件的所有位置。
如果您只是执行"echo $PATH"，您将获得此列表；所有这些位置将按顺序进行查询。
它将遍历所有位置，并且实际上——我们已经...我们介绍过哪些？+ 是的。
因此，如果您运行"which"和一个特定的命令，Shell实际上会告诉您它在哪里找到此（命令）。
除此之外，有一些公约，许多程序将安装其二进制文件，例如/usr/bin（或者至少包含符号链接）在/usr/bin中，以便您可以找到它们。
还有一个/usr/local/bin。
有一些特殊的目录，例如，/usr/sbin仅用于sudo用户，一些这些公约在不同的发行版之间略有不同。
我知道有些发行版例如在/opt下安装用户库。

是的，我认为可以再详细介绍一下 /bin，Anish 可以说一下其他的文件夹。
关于 /bin，有一些惯例，通常 /bin 用于系统基本工具，/usr/bin 用于用户程序，/usr/local/bin 用于用户编译的程序，所以那些你想让用户运行的程序都应该放在 /usr/bin 中，用户自己编译并安装在系统中的程序通常会放在 /usr/local/bin，但是这也因机器和发行版而异。
例如，在 Arch Linux 上，/bin 是指向 /usr/bin 的符号链接。
它们是一样的，正如 Jose 提到的，还有 /sbin 专门为需要以 root 权限运行的程序准备，这也因发行版而异，有些发行版甚至没有这个目录，在许多系统上，/usr/local/bin 可能不在你的 PATH 中，甚至不存在于你的系统中。

另一方面，在BSD中，/usr/local/bin通常使用得更加频繁。
我们到目前为止讨论的都是Linux中文件和文件夹的组织方式。
Linux、BSD与macOS等平台之间存在一些差异。
如果你想要确切地知道某个位置的用途，可以查阅相关资料。
但需要记住的一些一般规律是：带有/bin的文件夹中包含可执行的二进制程序，带有/lib的文件夹中包含库文件，可供程序链接使用。
还有一些其他的有用信息，例如，许多系统都有一个/etc文件夹，其中包含配置文件；/home文件夹下的每个子文件夹都是一个用户的主文件夹，在Linux上，我的用户名或者Anish的用户名将与/home/anish这个主文件夹相对应。
还有一些其他的文件夹，例如/tmp通常是一个临时目录，在重启时会被清空（但并非总是如此，需要在系统上检查）；/var通常保存着随时间而变化的文件，通常会是像软件包管理器的锁文件、日志文件以及用于跟踪进程ID的文件；/dev文件夹中包含着系统的设备，通常是对应于系统设备的特殊文件。
我们之前提到过/sys，Anish提到了/etc。
/opt是常见的第三方软件文件夹，一般用于公司将其软件移植到Linux上，但它们实际上并不理解在Linux上运行软件的情况，因此它们只是将所有东西放在一个目录中，并将其安装到/opt中。
我想这些是我能想到的所有文件夹了。
我们会在本次讲座后制作的讲座笔记中列出这些文件夹。

下一个问题：我应该使用 apt-get 安装 Python 包还是使用 pip 安装？这是一个很好的问题，我认为从更高的层面来看，这个问题正在询问我是否应该使用系统的软件包管理器来安装东西，还是应该使用一些其他的软件包管理器？比如在这种情况下，更特定于某个语言的软件包管理器。
答案也有点因情况而异。
有时使用系统的软件包管理器来管理东西很方便，因为所有的东西都可以在一个地方安装和升级，但我认为通常系统库中提供的东西，比如通过 apt-get 或类似工具获得的东西，可能会比更特定于某个语言的库稍微过时一些。
例如，我使用的很多 Python 包，我真的想要最新的版本，因此我使用 pip 来安装它们。
进一步说，有时候系统软件包可能需要一些你可能没有意识到的其他依赖项，而且对于某些系统，至少对于像 Alpine Linux 这样的系统，它们没有很多 Python 包的 wheel，所以编译它们会花费更长的时间。
它们需要从头开始编译，所以需要更多的空间。
而如果你只是使用 pip，pip 有许多不同平台的二进制文件，那可能会更好用。

另外你也应该知道，pip 在不同的电脑上可能不会做完全相同的事情。
比如，如果你在运行 x86 或 x86_64 的笔记本电脑或台式机上，你可能有二进制文件，但如果你在运行 Raspberry Pi 或其他嵌入式设备上，这些设备运行在不同的硬件架构上，你可能没有二进制文件。
我认为这也值得考虑。
在这种情况下，使用系统包可能是值得的，因为它们需要的时间比从头开始编译整个 Python 安装要短得多。
除此之外，我想不出任何例外情况，我会真正使用系统包而不是 Python 提供的包。
另外要记住的一件事是，有时你的电脑上会有多个程序，你可能正在开发多个程序，但由于某种原因，并不总是使用最新版本的东西来构建所有程序，有时它们会滞后一些。
当你在整个系统上安装某些东西时，你只能......这取决于你的具体系统，但通常只有一个版本。
pip 可以让你做的，尤其是与像 python 的 virtualenv 这样的东西结合使用时，其他语言也有类似的概念，你可以说我想在它自己的子目录中编译这个包的依赖项，它所需的所有版本都将在那里构建，你可以为不同的项目单独做这个，所以它们有不同的依赖项或相同的依赖项，但不同版本仍然被分开保留。
这是使用系统包难以实现的一件事。

下一个问题是：什么是最容易和最好的性能分析工具，用于优化我的代码？这是一个我们可以讨论很长时间的话题。
最容易和最好的方法是使用时间打印输出。
就像，我不是在开玩笑，很多时候最简单的方法就在你的代码里。
在代码的顶部，你确定当前时间，然后在你的程序中进行二分查找，添加一个打印语句，打印自程序启动以来经过了多长时间，然后一直重复这样的步骤，直到找到花费时间最长的代码段。
然后进入那个函数，再次执行同样的操作，一直重复，直到找到大概的时间花费位置。
这并不是百分之百可靠的，但它非常简单，可以很快地为你提供有用的信息。
如果你需要更高级的信息，Valgrind有一个叫做cache-grind或call grind的工具。
这个工具可以让你运行你的程序并测量所有的调用堆栈，比如哪个函数调用了哪个函数，最终你会得到一个非常漂亮的程序源代码注释，基本上显示了每行花费的时间。
这会让你的程序变得慢十倍甚至更多，而且它并不支持线程，但是如果你能使用它，它非常有用。
如果你不能使用这些工具，那么像perf或其他语言的类似工具通常会提供一些采样分析类的有用数据，但是会有很多数据，它们会有一些偏见，并且通常会突出显示一些问题，有时很难提取有意义的信息来回答“我应该改变什么”。
相比之下，使用打印输出的方法可以很快地让你知道哪些代码部分是糟糕的或缓慢的。
火焰图也很好用，可以用来可视化一些信息。
是的，我只有一件事要补充，通常编程语言都有专门的工具用于分析性能，所以要找出适合你的语言的正确工具，比如如果你在Web浏览器中使用JavaScript，Web浏览器有一个非常好用的分析工具，你应该使用它。
或者如果你正在使用Go，例如，Go有一个内置的性能分析工具，非常好用，你应该使用它。
最后要补充的是，有时你可能会发现自己正在进行这种时间上的二分查找，你找到的时间可能是由于你正在等待网络或文件等原因导致的，如果是这种情况，你需要确保所花费的时间是最小的，比如如果我想要写一个1GB的文件或读取一个1GB的文件并将其存入内存，你需要检查实际的时间是否是你实际必须等待的最小时间。
如果时间是十倍长，你应该尝试使用我们在调试和性能分析部分中介绍的其他工具，以查看为什么你没有利用所有的资源，因为这可能是发生的很多事情，例如在我的机器学习工作负载研究中，大部分时间都是用来加载数据的，你必须确保加载数据的时间实际上是你想要的最短时间。
并且在此基础上，实际上有专门的工具可以进行等待时间分析。
很多时候，当你在等待某些东西时，真正发生的事情是你正在发出系统调用，这个系统调用需要一些时间来响应。

如果你需要进行大量的写入或读取操作，或者需要进行多个此类操作，那么一件非常方便的事情是尝试从内核中获取关于程序花费时间的信息。
现在有一个相对较新的可用工具，叫做 BPF 或 eBPF，它本质上是内核跟踪工具，可以进行一些非常酷的操作，包括跟踪用户程序。
虽然它可能有点棘手，但是如果你需要进行这种低级性能调试，我建议你看看一个叫做 BPF trace 的工具。
但是对于这种工作来说它真的非常好用，可以得到一些关于特定系统调用花费时间的直方图等信息。
这是一个非常好的工具。
你使用哪些浏览器插件？我尽量少使用插件，因为我不喜欢我的浏览器中有太多东西，但是有一些是比较常用的。
第一个是 uBlock Origin。
uBlock Origin 是众多广告拦截器之一，但它不仅仅是一个广告拦截器。
它是一个网络过滤工具，可以让你做更多的事情，不仅仅是拦截广告。
它还可以像阻止某些域名的连接、阻止某些类型的资源的连接。
我把它设置成了高级模式，基本上可以禁用所有的网络请求。
但不仅仅是网络请求，我也禁用了每个页面上的所有内嵌脚本、所有第三方图像和资源，然后你可以为每个页面创建一个白名单，它会提供关于如何提高浏览安全性的非常低级别的工具。
但是你也可以将其设置为非高级模式，然后它会做很多与普通广告拦截器类似的事情，如果你在寻找广告拦截器，它可能是你想要使用的，并且它适用于几乎所有的浏览器。
我认为这是我的首选。

我觉得我最常使用的插件可能是一个叫做Stylus的插件。
它让你修改网页的CSS或样式表。
这非常方便，因为有时你在浏览一个网站时，想要隐藏一些你不关心的部分，比如广告或者某个侧边栏。
问题是，这些东西最终都会在你的浏览器中显示，而你可以控制哪些代码执行。
就像Jon所说的那样，你可以无限制地自定义它，我已经为很多网页设定了隐藏这一部分，或者为它们尝试制作暗黑模式，你几乎可以为每个网站更改颜色。
实际上，还有一个在线仓库，里面有很多人为网站编写的样式表。
所以，可能有人已经为GitHub制作了暗黑版，这使得浏览更加愉悦。
 除此之外，还有一个并不很花哨，但我发现非常有用的插件，它可以截取整个网站的屏幕截图。
它会自动滚动并制作出整个网站的复合图像，这对于打印一个看起来很糟糕的网站非常有用。
（它内置在Firefox中） 哦，有趣！既然你提到了Firefox内置的插件，还有一个我非常喜欢的是Firefox的多账户容器。
（哦，是的，它非常棒！）
默认情况下，许多网页浏览器，比如Chrome，有一个叫做“会话”的概念，你在其中保存了所有的cookies，它们在不同的网站之间共享，也就是说，你打开新标签页时，除非你进入无痕模式，否则你使用的都是同一个档案。
而这个档案是适用于所有网站的，是通过一款浏览器插件还是内置功能实现的呢？（这是混合的，很复杂。
）我想你实际上需要说出你想要安装它或启用它，而这个名字叫做“多帐户容器”，它可以让你告诉Firefox要有单独的隔离会话。
比如说，你想对每次访问Google或每次访问Amazon建立独立的会话，这样你就可以在浏览器级别上确保它们之间没有信息共享。
这比打开无痕窗口更方便，因为后者每次都会清除所有东西。
（提醒一下，Stylus与Stylish之间的区别。
）哦，是啊，我忘了这一点。
有一件重要的事情是浏览器扩展程序可以加载CSS样式表，它叫做Stylus，不同于旧版的Stylish，因为Stylish曾经被某个不怎么靠谱的公司收购，他们不仅使用这个功能，还读取了你的整个浏览器历史记录并将其发送回他们的服务器，以便进行数据挖掘。
于是人们就开发了这个开源的替代品，叫做Stylus，这是我们推荐的。
话虽如此，我认为两个工具的样式库是相同的，但我需要再次确认一下。

"Anish，你有使用任何浏览器插件吗？"

"是的，我也有一些浏览器插件的推荐。
我也使用uBlock Origin和Stylus，但我还要推荐一款密码管理器的集成插件。
我们在安全讲座的讲义中有涉及到这个主题，但我们没有详细讨论。
基本上，密码管理器在处理在线账户时可以大大提高您的安全性，与浏览器集成可以节省您很多时间。
您可以打开一个网站，然后它可以自动填充您的登录信息，而不是您必须在独立的程序之间来回复制和粘贴。
而且，这种集成可以避免某些攻击，否则如果您进行手动复制和粘贴，则可能会受到攻击，例如钓鱼攻击。
因此，如果您找到一个看起来非常类似于Facebook的网站，并使用Facebook的登录凭据进行登录，然后将正确的凭据复制粘贴到这个奇怪的网站，那么现在它就有了您的密码。
但如果您有浏览器集成，则扩展程序可以自动检查，例如：我是在F A C E B O O K.com上还是在其他看起来相似的域名上，并且如果是错误的域名，则不会输入登录信息。
所以，密码管理的浏览器插件很好用。 "

"是的，我同意。 "
下一个问题是，还有哪些有用的数据整理工具？昨天的讲座中，我提到了curl。
Curl是一个非常好用的工具，可以直接在终端中进行网页请求并将其转储。
您还可以使用它来上传文件，非常方便。
在那个讲座的练习中，我们还谈到了JQ和pup，这是命令行工具，可以让您在JSON和HTML文档上编写查询，非常有用。
其他的数据整理工具？啊，Perl。
Perl编程语言通常被称为只能写不能读的编程语言，因为即使您编写它，也无法阅读它。
但是，它非常擅长于处理纯文本，没有什么能超越它。
因此，也许值得学习一些非常基础的Perl知识，以编写一些脚本。
这通常比编写一些grep、awk和sed的组合要容易得多，而且直接编写比例如Python的代码也要快得多。
但是除此之外，其他的数据整理工具呢？我脑海中没有想到。
实际上，"column -t"就非常好用。
如果您将任何以空格为分隔符的输入导入"column -t"，它会使列的所有空格对齐，从而使您得到漂亮的对齐列。
这是一种非常实用的工具，还有"head"和"tail"，但我们已经谈论过这些了。
我认为还有几个我经常使用的工具需要补充：一个是Vim。
Vim在数据整理中非常有用。
有时候您可能会发现要完成的操作很难用管道运算符来表达。
但是，如果您可以打开文件，只需记录一些快速的Vim宏来执行所需的操作，那么这可能会更加容易。
这是其中一个工具，另一个是如果您正在处理表格数据，并且想要执行更复杂的操作，例如按一列排序，然后分组并计算某种统计数据，我认为这种工作负载的大部分内容都可以使用Python和pandas来完成，因为它专门为此而建立。
我还发现自己经常使用的一个相当不错的功能是它可以导出许多不同的格式。
因此，这种中间状态具有自己的pandas数据框架对象，但它可以导出到HTML、LaTeX等许多不同的表格格式。
如果你的最终产品是某种摘要表格，那么我认为Pandas是一个非常好的选择。
我也同意使用Vim和Python。
我认为这两个工具是我最常用的数据处理工具之一。
关于Vim，去年我们在系列课程的讲义中进行了演示，但是我们没有在课堂上介绍它。
我们进行了一个演示，将一个XML文件转换为同一数据的JSON版本，只使用了Vim宏。
我认为这实际上是我实践中的处理方式。
我不想去找一个工具来做这个转换。
将其编码成Vim宏实际上很简单，然后我就可以这样做。
此外，特别是在像Jupyter笔记本这样的交互式工具中，Python是进行数据处理的一种非常好的方式。
我还想提到第三个工具，我不记得我们是否在数据处理讲座或其他地方介绍过，那就是一个叫做pandoc的工具，它可以在不同的文本文档格式之间进行转换。
因此，你可以将纯文本转换为HTML或HTML转换为Markdown或LaTeX转换为HTML或许多其他格式。
它实际上支持大量的输入格式和输出格式。
我想最后还有一个，我在数据处理讲座中简要提到过，那就是R编程语言。
它是一个非常糟糕的（我认为是非常糟糕的）编程语言，我不会在数据处理流水线的中间使用它。
但是，在最后阶段，为了生成漂亮的图表和统计数据，R是非常好的。

因为 R 是为统计和绘图而建的，所以有一个叫做 ggplot 的库，非常棒。
ggplot2 从技术上讲很棒。
它可以产生非常好的可视化效果，让你可以很容易地做出像数据集具有多个方面这样的东西，不仅仅是 X 和 Y，还有 Z 和其他变量，然后你想一次性将所有这些参数分组的吞吐量绘制成可视化效果。
R 可以让你非常容易地做到这一点，我还没有看到其他工具能像 R 那样容易地做到这一点。
下一个问题，Docker 和虚拟机的区别是什么？最容易解释的方法是什么？所以，Docker 开始了一些叫做容器的东西，Docker 并不是唯一启动容器的程序。
还有许多其他的程序，通常它们依赖于底层内核的某些特性。
在 Docker 的情况下，它们使用了一些叫做 LXC 的东西，这是 Linux 容器。
基本原理是，如果你想启动一个看起来像虚拟机的东西，它运行的操作系统与你已经在计算机上运行的操作系统大致相同，那么你实际上不需要运行另一个内核实例。
实际上，另一个虚拟机可以共享一个内核，你可以使用内核内置的隔离机制来启动一个程序，让它认为它在它的硬件上运行，但实际上，它是在共享内核。
这意味着容器通常可以比完整虚拟机使用更低的开销运行。
但是你应该记住，它的隔离性也比较弱，因为你在两个容器之间共享内核。
如果你启动了一个虚拟机，唯一共享的是硬件和某种程度上的 hypervisor，而 Docker 容器则共享整个内核，这是一个不同的威胁模型，你可能需要考虑这一点。

正如Jon指出的那样，要使用容器（例如Docker），你需要底层操作系统与运行在容器顶部的程序所期望的操作系统大致相同。
如果你使用的是macOS，那么你需要在虚拟机中运行Linux，然后在Linux上运行Docker。
因此，如果你使用容器来提高性能，那么你就是在为性能而牺牲隔离性。
如果你在macOS上运行，那么可能无法达到预期的效果。
最后需要注意的是，Docker和容器有一个细微的区别。
使用容器需要注意的问题之一是，容器更类似于虚拟机，因为它们会持久化存储所有内容，而默认情况下，Docker并不会这样做。
Docker的主要想法是“我想运行一些软件，我获得了镜像，然后它运行起来了”，如果你想要与主机系统链接的任何持久性存储，你必须手动指定，而虚拟机则使用提供的虚拟磁盘。

下一个问题是，每个操作系统的优点是什么，我们如何在它们之间进行选择？例如，选择最适合我们需求的Linux发行版。
我想说的是，对于很多任务来说，你所运行的具体的Linux发行版并不是那么重要的。
重要的是了解不同类型或者分组的发行版。
例如，有一些发行版有着很频繁的更新，但是它们更容易出问题。
例如，Arch Linux通过滚动更新的方式来推送更新，可能会出现一些问题，但是他们习惯于事情是这样的。
但是，如果你有一些非常重要的Web服务器来托管你所有的业务分析，你肯定希望它更新的方式更加稳定。
这就是为什么你会看到像Debian这样的发行版在他们推送更新时更加保守，或者比如Ubuntu区分了长期支持版本，它们只每两年更新一次，还有更加定期的更新，每年会有两次。
所以，了解到这种差别很重要。
此外，一些发行版提供二进制文件的方式以及仓库的方式也有所不同。
例如，我认为很多Red Hat Linux不想在官方仓库中提供非自由驱动程序，但Ubuntu则对其中的一些驱动程序没有问题。
除此之外，我认为大多数Linux发行版的核心是共享的，在共同点上有很多学习的内容。
所以，你不必担心具体的细节。

继续保持这个课程有些主观的主题，我想说如果你是第一次使用Linux，选择类似Ubuntu或Debian这样的东西。
所以，Ubuntu也是基于Debian的发行版，但可能更加友好。
Debian则更加简约。
例如，我在所有的服务器上使用Debian，我在运行Linux的桌面计算机上使用Debian桌面。
如果你想尝试学习更多的东西，并且想要一种在稳定性和软件更加更新之间做出权衡的发行版，也许你可以考虑像Arch Linux、Gentoo或Slackware这样的东西。
噢，我想说，如果你正在安装Linux并想要完成工作，Debian是一个很好的选择。
是的，我同意这个观点。
另一个观察是，你可以安装BSD。
BSD从过去到现在发生了很大的变化。
仍然有一些软件在BSD上无法使用，但它提供了一个非常完善的文档体验。
与Linux不同的是，在安装BSD时，你会得到一个完整的操作系统。
因此，许多程序由同一个团队维护，他们同时升级，这与Linux世界的工作方式有些不同。
这确实意味着事情通常会慢一点。
我不会将其用于游戏等方面，因为驱动程序支持一般。
但这是一个有趣的环境值得一看。

接下来，对于像 Mac OS 和 Windows 这样的东西，如果你是一个程序员，我不知道为什么你会使用 Windows，除非你正在构建 Windows 的东西，或者你想玩游戏之类的东西，但在这种情况下，也许尝试双重启动，即使这也很麻烦。
Mac OS 是两者之间的一个很好的中间点，你可以得到一个相对不错的系统。
但你仍然可以在某种程度上访问一些较低级别的内容。
而且双重启动 Mac OS 和 Windows 也非常容易。
但 Mac OS 和 Linux，以及 Linux 和 Windows 之间就不是这种情况了。


好的，对于其余的问题，这些问题都没有人点赞，所以我们可以在课程的最后五分钟内快速回答它们。
下一个问题是 Vim 和 Emacs 呢？Vim！很容易的答案，但更严肃的回答是，我认为我们三个人都将 vim 作为我们的主要编辑器。
我在某些需要使用 Emacs 的研究特定工作中使用 Emacs，但在更高的层面上，两个编辑器都有有趣的思想。
如果你有时间的话，值得探索一下两者，看哪一个更适合你。
另外，你可以使用 Emacs 并在 vim 模拟模式下运行它。
我实际上认识很多这样做的人，这样他们就可以访问一些很酷的 Emacs 功能和一些酷的哲学思想。
就像 Emacs 可以通过 Lisp 进行编程一样，这很酷。
比 vimscript 好多了，但人们喜欢 vim 的模态编辑，所以有一个 Emacs 插件叫做 evil 模式，它在 Emacs 中提供了 vim 模态编辑。
所以这不一定是一个二元的选择，如果你愿意，可以将两个工具结合起来。
如果你有时间，值得探索一下两者。

下一个问题：机器学习应用有什么技巧或诀窍吗？我认为，了解这些工具的使用方法，尤其是数据处理方面的许多shell工具非常重要，因为作为机器学习研究人员，你似乎正在尝试不同的方法。
但我认为做到这一点的一个核心方面，就像许多科学工作一样，是能够以合理的方式获得可重复的结果并记录下来。
例如，与其想出如何命名你的文件夹以理解实验，也许直接使用一个描述整个实验的JSON文件更值得，我通常会在其中记录所有的参数，然后我可以使用我们已经介绍过的工具，快速查询使用特定数据集的实验。
除此之外，另一方面，如果你正在运行训练机器学习应用的任务，而你还没有使用类似于大学或公司提供的某种集群，而是像许多实验室一样手动ssh连接，这可能是因为这是一种简单的方式。
那么自动化这项工作是很值得的，因为手动进行这些操作可能看起来很不起眼，但却需要大量的时间和精力。

还有其他的vim技巧吗？我有一个建议。
在vim讲座中，我们尽量不会向您介绍太多不同的vim插件，因为我们不希望那堂课让您感到不知所措。
但我认为探索vim插件是值得的，因为有很多非常酷的插件可供选择。
一个资源可以使用不同的讲师点文件。
像我们大多数人一样，我使用了大约两打vim插件，我发现其中很多都很有用，而且我每天都在使用它们。
我们所有人都使用略微不同的子集。
因此，去看看我们使用了什么或查看我们链接到的其他资源，您可能会发现一些有用的东西。
另外，我认为我们在讲座中没有详细介绍过的是熟悉leader键，这是一种特殊的键，很多程序，特别是插件，都会链接到它，而且vim有很多常见操作的简短方式，但是你可以想出更快的方法来完成它们。
例如，我知道您可以使用分号WQ来保存和退出，或者可以使用大写ZZ，但我实际上只是使用leader（对我来说是空格），然后W。
我已经为我经常执行的很多常见操作做到了这一点。
因为在极其常见的操作中节省一个按键只是每月节省数千个按键。

是的，稍微展开一下什么是leader key，所以在vim中，您可以绑定一些键。
我可以做像Ctrl J这样的事情，就像按住一个键然后按另一个键。
我可以将其绑定到某个动作，或者我可以将单个击键绑定到某个动作。
leader key让您做的是绑定。
因此，您可以分配任何键作为leader key，然后将leader加上其他某个键分配给某个操作。
例如，像Jose的leader key是空格，他们可以将空格与释放空格后的某个其他键组合在一起，绑定到任意vim命令。
它只是给您另一种绑定整套键组合的方法。
Leader key加上键盘上的任何键可以实现某种功能。
我忘记我们是否在vim uh中涵盖了宏，但是学习vim宏是值得的。
它们并不复杂，但知道它们的存在以及如何使用它们将节省您很多时间。
另一个是称为标记的东西。
因此，在vim中，您可以按m，然后按键盘上的任何字母，以在该文件中打标记，然后可以按相同字母的单引号跳回同一位置。
例如，如果您在两个代码不同的部分之间来回移动，这将非常有用。
您可以将一个标记为A，另一个标记为B，然后使用tick A和tick B在它们之间跳转。
还有Ctrl + O，它跳转到文件中您上次在哪个位置，无论您因何而动。
例如，如果我在某行，然后跳转到B，然后跳转到A，Ctrl + O将带我回到B，然后回到我最初的位置。
如果您正在执行搜索，则可以使用Ctrl + O从搜索的位置移动到文件的其他部分。
Ctrl + O还可用于在不同文件之间移动，因此如果我从一个文件转到另一个文件的某个位置，然后再返回第一个文件的某个位置，Ctrl + O将通过该堆栈将我移动回去。
Ctrl + I可以向前移动该堆栈。
因此，它并不是一旦弹出就永远消失。

"colon earlier" 这个命令真的很方便。
使用"colon earlier"可以获取文件的早期版本，这是基于时间而不是基于操作的。
例如，如果你按了一些撤销和重做操作并进行了一些更改，"earlier"将获取文件的真正早期版本并将其还原到缓冲区。
有时这很有用，如果你撤销了一些更改并重新写了一些内容，然后意识到你实际上想要撤销之前的版本，"earlier"可以让你这样做。
另外，还有一个叫做"undo tree"的插件，它允许你浏览vim保留的撤销历史记录的完整树形结构。
因为它不仅仅保留线性历史记录，而是保留了完整的树形结构。
探索这个功能在某些情况下可能会帮助你避免重新输入过去输入过的东西，或者你已经忘记了曾经使用的工作了的东西。
还有一个我想要提到的就是，我们提到过vim中有动词和名词，对于你的动词比如删除或复制，你还有名词，比如下一个字符或百分号来交换括号等等。
搜索命令是一个名词，所以你可以做一些类似D/某个字符串的操作，它会删除到下一个匹配的字符串。
这个功能非常有用，我经常使用。
还有一个我在日常使用中发现非常有价值的撤销功能的一个很好的补充是，vim内置的一个功能，就是你可以指定一个撤销目录。
如果你指定了一个撤销目录，默认情况下，如果你没有启用这个功能，每次进入一个文件时，你的撤销历史记录都是干净的。
当你在文件中进行修改并撤消操作时，你会创建一个历史记录，但一旦你退出文件，它就会丢失。
对不起，一旦你退出vim，它就会丢失。
然而，如果你设置了一个undodir，vim将持久化所有这些更改到这个目录中，所以无论你进入和离开多少次，历史记录都将被保存，并且这非常有帮助，因为它可以帮助你保持文件的更新。
如果你经常修改某些文件，你可以跟踪它们的变化。
但有时候也很有帮助，例如，如果你修改了你的bashrc，然后五天后发现某些东西坏了，然后你又使用vim。
如果你没有版本控制，你可以查看撤消记录，这就是实际发生的事情。
最后，值得熟悉vim使用的不同特殊寄存器，例如，如果你想复制/粘贴一个东西，它会进入一个特定的寄存器，如果你想使用类似于操作系统剪贴板的a OS a复制，你应该从不同的寄存器中复制或粘贴，寄存器有很多种。
我认为你应该探索一下，有很多关于寄存器的知识需要了解。
下一个问题是关于双因素身份验证的，出于时间考虑，我将简单回答一下。
对于任何安全敏感的事情，使用双因素身份验证是值得的。

我用双因素认证来保护我的GitHub账号和邮箱等安全敏感信息。
有很多不同类型的双因素认证，从基于短信的双因素认证，当你尝试登录时，会向你发送一个特殊的数字，你必须输入这个数字，到像通用双因素认证这样的工具，比如那些需要插入Yubikey的东西，每次登录都需要轻触。
并不是所有的双因素认证都是一样的，你真的想使用像U2F这样的认证，而不是基于短信的认证。
有些基于一次性密码的认证，你需要输入这个密码，我们没时间深入讨论为什么有些方法比其他方法更好，但在高层次上使用U2F。
互联网上有很多解释为什么其他方法不是一个好主意。
 现在网页浏览器之间的差异越来越少了。
几乎所有的网页浏览器都是Chrome，或者是使用与Chrome相同的浏览器引擎的浏览器。
这有点让人难过，但我认为如果您想要一个更可定制或不想被Google绑架的安全浏览器，Chrome是一个很好的选择，那么使用Firefox，不要使用Safari，它是Chrome的更糟糕的版本。
新的Internet Explorer Edge也很不错，也使用与Chrome相同的浏览器引擎，这可能是可以接受的，但如果可以的话还是要避免它，因为它有一些像遗留模式的东西，你不想处理。
还有一个很酷的新浏览器叫做flow，你目前不能用它做什么有用的事情，但他们正在编写自己的浏览器引擎，这真的很棒。
Firefox也有一个叫做Servo的项目，他们正在使用Rust实现他们的浏览器引擎，以便使其超级并发。
他们已经开始从该版本中获取模块，并将它们移植到gecko中，gecko是Firefox的主要浏览器引擎，以便在那里获得速度提升，这是一个很酷的东西，你可以关注一下。
 这就是所有的问题，嘿，我们做到了。
很好，我想感谢你参加了这门缺失的学期课程，我们明年再见。
