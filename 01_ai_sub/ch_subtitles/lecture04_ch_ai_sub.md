好的，欢迎来到今天的讲座，我们将会讲解数据整理。
"数据整理"这个词组可能听起来有点奇怪，但它的基本想法是，你有一个格式的数据，而你想要它在另一种不同的格式中，这种情况时常发生。
我不仅指转换图像，还可能是你有一个文本文件或日志文件，但你实际上希望以某种其他格式获得这些数据，例如你想要一个图形或对数据进行统计。
任何从一段数据到另一种表示形式的过程都可以被称为"数据整理"。
在本学期前面的某些课程中，我们已经看到了一些这种数据整理的例子，例如当你使用管道操作符时，它可以让你从一个程序的输出中获取数据并将其传递给另一个程序，你就是以某种方式进行数据整理。
但是在这节课上，我们将会看到更高级和更实用的数据整理方法。
然而，要进行任何类型的数据整理，你需要有一个数据源。
你需要先有一些数据才能进行操作。
这样的数据很多种，我们在今天的讲座笔记的练习部分中给出了一些例子。
在这个例子中，我将使用一个系统日志。
我有一台服务器在荷兰运行，因为那时候看起来是个合理的选择。
在那台服务器上，它运行了一个常规的日志守护进程，这是Linux的一个相对标准的日志机制，有一个名为"journal CTL"的命令，可以让你查看系统日志。
所以我将对该日志进行一些转换，看看是否可以从中提取出一些有趣的东西。
然而，你会看到，如果我运行这个命令，我会得到很多数据，因为这个日志包含了很多东西，对于我的服务器来说，这个日志记录了从一月一日开始发生的事情，而且有些日志甚至记录了更早的事件。
有很多东西。
所以我们要做的第一件事情是尝试将它限制到只有一个内容。
```
好的，欢迎来到今天的讲座，我们将要讲解数据整理。
虽然"数据整理"这个词组可能听起来有些奇怪，但它的基本想法是，你有一份格式化的数据，但你希望将它转换成另一种不同的格式。这种情况时常发生。这种数据的格式转换可能涉及到图像转换，也可能是将文本文件或日志文件转换成另一种格式，例如图形或者统计数据。
任何将一段数据转换成另一种表示形式的过程都可以被称为"数据整理"。
在本学期前面的一些课程中，我们已经看到了一些数据整理的例子，例如当你使用管道操作符时，它可以让你从一个程序的输出中获取数据并将其传递给另一个程序，以便以某种方式进行数据整理。
但是在这节课上，我们将会看到更高级和更实用的数据整理方法。
然而，在进行任何类型的数据整理之前，你需要有一个数据源。你需要先有一些数据才能进行操作。这样的数据有很多种，我们在今天的讲座笔记的练习部分中给出了一些例子。在这个例子中，我将使用一个系统日志。
我有一台服务器在荷兰运行，因为那时候看起来是个合理的选择。在那台服务器上，它运行了一个常规的日志守护进程。这是Linux的一个相对标准的日志机制，有一个名为"journal CTL"的命令，可以让你查看系统日志。因此，我将对该日志进行一些转换，看看是否可以从中提取出一些有趣的东西。
然而，你会发现，如果我运行这个命令，我会得到很多数据，因为这个日志包含了很多内容。对于我的服务器来说，这个日志记录了从一月一日开始发生的所有事件，有些日志甚至记录了更早的事件。因此，我们需要做的第一件事情就是尝试将它限制到只有一个内容。
```

这里我们要用到grep命令。
我们将把这个命令通过grep管道进行传递，并用它来搜索SSH。
SSH指的是一种通过命令行远程访问计算机的方式。
特别是当您将服务器放在公共互联网上时，全世界的人都会试图连接并登录以接管您的服务器。
因此，我想查看这些人试图如何做到这一点，所以我要使用grep搜索SSH。
您很快就会看到，这也会生成大量内容。
至少在理论上，这会非常慢。
这将生成大量内容，很难甚至只是可视化这里正在发生的事情。
因此，让我们只查看人们尝试登录我的服务器时使用的用户名。
所以，您会看到其中一些行显示为已断开连接，已断开连接的无效用户，然后是某个用户名。
我只需要这些行，这就是我真正关心的。
不过，我将再做一次更改，如果您考虑此管道的工作方式，如果我在这里做到“已连接”，那么此管道底部的操作将会将整个日志文件通过网络发送到我的机器，然后在本地运行grep来仅查找包含ssh的行，然后在本地进一步过滤它们。
这似乎有点浪费，因为我不在乎大多数这些行，而且远程站点也在运行shell，所以我实际上可以在服务器上运行整个命令。
因此，我告诉您，SSH，我要您在服务器上运行这三个管道操作，然后将返回的内容通过less管道进行传递。
```
在这里，我们将使用grep命令。
我们将使用grep管道将该命令传递，并用它来搜索SSH。
SSH是一种通过命令行远程访问计算机的方式。
特别是当您将服务器放在公共互联网上时，全世界的人都会试图连接并登录以接管您的服务器。
因此，我想查看这些人试图如何做到这一点，所以我要使用grep搜索SSH。
很快您就会看到，这将生成大量内容。
至少在理论上，这会非常慢。
这将生成大量内容，很难甚至只是可视化这里正在发生的事情。
因此，让我们只查看人们尝试登录我的服务器时使用的用户名。
所以，您会看到其中一些行显示为已断开连接的无效用户，然后是某个用户名。
我只需要这些行，这就是我真正关心的。
不过，我还要进行一些修改。如果您考虑此管道的工作方式，如果我在这里加上“已连接”，那么整个日志文件都会通过网络发送到我的机器，然后在本地运行grep来仅查找包含ssh的行，然后在本地进一步过滤它们。这似乎有点浪费，因为我不关心大多数这些行，而且远程站点也在运行shell，所以我实际上可以在服务器上运行整个命令。
因此，我会告诉SSH，在服务器上运行这三个管道操作，然后通过less管道将返回的内容传递回来。
```

这个操作是什么意思呢？它将进行与我们之前筛选日志相同的筛选，但是它将在服务器端执行，服务器只会发送我关心的那些行给我。
然后，当我将其本地通过叫做less的程序进行管道连接时，less是一个分页程序。
你已经看到过一些例子，比如当你输入man命令时，它会在一个分页程序中打开，分页程序是一种方便的方式，可以将长篇内容适应到你的终端窗口中，并让你滚动和浏览，以便不会直接滚过你的屏幕。
因此，如果我运行这个命令，它仍然需要一段时间，因为它必须解析大量的日志文件，并且特别地，grep正在缓冲，因此它决定是相对不可靠的。
我可以尝试不加grep参数来运行，看看是否更有帮助。
它为什么不想帮助我呢？好吧，我要作弊一点，忽略我。
或者因为互联网速度真的很慢。
幸运的是，有一个解决办法，因为之前我已经运行了以下命令。
因此，这个命令将匹配断开连接的所有SSH日志条目的输出，并将其保存在我电脑上的一个文件中。
好的，我在我的办公室运行了这个命令，这样做的目的是下载所有与"disconnect from"匹配的SSH日志条目，因此我本地拥有这些内容，这非常方便，对吧？没有必要每次都流式传输整个日志，因为我知道我将来要操作的内容一定是这些起始模式。
因此，我们可以查看SSH.log文件，你会看到有很多很多行，都说"disconnected from"，"invalid user"，"authenticating users"等等。
所以这些是我们需要处理的行，这也意味着未来，我们不必经过整个SSH过程。
我们只需要查看那个文件，然后直接操作它。
因此，在这里我还可以演示一下这个分页程序，如果我运行cat SSH.log并将其通过less管道连接，它会给我一个分页程序，我可以上下滚动。
可以把它变小一点，这样我可以通过这个文件浏览，我可以使用大致上的Vim绑定来进行操作，比如控制U向上滚动，控制D向下滚动，Q退出。
```
这个操作的意思是什么呢？它将进行与之前筛选日志相同的筛选，但是它将在服务器端执行，只会将我关心的那些行发送给我。
然后，当我将其本地通过一个叫做less的程序进行管道连接时，less是一个分页程序。你已经看到过一些例子，比如当你输入man命令时，它会在一个分页程序中打开，分页程序是一种方便的方式，可以将长篇内容适应到你的终端窗口中，并让你滚动和浏览，以便不会直接滚过你的屏幕。
因此，如果我运行这个命令，它仍然需要一段时间，因为它必须解析大量的日志文件。特别地，grep正在缓冲，因此它决定是相对不可靠的。我可以尝试不加grep参数来运行，看看是否更有帮助。为什么它不想帮助我呢？好吧，我要作弊一点，忽略我，或者因为互联网速度真的很慢。
幸运的是，有一个解决办法，因为之前我已经运行了以下命令。这个命令将匹配所有与“disconnect from”相关的SSH日志条目，并将其保存在我电脑上的一个文件中。
好的，我在我的办公室运行了这个命令，这样做的目的是下载所有与“disconnect from”匹配的SSH日志条目，因此我本地拥有这些内容，这非常方便，对吧？没有必要每次都流式传输整个日志，因为我知道我将来要操作的内容一定是这些起始模式。
因此，我们可以查看SSH.log文件，你会看到有很多很多行，都说“disconnected from”，“invalid user”，“authenticating users”等等。这些是我们需要处理的行，这也意味着未来，我们不必经过整个SSH过程。我们只需要查看那个文件，然后直接操作它。
在这里我还可以演示一下这个分页程序。如果我运行cat SSH.log并将其通过less管道连接，它会给我一个分页程序，我可以上下滚动。可以把它变小一点，这样我可以通过这个文件浏览。我可以使用大致上的Vim绑定来进行操作，比如控制U向上滚动，控制D向下滚动，Q退出。
```

这依然是很多的内容，而且这些行包含了我并不感兴趣的垃圾信息。
我真正想看到的是这些用户名。
这里，我们要开始使用的工具叫做 sed。
Sed 是一个流编辑器，它修改了一个更早的程序叫做 edie，后者是一个非常奇怪的编辑器，你们可能都不想使用。
是的，Oh tsp 是我正在连接的远程计算机的名称。
因此，sed 是一个流编辑器，它基本上允许你修改流的内容。
你可以将其视为做替换，但实际上它是在流上运行的一个完整的编程语言。
然而，你用 sed 最常做的事情之一就是在输入流上运行替换表达式。
这是什么样子的呢？好的，让我给你展示一下。
这里，我将它管道到 sed，然后我会说我想要删除“disconnected from”之前的所有内容。
这可能看起来有点奇怪。
观察到的是，SSH 守护程序的日期、主机名和进程 ID，我不在意。
我可以直接删除它，还可以删除“disconnected from”那一部分，因为似乎每个日志条目中都包含这个。
因此，我编写了一个 sed 表达式。
在这种情况下，它是一个 S 表达式，即一个替换表达式。
它有两个参数，基本上是包含在这些斜杠中的。
因此，第一个是搜索字符串，第二个是目前为空的替换字符串。
所以，在这里，我是说搜索以下模式并将其替换为空格，然后在最后将其管道到 less 中。
你看到了吗？现在它已经删除了所有这些行的开头，正则表达式。

这看起来非常方便。
但你可能会想，我构建的这个模式是什么意思？这是一个正则表达式的例子。
在编程中你可能已经接触过正则表达式，但是一旦你进入命令行，你会发现自己经常使用它来进行数据处理。
正则表达式本质上是一种强大的匹配文本的方法。
你可以用它来匹配其他东西，但文本是最常见的例子。
在正则表达式中，有许多特殊字符，它们不仅可以匹配单个字符，还可以匹配特定类型的字符或一组选项。
它本质上为你生成一个程序，用于搜索给定的文本。
例如，句点（dot）表示任何单个字符，如果你在一个字符后面加上星号（star），它就表示该字符的零个或多个。
因此，在这种情况下，这个模式表示零个或多个任何字符，后面跟着字面上的字符串“disconnected from”。
我要求匹配它，然后用空格替换它。
正则表达式有许多这种特殊字符，具有各种不同的含义。
你可以利用它们。
我提到了星号（star），表示零个或多个，还有加号（Plus），表示一个或多个。
这表示我想要前面的表达式至少匹配一次。
你还可以使用方括号来匹配许多不同的字符。
所以在这里，让我们建立一个字符串列表，像AB这样，我想用空格替换A和B。

好的，那么这里我告诉模式要做的是用空替换任何A或B字符。
所以如果我把第一个字符变成B，它仍然会产生BA。
你可能会想，为什么它只替换了一次？这是因为正则表达式会做的事情，特别是在这种默认模式下，它们只会匹配一次模式，然后在每一行上应用一次替换。
这就是sed通常做的事情。
你可以提供G修饰符，它表示尽可能多次匹配，这种情况下会删除整行，因为每个字符都是A或B。
如果我在这里添加了一个C并移除除C以外的所有字符，那么中间的其他字符都将被保留，但是任何A或B都会被删除。
你也可以像对这个添加修饰符。
例如，这会做什么？它表示我想要零个或多个AB字符串，然后我要用空替换它们。
这意味着如果我有一个独立的A，它将不会被替换。
如果我有一个独立的B，它将不会被替换，但是如果我有AB字符串，它将被删除，这是因为sed很愚蠢。
这里的-a是因为sed是一个非常古老的工具，因此它仅支持非常旧的正则表达式版本。
通常，您需要使用-E（大写E）运行它，这使它使用更现代的语法来支持更多的功能。
如果你在无法使用的地方，你必须在括号前加上反斜杠，以表示“我要特殊的括号含义”，否则，它们只会匹配文字括号，这可能不是你想要的。
注意，这里替换了AB，这里替换了AB，但是它留下了这个C，而且它也留下了最后的A，因为这个A不再匹配这个模式了。
你可以按任何方式组合这些模式。
你也有类似于替换的东西。

你可以说任何匹配AB或BC的内容，我要删除它们。
你会发现这个AB已经被删除了，而这个BC虽然也符合模式，但因为AB已经被删除了，所以它没有被删除。
这个AB被正确地删除了，但C仍然保留在原地。
这个ab被删除了，而这个c被保留了，因为它仍然不匹配。
如果我这样做，如果我删除这个a，那么现在这个aB模式就不会匹配到这个B，所以它会被保留，然后BC将匹配BC，就会被删除。
当你第一次接触到正则表达式时，它们可能会非常复杂，即使你对它们有更多的经验，看起来仍然会让人望而生畏。
这就是为什么通常需要使用类似于正则表达式调试器这样的工具，我们稍后会介绍。
但首先，让我们试着制定一个能够匹配日志并且匹配到目前为止我们一直在处理的日志的模式。
所以在这里，我将从这个文件中提取出几行，比如前五行。
现在这些行看起来都是这样的，对吧？我们想要做的是只留下用户名。
那么这可能是什么样子呢？好的，我们可以试着做一件事情。
但是，让我先拿出一行内容，比如说“disconnected from invalid user disconnected from maybe four to one one whatever.”，这是一个登录行的例子，其中有人尝试使用用户名“disconnected from missing an S”登录。
你会发现这个模式实际上删除了用户名，这是因为当你使用“点星”和任何这些范围表达式、间接表达式时，它们是贪婪的。
它们会尽可能匹配更多内容。
所以在这种情况下，这是我们想要保留的用户名，但是这个模式实际上一直匹配到第二次出现它或最后一次出现它，所以它之前的所有内容，包括用户名本身，都被删除了。

因此，我们需要想出一个比只使用“点星”更聪明的匹配策略，因为这意味着如果我们遇到特别敌对的输入，我们可能会得到我们意想不到的结果。
好的，让我们来看看如何匹配这些行。
让我们从头开始构建这个正则表达式。
首先，我们知道我们要一个短横线加大写字母E，对吧？因为我们不想到处都要加反斜杠。
这些行看起来像是说“from”，然后有些行写了“invalid”，但有些没有，对吧？这行写了“invalid”，那个没有。
这里的问号表示零或一次，所以我想要“invalid space user”的零次或一次。
还有什么？好的，这里会是一个双空格，所以我们不能有那个。
然后会有一些用户名，然后会是一个看起来像是IP地址的东西。
这里我们可以使用我们的范围语法，写零到九和一个点，对吧？这就是IP地址，我们想要很多。
然后它说“port”，所以我们只需要匹配一个字面上的端口，然后是另一个数字零到九，然后我们会加号一次或多次。
这里我们还要做的另一件事是在正则表达式中加上锚定。
所以正则表达式中有两个特殊字符：一个是脱字符或帽子，它匹配行的开头，还有一个是美元符号，它匹配行的结尾。
所以这里我们要说这个正则表达式必须匹配整个行。
我们这样做的原因是想象一下，如果有人把他们的用户名设置为整个日志字符串，那么如果你尝试匹配这个模式，它会匹配用户名本身，这不是我们想要的。
通常，你会希望尽可能地锚定你的模式，以避免那些奇怪的情况。
好的，让我们看看这给我们带来了什么。
这删除了许多行，但不是所有行。
例如，这个行末包括了“pre-off”，所以我们需要去掉它。
如果有一个空格，“pre-off”，方括号是特殊字符，我们需要转义它们，对吧？现在，让我们看看如果尝试更多行会发生什么。

不，它仍然得到了一些奇怪的结果。
这是因为有些行不为空，也就是说这个模式没有匹配上。
例如，这一行是“authenticating user”，而不是“invalid user”。
那么，我们怎样才能匹配“invalid”或“authenticated”出现零次或一次，并紧跟着“user”呢？好的，现在看起来很有希望了，但是这个输出并不是特别有用，对吧？这里我们只是成功地删除了日志文件的每一行，这并不是非常有用的。
相反，我们真正想要做的是在匹配用户名时，就像这里一样，我们真正想要记住的是用户名，因为那是我们想要打印出来的内容。
在正则表达式中，我们可以使用捕获组来实现这一点。
捕获组是一种方式，可以指示我们要记住这个值，并在以后重用它。
在正则表达式中，任何带括号的表达式都将成为这样的捕获组。
我们实际上已经有了一个捕获组，就是这个第一个组，现在我们正在创建第二个组。
请注意，这些括号对匹配没有任何影响，因为它们只是在表示这个表达式是一个整体，但是我们没有在后面加上任何修饰符，所以只匹配一次。
捕获组之所以有用，是因为您可以在替换时引用它们。
在这里，我可以说反斜杠二。
这是指引用捕获组的名称的方式。
在这种情况下，我是说匹配整行，然后在替换中放入您捕获的第二个捕获组的值。
请记住，这是第一个捕获组，而这是第二个捕获组。
这样可以得到所有的用户名。
现在回顾一下我们写的内容，这非常复杂，对吧？现在我们已经逐步走过了它的每个步骤，知道为什么它必须是这样的，但这并不明显，这就是这些行的工作原理。

这就是正则表达式调试器非常有用的地方。
这里有一个调试器，网上也有很多。
我已经预先填好了我们刚刚使用的表达式。
你会注意到它告诉我现在所有的匹配情况。
这个窗口的字体有点小，但是如果我在这里做一些操作，这个解释会告诉我点-星可以匹配零个或多个字符，然后是“断开连接”，后面是一个捕获组，它会向你展示所有的东西。
这是一件事，但它还会让你给出一个测试字符串，然后将模式与每个测试字符串匹配，并突出显示不同的捕获组。
所以，在这里，我们将用户设置为了一个捕获组，对吧？它会说好的，整个字符串都匹配了，所以整个字符串都是蓝色的，所以它匹配了。
绿色是第一个捕获组，红色是第二个捕获组，这是第三个捕获组，因为“pre-auth”也被放在括号中。
这是一种方便的方法，可以尝试调试正则表达式。
例如，如果我输入“断开连接”，然后在这里加一行，让用户名变成“disconnected from”，现在这一行的用户名已经变成“disconnect from”。
很好，我在这里有一些预见性。
你会注意到，使用这个模式，这不再是一个问题，因为它匹配了用户名。
如果我们把整行或整行变成用户名会发生什么？现在会变得非常混乱，对吧？所以这就是为什么正则表达式很难弄对的原因，因为它现在尝试匹配。
它匹配第一次出现的用户名，或者第二个“invalid”（在这种情况下），因为这是贪婪的。
我们可以通过在这里加一个问号来使它变成非贪婪。

如果你在加号或星号后面加上一个问号，它就变成了一个非贪婪匹配。
这意味着它将不会尽可能地匹配尽可能多的字符。
然后你会发现，这个表达式被正确解析了，因为这个点会停在第一个disconnected from，这是SSH实际上会生成并出现在我们的日志中的。
从这些解释中，你可能可以看出正则表达式可以变得非常复杂，并且你可能必须在模式中应用各种奇怪的修饰符。
真正学习它们的唯一方法是从简单的表达式开始，然后逐步构建，直到它们匹配你所需的内容。
通常你只需要处理一些类似于我们在这里提取用户名的一次性工作，而不需要关心所有特殊的条件，对吧？不需要担心某个人的SSH用户名是否完全匹配你的登录格式。
那可能不是什么重要的事情，因为你只是想找到用户名。
但是正则表达式确实非常强大，如果你做的是真正重要的事情，你就要小心。
你提出了一个问题：默认情况下，正则表达式只会按行匹配，不会跨越换行符。
所以sed的工作方式是每行操作，所以sed将为每一行执行这个表达式。
好的，关于正则表达式或者这个模式有什么问题吗？这是一个复杂的模式，如果感觉困惑，不要担心。
之后可以在调试器中查看它。
请记住，我们在这里假设用户只能控制他们的用户名。
所以他们能做的最糟糕的事情就是把整个条目都作为用户名。
看看会发生什么，对吧？这就是它的工作原理。
原因在于这个问号的作用，它意味着一旦我们遇到断开连接的关键字，就开始解析模式的剩余部分。
而SSH在用户可以控制任何东西之前就打印了第一次出现的disconnected。
因此，在这种特定情况下，即使是这种情况也不会混淆模式。

如果你在进行数据整理时使用这种奇怪的匹配方式，通常不会涉及到安全问题，但可能会导致你得到非常奇怪的数据。
如果你要绘制数据图表，可能会漏掉重要的数据点，或者解析出错误的数字，然后你的图表中就会出现原始数据中没有的数据点。
因此，如果你发现自己在编写复杂的正则表达式，请仔细检查它是否确实匹配了你想要匹配的内容。
即使与安全无关，正则表达式的模式也可能非常复杂。
例如，关于如何使用正则表达式匹配电子邮件地址存在很大的争议。
你可能会想到类似于这样的模式：字母、数字、下划线和百分号，后跟一个加号，因为在 Gmail 中，电子邮件地址中可以包含加号。
在这种情况下，加号只是用于表示任意数量的这些字符，但至少要有一个，因为一个没有任何内容的电子邮件地址是无效的，而且在域名后面也是一样。
顶级域名必须至少包含两个字符，并且不能包含数字。
你可以使用.com，但不能使用.dap7。
但事实证明，这种方法并不是完全正确的。
有很多有效的电子邮件地址无法通过这种方式匹配，也有很多无效的电子邮件地址可以通过这种方式匹配。
因此，有许多建议，有些人已经建立了完整的测试套件来尝试找到最佳的正则表达式，而这个特定的正则表达式是用于 URL 的。
类似的正则表达式也适用于电子邮件地址，他们发现最好的正则表达式是这个。
我不建议你试图理解这个模式，但这个模式似乎几乎可以完美地匹配互联网标准中的有效电子邮件地址，包括各种奇怪的 Unicode 代码点。

这只是说，正则表达式可能非常复杂，如果你陷入像这样的境地，那么可能有更好的方法。
例如，如果你发现自己试图解析HTML或JSON等表达式的内容，你应该使用不同的工具。
还有一个练习，要求你不使用正则表达式完成这个任务。
如果你想了解它们的工作原理，可以查看讲义。
现在我们有了用户名列表，让我们回到数据整理。
对我来说，这个用户名列表还不是很有趣。
让我们看看有多少行。
如果我使用wc -l命令，有198000行。
wc是单词计数程序，-l让它计算行数。
这是很多行。
如果我开始滚动它们，这仍然没有帮助我。
我需要统计数据，需要某种聚合，而sed工具对许多事情都很有用，它提供了一个完整的编程语言，可以做奇怪的事情，比如插入文本或只打印匹配的行，但并不一定是万能的工具。
有时候有更好的工具。
例如，你可以编写一个行计数器。
你只是不应该使用sed，除了搜索和替换之外，它是一个糟糕的编程语言，但有其他有用的工具。
例如，有一个叫做sort的工具。
sort接受一堆输入行，将它们排序，然后将它们打印到输出中。
因此，在这种情况下，我现在得到了那个列表的排序输出。
它仍然有20万行，对我来说仍然不是非常有用，但现在我可以将它与一个叫做uniq的工具组合使用。

uniq会查看一个排序后的行列表，并仅打印那些唯一的行。
因此，如果有多个相同的行，则仅打印一次。
然后我可以使用uniq -c，这将计算任何重复行的重复次数并消除它们。
这是什么样子？好的，如果我运行它，需要一段时间。
有13个zze用户名，有10个ZXVF用户名等等。
我可以滚动浏览这个列表。
这仍然是一个非常长的列表，但至少现在它比以前更整理了一些。
让我们看看现在我有多少行。
好的，有24,000行。
它仍然太多，对我来说不是有用的信息，但是我可以使用更多的工具来缩小范围。
例如，我可能关心哪些用户名被最多使用。
那么，我可以再次使用sort，然后我可以说我想在输入的第一列上进行数字排序，因此-n表示数字排序，-K允许您选择要按其排序的输入中的一个空格分隔列。
我在这里给出一个逗号，是因为我想从第一列开始并在第一列停止。
或者，我可以说我要按这个列列表进行排序，但在这种情况下，我只想按该列排序。
然后我只想要最后的十行。
因此，默认情况下，sort会按升序输出，因此具有最高计数的那些将位于底部，然后我只想要最后的十行。
现在当我运行这个命令时，我实际上得到了一些有用的数据。
对，它告诉我有11,000次使用用户名root的登录尝试，有4,000次使用用户名123456等等。
这非常方便，对吧？现在突然间这个巨大的日志文件实际上为我提供了有用的信息。
这就是我真正想从那个日志文件中得到的信息。

现在，也许我只想快速禁用我的机器上SSH登录的root用户，这是我建议你也要做的。
在这种情况下，我们实际上不需要-k4排序，因为默认情况下，sort会按整行排序，而数字恰好排在第一位。
但是了解这些额外的标志是有用的，您可能会想知道，我怎么知道这些标志存在？我怎么知道这些程序甚至存在？好吧，通常是从像这样的课程中得到的信息。
标志通常是“我想按照不是整行的某些东西进行排序。
”您的第一反应应该是键入man sort，然后阅读页面，很快就会告诉您，“这是如何选择一个非常好的列。
这是如何按数字进行排序的。
”好的，如果现在我有了这个前20名的名单，假设我实际上并不关心计数，我只想要一个逗号分隔的用户名列表，因为我要每天通过电子邮件发送给自己之类的东西，例如：“这是前20个用户名。
”那么我可以这样做。
这是很多奇怪的命令，但它们是值得知道的命令。
awk是一种基于列的流处理器。
所以我们谈论过sed，它是一种流编辑器，所以它主要尝试编辑输入中的文本。
另一方面，awk也让您编辑文本。
它仍然是一种完整的编程语言，但它更专注于列数据。
因此，在这种情况下，awk默认会解析其输入的空格分隔列，然后单独操作这些列。
在这种情况下，我正在说仅打印第二列，也就是用户名。
Paste是一个命令，它将一堆行粘在一起成为一行，这是用逗号分隔符“-s”表示的。
因此，在这种情况下，对于这个问题，我想获得一个逗号分隔的前用户名列表，然后我可以做任何有用的事情。
也许我想将其放入不允许用户名的配置文件中或类似的内容。
值得更多地讨论awk，因为它被证明是这种数据整理的一个非常强大的语言。
我们简要提到了“print $2”做了什么，但事实证明，对于awk，您可以做一些非常非常复杂的事情。

例如，让我们回到我们只有用户名的地方。
我认为我们仍需要使用sort和unique，因为否则列表会变得太长，而且我只想打印与特定模式匹配的用户名。
例如，我想查看所有仅出现一次且以C开头以e结尾的用户名。
虽然这是一件奇怪的事情，但总体来说，它非常简单易懂。
我可以说我希望第一列为1，第二列匹配以下正则表达式。
嘿，这可能只是一个点，然后我想打印整个行。
所以，除非我弄错了什么，这将给我所有以C开头以e结尾并且在日志中仅出现一次的用户名。
现在，这可能对数据并不是非常有用。
我在这个讲座中试图向您展示可用的工具类型，而在这种特定情况下，即使我们所做的事情很奇怪，这种模式也不是很复杂。
这是因为在Linux上，特别是在命令行工具中，工具通常是基于输入行和输出行构建的，而这些行通常会有多列，而awk非常适合操作列。
现在，awk不仅可以像每行匹配那样做事情，而且还可以让你做一些事情，例如，我想知道这些的数量。
我想知道有多少用户名与此模式匹配。
好的，WCHL可以正常工作。
有31个这样的用户名，但awk是一种编程语言。
这是您可能永远不会自己做的事情，需要了解这些。

但是重要的是要知道你可以做到。
有时候这样做实际上是有用的。
我刚刚意识到这可能在我的屏幕上很难阅读，让我尝试在一秒钟内修复它。
让我们开始……是的，显然鱼不想让我这样做。
那么，这里开始是一个只匹配第零行的特殊模式。
结束是一个只在最后一行之后匹配的特殊模式。
然后这将是一个正常的模式，用于匹配每一行。
所以我在这里所说的是，在第零行上，将变量rose设置为零。
在每行匹配此模式时，增加rose的值。
在匹配了最后一行之后，打印rose的值。
这将具有与运行WCHL相同的效果，但全部使用awk。
像WCHL这样的特定实例非常好，但有时您可能想要像保留词典或地图之类的内容。
您可能想要计算统计信息。
您可能想要这样做，例如：我想要此模式的第二个匹配项。
因此，您需要一个有状态的匹配器，可以忽略第一个匹配项，但然后打印第二个匹配项之后的所有内容。
对于此类简单的awk编程，可能很有用。
实际上，我们可以在这种模式中，摆脱最初用于生成此文件的said，sort，unique和grep，并全部使用awk来完成。
但您可能不想这样做。
这可能会太痛苦而不值得。
值得稍微谈谈您可能想要在命令行上使用的其他工具类型。
其中之一是一个非常方便的程序，称为BC。

BC是伯克利计算器，我想。
Man BC。
我认为BC最初来自伯克利计算器。
它是一个非常简单的命令行计算器，但是它不会给你提示符，而是从标准输入中读取。
所以我可以像这样做：echo 1加2，然后将其管道传递给BC。
Shell因为许多这些程序通常在愚蠢模式下运行，因此它们不是很有帮助。
所以它在这里打印了3。
哇，非常令人印象深刻。
但是事实证明这可以非常方便。
想象一下你有一个包含一堆行的文件，比如说，我不知道，这个文件。
假设我想要求出登录次数，用户名仅被使用一次的数量。
好的，那么计数不等于1的用户名，我只想打印出计数。
对的，这是我，给我所有非单次使用用户名的计数。
然后我想知道这些有多少个。
请注意，我不能只数行，因为每行都有数字。
我想求和。
好的，我可以使用paste将其粘贴到加号中。
因此，将每行都粘贴到加号表达式中。
现在这是一个算术表达式，因此我可以将其通过BCL管道传递。
现在有191,000次登录与至少一个其他登录共享用户名。
再次说明，这可能不是你真正关心的事情，但这只是为了向你展示你可以相当容易地提取这些数据。
你还可以用这个做很多其他的事情。
例如，有一些工具可以让你对输入进行统计分析。
因此，对于我刚刚打印的这个数字列表，我可以做一些像使用R这样的事情。
R是一种专门用于统计分析的单独编程语言。
我可以说，让我看看我是否做对了......这又是一种你需要学习的不同编程语言，但如果你已经了解R，或者你也可以将它们通过其他语言管道传递，比如这样。

这个命令会在输入流中给我一个汇总统计数据。
因此，每个用户名的登录尝试中位数为3，最大值为10,000（这是我们之前看到的路由），并告诉我平均值为8。
对于这个特定的实例，这可能并不重要，这些可能不是有趣的数字，但是如果您正在查看来自基准测试脚本或其他一些数值分布的输出，并且想要查看它们，这些工具非常有用。
我们甚至可以进行一些简单的绘图。
因此，这里有一些数字。
让我们回到我们的sort和k-11，并只查看前两个5。
GNU绘图器是一种让您从标准输入中获取内容的绘图器。
我并不希望您了解所有这些编程语言，因为它们确实是自己的编程语言，但只是向您展示可能的内容。
现在，这是自1月1日以来我的服务器上使用前5个用户名的次数的直方图，这只是一个命令行。
这是一个有点复杂的命令行，但它只是一个命令行，您可以这样做。
还有两种特殊类型的数据整理，我想在我们剩下的时间中与您谈论的第一种是命令行参数整理。
有时，您可能会像我们在上一堂课中看到的那样，拥有像查找这样的东西，产生文件列表或者可能产生基准测试脚本参数列表的内容，例如您想使用特定的参数分布运行它。
假设您有一个脚本，打印运行特定项目的迭代次数，并且您希望像指数分布一样打印每行的迭代次数，并且您要为每个迭代次数运行基准测试。

好的，这里有一个工具叫做xargs，它是你的好朋友。
xargs可以将输入的每行转换成参数。
这可能看起来有些奇怪。
我来举一个例子。
我用Rust编程，而Rust可以安装多个版本的编译器。
所以在这种情况下，你可以看到我安装了稳定版、beta版和几个较早的稳定版本，并启动了不同的日期的Nightly版本。
这些都非常好，但是随着时间的推移，我不需要去年3月的Nightly版本了。
我可能想偶尔清理一下这些版本，或许我想清理一下这些东西。
好吧，这是一系列行的列表，所以我可以先找出Nightly版本，然后把它们删掉。
-V表示不匹配，我不想匹配到当前的Nightly版本。
好的，这是一个日期为Nightly的列表。
也许我只想要2019年的版本，现在我想为我的机器卸载这些工具链。
我可以手动复制每个工具链的名称并粘贴到rust up tool chain remove或uninstall，对吧？但是我现在有这个列表，手动输入会变得非常烦人。
所以，我想删除它添加的这种后缀，现在只剩下名称，然后我使用xargs。
因此，xargs将输入列表转换成参数。
所以我想把这些参数传递给rust up tool chain uninstall，并为了我的方便，我会加上echo以便查看要运行的命令是什么。

嗯，这些信息可能不是很有用，但至少你可以看到即将执行的命令。
如果我去掉这个echo，就是rust up tool chain uninstall，然后是Knightley的列表作为该程序的参数。
这样，如果我运行它，就会卸载所有工具链，而不必复制粘贴它们。
因此，这是一个例子，说明这种数据整理实际上可以用于除了查看数据以外的其他任务。
它只是从一个格式转换到另一个格式。
您也可以整理二进制数据。
因此，一个很好的例子是一些视频和图像，您可能真的希望以某种有趣的方式对它们进行操作。
例如，有一个叫做ffmpeg的工具。
ffmpeg用于编码和解码视频，以某种程度上的图像。
我将设置它的日志级别为panic，否则它会打印很多东西。
我希望它从dev video 0读取，这是我的网络摄像头设备的视频，我想要获取第一帧，所以我只想要一张图片，而不是单帧视频文件，然后我希望打印它的输出。
-通常是告诉程序使用标准输入或输出而不是给定文件的方式。
因此，它在这里期望一个文件名，而文件名-在这种情况下表示标准输出。
然后，我想通过一个叫做convert的参数将其导管。
convert是一个图像处理程序。
我想告诉convert从标准输入读取，并将图像转换为灰色空间，然后将结果图像写入文件-，这是标准输出。
我不想将其导管到gzip中；我们将只压缩这个图像文件，这也将只在标准输入和标准输出上操作。
然后，我将把它导管到我的远程服务器，并在那里解码该图像，然后将该图像的副本存储下来。

记住，tee 会读取输入，将其打印到标准输出和文件中。
这将复制解码后的图像文件，并继续将其流出。
现在我将把它带回本地流，并在图像显示器中显示。
让我们看看是否有效。
嘿，好的，现在它通过服务器进行了往返，然后通过管道返回，至少在理论上，我的服务器上有一份未压缩的文件的副本。
让我们看看它是否存在：在这里，CPT's p copy PNG 2 和 CP 8，是的，嘿，同样的文件出现在了服务器上，我们的管道工作了。
再次强调，这是一个有点儿傻的例子，但它让你看到了构建这些管道的强大之处，这些管道不必是文本数据，它只是将任何格式的数据从一种格式转换为另一种格式。
例如，如果我想，我可以使用cat dev video 0，然后将其传送到Anish控制的服务器上，然后他可以通过将其输入到他机器上的视频播放器中观看该视频流。
如果我们想要写入，我们只需要知道这些东西的存在。
这个实验室有一些练习题，其中一些依赖于你拥有一个看起来有点像Mac OS和Linux上的日志的数据源。
我们提供了一些命令，供你尝试实验，但请记住，你使用的数据源不是那么重要。
更重要的是找到一些数据源，你认为可能存在一些有趣的信号，然后尝试从中提取一些有趣的东西，这就是所有练习的目的。

因为周一是马丁·路德·金纪念日，所以下一次课是星期二，讲述命令行环境。
大家对我们目前讲解的内容或是管道或是正则表达式有什么问题吗？我强烈推荐你们学习正则表达式，它们非常方便，不仅在这里使用，而且在编程中也很实用。
如果有任何问题，请来办公时间，我们会帮助你们的。
