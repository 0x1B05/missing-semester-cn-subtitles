好的，那么，让我们开始今天的讲座吧。
今天，我们将讨论安全和密码学，今天的讲座会与我们去年课堂上对这个话题的处理有些不同。
去年，我们更注重从计算机用户的角度讨论安全和隐私问题，但今天我们将更多地关注安全和密码学概念，这些概念对于理解我们在这门课上早些时候讨论的一些工具非常重要。
例如，我们在Git讲座中讨论了哈希函数或加密哈希函数（如sha-1），在命令行环境讲座中讨论了公钥。
因此，今天我们将更详细地讨论这些不同的密码原语，了解它们的工作原理以及它们在这些不同的工具中的使用方式。
这个讲座不是替代更严格的安全课程的，麻省理工学院有很多非常好的课程，例如6.858，它是关于计算机系统安全的，或者6.857和6.875，它们更加专注于密码学。
因此，在没有接受这些课程或其他地方的安全形式培训的情况下，请不要从事安全工作。
除非你是专家，否则不要自己开发加密算法，不要构建自己的加密实现或协议。
同样的原则也适用于计算机系统安全。
这个讲座不是关于构建自己的东西，而是关于了解已经存在的东西。
因此，我们认为这个讲座将非常非正式但实用地处理这些基本的密码学概念，并希望它能帮助你理解我们在这门课上早些时候讨论的一些工具。
今天的讲座计划有什么问题吗？太好了。
那么今天的第一个话题是熵。
熵是随机性的一种度量，这在尝试确定密码强度时非常有用。
让我们看看xkcd的这个漫画，我们很喜欢xkcd漫画。
这个漫画举手如果你以前看过这个漫画。
【暂停】好的，你们中有很多人。
这个漫画抱怨了这种常见的模式，这种模式被教给计算机用户，即当你设计密码时，它们应该是像“t＃0rU＆b40rM $”或“p3@ch3$”这样的字符串，就像我们应该设计充满有趣字符和其他内容的密码，以使攻击者很难猜测。
然而，事实证明，像这样的密码实际上相当脆弱，易于被能够快速猜测密码和暴力攻击的计算机所猜测。
另一方面，像左下角的"correct horse battery staple"这样直觉上看起来不太安全的密码，却被证明更安全。
那么我该如何量化这些不同密码的安全性呢？通过测量密码中的随机性数量，即其中有多少比特的随机性。
因此，熵是以比特为单位进行度量的。

这段话主要是在讲如何量化密码的安全性，通过计算密码中包含多少随机性的“熵”来衡量。
熵是用比特（bits）来度量的，和信息论中的熵类似。
在简单的情况下，我们只需要考虑从一组事物中随机选择的情况。
例如，构造一个由四个随机单词组成的密码时，我们可以从一个包含一百万个单词的字典中随机选择每个单词。
通过计算可能性的数量，就可以得出熵的度量，即可能性数量的以2为底的对数。
在这个例子中，如果有一千个可能性，那么攻击者每秒尝试猜测一千个密码，这不是一个很好的密码。
熵的度量也决定了攻击者需要多长时间才能破解密码。
对于硬币抛掷，因为只有两种可能性，所以熵是1比特。
对于骰子掷出的6个面，有6种可能性，所以熵是2.6比特。
在设计密码时，我们需要考虑生成密码的模型，例如，在左上角的例子中，我们可以将一个词典单词的某些字符替换为类似的数字，然后在末尾加上一个标点符号和一个数字，我们可以使用常规语言来计算这样的密码有多少种可能性，然后计算出熵。
在这个例子中，密码的熵为28比特。
而在左下角的例子中，“correct horse battery staple”，我们假设有一个包含2000个单词的词典，将其中四个单词组合起来，就可以获得大约44比特的熵，比前面的例子更加安全。
在设计密码时，我们需要考虑我们要保护的内容和受到攻击的威胁模型，不同的威胁模型需要不同的熵来保护密码的安全。

例如，这个漫画提到了一个攻击者可以每秒猜测一千个密码。
这可能对某些允许人们尝试使用您的电子邮件和随机密码进行登录的网络服务来说是可能的。
但是，这个每秒猜测一千个密码的模型可能对其他情况不准确。
例如，离线密码破解场景或者攻击者已经破解了一个网站并下载了它们的数据库，他们有一种混淆形式的您的密码，并且正在尝试找出密码是什么。
也许他们可以并行化这种攻击，使其每秒进行一百万次猜测。
猜测次数取决于您需要保护自己免受什么样的攻击。
但是，对于需要受到保护的网站并且您担心在线密码猜测的情况，大约四十个比特的熵可能足够了。
如果您担心离线攻击并且想要真正、真正地安全，那么可能需要八十比特的熵。
这些是您可以使用的大致指南。
那么，如何生成强密码呢？首先，您需要一些密码模型。
例如，常用的字典词组，您可以得到一个字典。
然后，您可以使用类似于掷骰子的方法。
有一首歌曲在讲义中有链接，您可以获得物理骰子并将其滚动，然后将掷骰结果映射到字典词语，以最终将其转换为密码。
这样做的好处在于，使用一些您知道是随机的物理标记（如平衡骰子或硬币）是一个好习惯，因为人类实际上并不擅长选择随机数字。
如果我让您从1到100中随机选择一个数字，您很有可能不能很好地以均匀随机的方式选择。
这就是为什么使用这些物理标记来产生随机性是好的。
熵是我们的第一个概念。
有关此事或此漫画的任何问题吗？好的。
那么进入稍微有趣和复杂的主题，下一个我们要谈论的是哈希函数。
希望你们中的大多数人都参加了上一次关于Git中使用的SHA-1哈希函数的讲座。
现在更详细地讨论这个主题，哈希函数在高层次上是将可变数量的数据映射为固定大小输出的函数。
这是这个特定哈希函数的类型签名。
这些函数具有一些有用的属性。
从高层次来看，它们可以被视为难以反演的函数，其输出看起来是随机的。
我们可以在一些随机数据上实际尝试这个函数。
例如，如果我在我的终端中输入 "printf hello"，它将按照你所期望的那样打印出字符并将其导出到标准输出，然后我可以将其导入 SHA-1 校验和命令。

这是一个命令行程序，通过标准输入接受输入，并计算SHA-1函数，该函数从输入中获取一些可变数量的字节并生成一个160位的输出，该输出在这种情况下表示为十六进制字符串。
因此，它是一个长度为40的十六进制字符串，并且您可以在此处看到此输出。
 "-"只是表示它从标准输入中获取了输入。
因此，此输出看起来像某些随机数字，但重要的一点是，这是一个确定性数字。
如果您在自己的计算机上尝试相同的命令“printf hello | SHA-1 something”，您将得到相同的输出。
因此，SHA-1是一些人们已经就其所有参数达成一致的著名函数。
我们将看到，如果我们略微调整输入，比如说将“hello”更改为一个大写的“Holo”，现在我得到了一个完全不同的输出。
即使它是确定性的，它也看起来像某种其他随机的数字，并且您可以在自己的计算机上再现它。
哈希函数具有许多重要属性。
密码哈希函数具有的第一个属性是它们是不可逆的。
这意味着，如果您获取此函数的输出，例如，即“aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d”，则很难弄清楚产生该输出的输入是什么。
因此，您可以很容易地计算SHA-1哈希值，但是您无法逆向操作。
这些函数具有的另一个属性是它们是抗碰撞的。
这个属性的意思是很难找到两个不同的输入产生相同的输出。
因此，这基本上描述了什么是密码哈希函数。
那么，这些哈希函数实际上有什么用途呢？嗯，我们已经在Git中看到了内容地址存储的一个应用。
因此，我们希望得到一种统一的方式来命名存储在对象存储中的不同对象，而Git将它们全部命名为它们的SHA-1哈希。
因此，您拥有要存储的实际数据，然后要为该特定数据命名，只需命名SHA-1哈希即可。
所有这些都以特定方式存储在对象存储中。
我们在查看Git的许多不同部分时看到了这一点。
例如，右边这里，我进入Git存储库。
如果我执行'git log'，它会显示提交。
例如，这个数字上面是密码哈希函数SHA-1应用于描述此特定提交的提交对象。
那么，有人知道为什么Git在这里使用密码哈希函数而不是......你可能在其他计算机科学课程中听说过称为散列函数的东西，没有前面加上“密码学”这个词。

它们具有类似的属性，可以将可变大小的输入转换为某个固定大小的输出。
但是它们并没有完全具备难以找到产生特定输出的输入等属性。
这是一种比较弱的定义。
那么，为什么在 Git 中我们关心拥有一个密码哈希函数而不仅仅是一个普通的哈希函数？大家有什么想法吗？是的，基本上就是这样，我们不希望这个哈希函数的输出产生冲突。
就像每个提交都由一个哈希函数标识，每个文件都由该文件的哈希标识。
如果在实践中有两个不同的内容产生了相同的输出，也就是说，如果该函数不具有抗碰撞性，那么这可能会造成很大问题。
因为你和我，我们可能会为了得到我们认为是相同的 repo，检出相同的提交哈希，并且我们可能会得到不同的文件。
这是令人担忧的，因为 Git 用于跟踪软件、跟踪软件的开发，同时也涉及确保正确的人员在编写软件，没有发生任何有趣的事情。
例如，有许多开源项目，如 Linux 内核，使用 Git 进行开发。
如果某个 Git 贡献者能够编辑某个文件并提出一些看起来相当良性的更改请求，比如“让我改进一下 Linux 的这个部分”，提交该更改请求给 Linux 开发人员，然后在实践中实际提供一个具有相同提交哈希等的 Git 存储库，但实际上文件内容是不同的，那么就有一些恶意行为。
因此，Git 实际上依赖于这个 SHA-1 函数作为密码哈希函数，以实现安全性。
还有其他一些有趣的哈希函数应用吗？所以，就像我们看到的那样，哈希函数将大输入转换为小输出，而且由于哈希函数是抗碰撞的，输出可以用来验证或标识输入。
因此，您可以将哈希视为文件的简短摘要。
例如，在此目录中的一堆文件中，我可以计算此 readme MD 文件的 SHA-1 校验和。
有趣的是，计算出另一个具有相同哈希输出的文件在计算上是计算上困难的，或者你可以认为是不可能的。
在从互联网下载文件的情况下，这种场景非常有用。
例如，有许多 Linux 发行版从其网站分发大型 CD 或 DVD 映像。
像我可以到 Debian org 上下载最新版本的 Debian。
问题是，托管这些文件可能是昂贵的。
因此，许多人很好心地提供这些文件的镜像。
所以，我可以去许多其他站点之一，而不是从Debian org下载Debian，下载那些在Debian org托管的应该是相同的文件。
但是，我怎么知道我实际上得到了正确的文件？比如，如果我设置了一个恶意镜像，你去了类似Anisha是恶意Debian网站的地方然后尝试下载Debian，结果你的Linux安装被植入了后门。
好吧，你可以做的一件事就是从原始的Debian网站下载一份副本，然后下载我的版本并进行比较。

事实上，托管这些文件可能会很昂贵。
因此，很多人都很友好地托管这些文件的镜像。
因此，我可以不从Debian.org下载Debian，而是可以去许多其他站点之一，并下载应该是Debian.org托管的相同文件。
但是，我怎么知道我是否真的得到了正确的文件呢？比如，如果我设置了一个恶意镜像，你去像Anisha is evil Debian website com这样的站点尝试下载Debian，结果你的Linux安装被后门入侵了。
那么，你可以做的一件事是从原始的Debian网站下载一份副本，然后再下载我的版本并进行比较。
 但这有点违背了初衷，对吧？因为我们希望避免从Debian.org下载文件，因为托管这些文件很昂贵，我们希望让许多不同的人能够在其他地方镜像文件的副本。
那么，有没有人看到加密哈希函数如何有用来解决这个问题？我想从一个不受信任的来源下载一个文件，而不是从受信任的来源本身下载文件。
但也许我可以从这个受信任的来源获取一些小的信息，以便知道我从不受信任的来源下载的文件是否是我应该得到的东西。
是的，它基本上只是一个加密哈希函数的简单应用。
因此，Debian.org可以生成它们的正确ISO文件或其他文件，并且不是在其网站上发布文件本身，而是发布该文件的哈希值。
与文件本身相比，这个哈希值可能只有160位数据，在这种特殊情况下非常便宜。
然后，作为用户，我可以从任何随机网站下载该文件，可能是一个不受信任的网站，下载完成后，我只需双重检查sha-1哈希值。
如果哈希匹配，则我知道我有正确的文件，因为对于某人来说，给我一些不同的文件，而这些文件恰好具有相同的哈希值是计算上不可能的，因为哈希函数是抗碰撞的。
对此应用有任何问题吗？是的，这是一个很好的问题，为什么需要不同的人来托管信息？难道对于每个人来说都同样昂贵吗？这个问题的答案有点复杂，但这是部分答案。
一件事是从服务器下载文件受到服务器距离你有多远的影响。
举个例子，如果服务器在马萨诸塞州而您在中国，您必须通过互联网进行大量的往返，这可能会因为许多原因而变得昂贵，比如延迟高，流量需要通过许多不同的电线才能到达您所在的位置。
因此，这些网站所做的一件事情就是将他们的内容分发到世界各地的服务器上，然后作为用户，您从最接近您的服务器下载。
比如，MIT维护一个Debian软件包存储库，镜像了所有的Debian软件。
因此，如果您是MIT的Debian用户，您可以使用MIT的所有内容副本，然后通过我们快速的本地网络访问，这样流量根本不需要通过外部互联网，所以非常快速。
这是个好问题。
还有其他问题吗？好的，最后一个有趣的哈希函数应用是一种称为承诺方案的东西。
我想玩一个游戏，我需要一个志愿者。
所以你实际上不需要从座位上站起来什么的，我只需要你跟我交流一下。
有人愿意举手自愿吗？好的，你叫什么名字？Abdul Aziz？好的，太好了。
所以，Abdul Aziz，我们要玩一个游戏，我要掷一枚硬币，然后你要叫正面或反面，如果你猜对了，你就赢了，如果你猜错了，你就输了。
这个游戏没有任何利益关系，只是赢得荣誉。
不幸的是，我检查了一下我的钱包，只有美元，没有硬币。
所以，我只能在脑海中掷硬币。
好的，我掷硬币了，请你叫正面或反面。

很抱歉，你输了，是正面。
我可以作弊，对吧？我可以看到你说的并说相反的话。
所以让我们试着修正一下这个游戏。
如果我说翻转结果是正面或反面，你再猜，怎么样？好的，如果我说“结果是反面”，你会怎么猜？你会选反面？是的。
那么，我们是否可以在没有共享物理硬币的情况下公平地玩这个“猜硬币翻转结果”的游戏呢？因为我无法真正操纵你的物理现实。
如果我在你面前翻硬币，你可能会相信它是好的，对吧？所以，事实证明，哈希函数通过一种称为承诺方案的思想为我们提供了一种解决这个问题的很酷的方法。
因此，我可以说：“这里是解决方案的构造。
我可以选择正面或反面，实际上我要选择一个大的随机数，比如这个数，在这个时刻，你还没有看到这个数，我只是在脑海中做所有这些。
然后，我告诉你：“好的，我翻了个硬币，我现在不会告诉你结果，因为你还没有猜正面或反面，但我会告诉你结果的SHA-1摘要。
这是这个值。
现在，在此之后，你可以猜正面或反面了。
所以，你选什么？选正面。
那么，我可以向你揭示我的输入值，然后你可以进行交叉检查，对输入进行SHA-1摘要以验证输出是否与我之前所说的一样，然后我们可以找到一种将这些数字映射到正面或反面的方法。
所以，我可能事先同意偶数为正面，奇数为反面，这是一种修正游戏的方法。
所以，我们实际上可以在我们的脑海中玩这个游戏。
我可以选择一个值，但不向你透露该值，但我可以承诺该值。
因此，这是一种绑定承诺方案，我在告诉你之后无法改变主意，但不会向你透露原始值。
因此，这是加密哈希函数的另一个不错的应用。
对于这个特定的构造有任何问题吗？好的。
接下来，我们将讨论密钥派生函数，通常缩写为KDF。
这是一个与哈希函数非常相似的概念，除了它有一个额外的特性，即计算速度较慢。
举个例子，有一个被称为PBKDF2的哈希函数或密钥派生函数，它具有与我们在这里谈论的这些哈希函数类似的形式，它们接受某些可变长度的输入并生成固定长度的输出。

但它们通常被用于一特定目的。
这个目的通常是将固定长度的输出作为另一个密码算法中的密钥。
我们稍后将讨论这些算法，比如使用这个函数的输出的用途。
但这些东西的一个特性就是它们很慢。
有没有人知道为什么要让算法变慢？通常我们希望算法很快，对吧？那么为什么我们希望算法很慢呢？是的，没错，就是这个原因。
我重复一遍，这样话就可以被录音了。
你希望它变慢的原因是在实际使用它进行密码认证时。
你保存了密码的哈希值，然后有人输入密码，你想知道它是否与哈希值相对应。
它慢一些也没关系，因为你只需要进行这个检查一次。
但另一种使用这个函数的情况是当有人试图暴力破解密码时。
比如一个网站的密码数据库被盗，有人在尝试破解所有密码。
那么在这种情况下，你希望这个函数变慢，因为有人将要做这个操作数百万次。
通过使这个函数变慢，你可以大大减缓攻击者的速度。
所以，如果这需要一秒钟才能计算出这个函数，这也没关系。
但当你进行暴力破解时，我们不会像那个 XKCD 漫画中一样每秒尝试一千次。
我们可以让它慢一点。
那么密钥派生函数的输出实际上用于什么呢？好的，我们接下来要讨论的，可能是当你想到密码学时最经典的东西之一，就是加密和解密。
接下来的话题是对称密钥密码学。
就像这节课的其余部分一样，我们不会讨论如何实现它们，而是会讨论对称密钥密码学的 API，就是它们如何被使用。
对称密钥密码系统有几个不同的函数。
它们有一个密钥生成函数，这是一个随机函数，生成我们称之为密钥的东西。
然后它们有一对函数，加密和解密。
加密将我们所称的明文作为输入，这只是一些字节序列，一些数据。
它采用一个密钥，这是一个来自这个密钥生成函数的输出，然后产生我们所称的密文。

然后解密函数则是相反的过程。
它需要密文和密钥，产生明文。
这个三个函数有几个属性。
其中之一，就像你预期的一样，这个函数并没有告诉你加密输入的所有信息。
所以第一个属性是，只有在拥有密钥的情况下，你才能通过密文找出明文。
另一个属性是一种显而易见的正确性属性，即如果你使用密钥加密某个消息M，然后使用相同的密钥解密该密文，那么你将得到相同的消息。
这是一种显而易见的正确性属性。
这个描述听起来合理吗？它是否符合你对于将某些数据模糊化以便你无法知道原始输入的直觉理解，然后通过某个解密函数以该密钥来检索原始输入的理解呢？虽然这不是关于安全性的严格定义，但这是一个足够好的直观定义，我们可以使用它。
那么，这个描述有没有问题？对于对称密钥密码学的应用场景在哪里呢？我们将在这个讲座后面讲解许多例子，但现在我们讲解一个例子，即将文件加密以便存储在一个不受信任的云服务中。
考虑像Dropbox或Google Drive这样的服务，你上传文件并信任服务不会查看你的文件或者对其进行任何恶意操作。
这些服务至少在我列举的这些中并没有进行加密等操作。
理论上，这些公司的任何员工都可以查看你的文件。
当然，这些公司有许多政策和技术控制来确保这种情况不会发生，但这并不意味着它在技术上不可能发生。
如果你不想信任这些云服务，不想让他们窥视你的数据，或者进行其他你不想要的操作（比如进行机器学习），那么你可以在上传这些文件到网络服务之前对其进行加密。
那么这个想法有道理吗？我可以将我的文件（比如中心照片）通过一个加密函数，产生密文，然后将该密文安全地放置在网络服务上进行备份等操作，如果我需要该文件，我可以检索该密文，然后使用我的密钥将其解密回明文，然后将结果用于我需要做的任何操作。
这个想法有道理吗？是的，这是一个好问题。
问题是，任何人都可以通过相同的加密程序进行加密吗？或许我应该更详细地解释一下这个密钥生成函数是随机的，并且这个密钥具有高熵值。
回到我们之前讨论的主题，比如我们可能会使用AES-256。
这是一种特定的对称密码，它的名称可能暗示了它的密钥具有256位熵。
这意味着只要攻击者（即从网络服务下载密文的人）不知道你的密钥，除非他们有更好的攻击手段，否则他们将不得不尝试所有可能的密钥。
如果有2的256次方个密钥，那么在合理的时间内尝试所有密钥是不可能的。
这回答了你的问题吗？
好的，还有其他问题吗？这是一个很好的问题，也引出了我接下来要谈论的话题。
所以感谢你的提问。
正如你所指出的，如果我丢了我的密钥，我就有点卡住了，对吧？我需要我的密钥来解密。
这就是这个东西的重点。
如果我不需要我的密钥来解密，那么这个加密系统就不会很好。
所以我可以将这个对称密钥加密的想法与我们刚才谈论的密钥派生函数相结合。
因此，我不再使用一些通过密钥生成函数随机生成的密钥，例如从计算机中的某个位置获取熵，而是使用一个口令，并将其通过我的密钥派生函数处理后得到我的密钥。
然后，我可以将我的明文和密钥结合在我的加密函数中，从而产生我的密文。
我将这个密文存储在网络服务上，但现在我不需要保存这个密钥了。
相反，我只需要记住我的口令，每当我需要我的密钥时，我就可以从密钥派生函数中重新构建它。
问题：是的，这是一个好问题。
问题是，密钥派生函数是否足够慢，以防止暴力破解？答案是，这取决于你的口令有多长。
例如，如果你的口令像字符串“password”一样简单，那么它很可能会很快被破解。
但只要你的口令中有足够的熵，就足够了。
所以，例如，如果我要上传一些文件到Dropbox，我真的希望它保持机密性，那么一个64位口令，真正具有64位熵的口令，在这种情况下将足够安全。
这里还有一个快速演示：有一些工具可以让这个过程变得非常容易。
实际上，这是其中一个练习，但我们可以使用一个名为OpenSSL的工具，将对称密码应用于某个文件。
例如，我有我的readme文本，readme.md。
它里面有很多东西，我可以做“openssl aes 256 cbc”，这是一个特定的对称密码的名称，然后我可以说我要将它应用于readme.md，并产生“readme.encrypted.md”，让我们给它起一个名字，然后它会要求你输入一个密码。
所以，默认情况下，它是在这种模式下工作的，我提供一个口令，它经过KDF处理后生成一个密钥，然后用于加密。
所以，我会输入一些密码，再输入一遍，然后现在我会生成这个readme.encrypted.md文件。
如果我查看这个文件，它看起来像垃圾一样，但这正是对称加密的重点。
它产生了一些密文，应该与随机数据难以区分。

当我想要解密这个文件时，我可以运行类似的命令：“openssl aes 256 cbc -d”，表示解密，以readme.encrypted.md作为输入，并将readme.decrypted.md作为输出。
我可以比较这两个文件，对称加密的正确性属性告诉我这应该是相同的。
确实如此。
如果我查看返回值，比较返回值为0，这意味着它们是相同的文件。
【掌声】所以，关于对称密钥密码学的问题，有什么问题吗？是的，这个特定的命令确实创建了一个新文件，所以它将我们的输入readme.md并产生了这个文件作为输出，这就是该文件的加密版本。
它并没有改变原始文件，但是我可以删除它，如果我想的话。
是的，这是一个很好的问题。
这是我不会详细讨论的东西。
问题是，我在这里提供了盐值参数，那么它存储在哪里？答案是，它存储在这里的输出中。
因此，此输出格式存储盐值和实际的输出密文，因此可以用于重构和解密。
是的，没错。
它不保留任何数据库或其他东西。
它是完全自包含的。
是的，正如John所说，盐并不是密码，密码短语才是这里的秘密。
好的，让我们回到问题。
什么是盐？在哈希函数的背景下，加密盐的概念可能最好解释。
哈希函数的一个常见应用是在密码数据库中存储密码。
如果我有一个网站，并且有用户的登录，像人们用他们的用户名和密码登录，我实际上不想以纯文本形式存储人们的密码。
有人知道我为什么不想这样做吗？是的，确切地说，如果出现违规行为，有人获取了您的所有数据，那会怎么样呢？所以，如果泄漏了所有用户的密码，那就真的很糟糕。
特别是因为许多人在不同的网站上重复使用他们的密码。
因此，您会看到攻击者侵入一个网站，例如，一段时间前曾经有一个大规模的雅虎泄漏事件，他们发现了所有这些用户名和密码，然后他们试图在Google、Facebook和YouTube等网站上使用这些相同的登录凭证。
这些人重复使用密码，因此不要存储明文密码。
因此，您应该使用哈希函数或理想情况下是故意设计成缓慢的密码哈希函数来存储散列密码。
一旦攻击者意识到人们开始存储散列密码，他们开始构建称为彩虹表的东西。

人们开始意识到人们开始存储哈希密码之后，攻击者开始做的一件事情就是构建所谓的“彩虹表”。
他们采用了一种生成大型密码列表的方法，例如，这些密码的模式是什么样子的。
例如，获取所有字典单词，获取所有长度为零到八的字符串等等，然后对它们进行哈希，并生成一个将哈希映射回它们的原像的大型数据库。
因此，鉴于哈希函数的输出，您可以直接在这个数据库中查找“哦，与此输出相对应的输入是什么？”人们已经为相当大的密码数据库构建了这些工具。
因此，您可以作为一种防御措施采取的一件事是，不仅要在数据库中存储密码的哈希值，而且要计算所谓的“盐值”。
这是一个大的随机字符串。
然后，您将存储在密码数据库中的是盐，它不是真正的秘密，您可以将其与附加到其后的密码哈希值一起存储在密码数据库中。
这有什么用处呢？这种盐是每个用户的随机唯一值。
因此，如果有人在一个网络服务上使用密码“safe password one two three”，如果您只存储密码的哈希值，则哈希在两个网络服务上都是相同的，对吗？因为这个哈希函数是一个确定性函数。
但是，现在，由于我们使用了这个随机化的盐值，我们存储了密码哈希值加上盐。
因此，即使某些人在多个网站上使用相同的密码，这个东西在两种情况下看起来都不同。
它使这些大型数据库，将这些短密码或哈希输出映射回它们来自的短密码，不再有用。
当您拥有盐味密码时，您需要为每个用户执行暴力攻击一次，一旦找到他们的盐值，就不能再使用这个大型预先计算的数据库了。
这回答了什么是盐的问题吗？那么，这个盐参数就是与之相关的。
看看，我们谈论过的任何问题吗？好的，那么我要抹去这个，然后我们最后要谈论的是密码学中最令人兴奋的发展之一。
它发生在相当长的时间以前，但仍然是一个非常酷的概念，称为对称密钥密码学。
这实际上是一种想法，使今天您使用的任何安全性和隐私相关功能都成为可能，例如，当您需要输入www.google.com/mapmaker时，密码学会作为其中的一部分。
这看起来与对称密钥密码学所讲的非常相似，但有一个区别。
有一个密钥生成函数，同样是随机的，但不是生成单个密钥，而是生成一对密钥，其中一个被称为公钥，另一个被称为私钥。
然后可以使用它们进行加密和解密，方式与对称密钥密码学类似，但这些不同的密钥现在具有不同的用途。
因此，我们有一个加密函数，它接受明文（我在这里写成P），并且接受公钥，并产生密文。
然后我有一个解密函数，它接受我的密文和私钥，并将明文还原回来。
与前面所讲的两个属性类似，仅凭密文，我们无法解密出明文，除非我们有私钥。

然后，我们有一个明显的正确性属性，如果我们用公钥加密某些东西，然后拿着那个密文尝试用相应的私钥来解密，输出两个不同的东西，那么最终我将得到相同的结果。
所以这非常类似于上面所说的，但有一个扭曲的地方，我们有两个具有不同功能的不同密钥。
这个公钥实际上可以被制作成公开的，这很棒，正如名称所示，任何人都可以在互联网上使用类似的加密系统，发布一个公钥供任何人查看，但保持私钥的机密性。
然后我有了这个有趣的属性，任何人都可以使用我的公钥加密任何内容并通过互联网将其发送给我。
然后我可以使用我的私钥解密它，只要我的私钥保持机密，我的公钥对于任何人都可以使用是无关紧要的。
这就是不对称性的来源所在。
之前，我们处于这样一种情况，假设我在互联网上，但你没有和我面对面交谈，你想通过一些未加密的频道将数据发送给我，并且你想使用对称密钥加密。
我们需要一种方式事先交换密钥，以便您可以使用密钥加密一些纯文本，并将那个密文传输给我，以便我可以使用该密钥解密它。
在对称密钥加密中，如果密钥是公开的，那么游戏就结束了，任何人都可以解密你的东西。
而在非对称密钥加密中，我可以拿出我的公钥并将其张贴在互联网上的公告板上，您可以查看并使用一些内容来加密它们，然后发送它们，这将是完全可以的，您只能使用私钥来解密它。
所以一个有用的比喻是将这些数学思想与物理锁进行比较。
你的房门可能有一个锁,你可以用钥匙将其旋转以锁门或旋转另一个方向以解锁门。
因此，有一把单一的钥匙，它既可以锁门也可以解锁门。
但现在考虑这种替代构造，如果我想让你能够向我发送一条消息并通过互联网发送，而且你和我之间不需要交换钥匙的方式。
我可以买一个盒子，你可以把信放在里面，然后你可以关上盒子。
我可以买一个锁眼，我可以打开锁眼并把它给你。
你可以在自己方便的时候把你的信息放在盒子里，然后拿起这个打开的锁眼，把它固定在盒子周围，然后将其发送给我。
然后我可以用我的钥匙打开它。
所以你能看到这种不对称性，与我用来打开我家门的钥匙不同，同一把钥匙可以开关门。
相反，我给你这个打开的锁眼，你有能力关闭它但无法打开它。
在你关闭它之后，我可以使用我保密的钥匙来打开它并取出里面的东西。
也许这个比喻有帮助，也许没有。
数学构造如果适合你，那么它就可以工作得很好。

关于对称密钥加密和解密以及它与对称密钥加密的关系有什么问题吗？在我们讨论这个想法的应用之前，我将谈论对称密钥密码学中的另一组概念。
这些加密系统为您提供了另一组与加密和解密相关的工具，称为签名和验证。
这在某种程度上类似于现实世界，我可以得到一份文件并用我的签名签署它。
除了现实世界的签名相对容易伪造外，这些签名是相当难伪造的，因此更有用。
签名方案是什么样子的？有一个函数sign，它需要一些消息和私钥，注意这是私钥，而不是公钥，它会生成一个签名。
然后还有另一个函数verify，它接收消息、签名和这次是公钥，它会返回一个布尔值，告诉我签名是否正确。
然后这一对函数具有以下性质，这些性质是从物理签名直觉中产生的，即如果没有私钥，很难为任何消息产生一个签名，使得您可以将消息和签名以及公钥提供给verify函数以使其返回true。
在高层次上，它很难被伪造。
当然，没有私钥是很难伪造签名的。
然后有明显的正确性属性，如果您使用公钥签署了一个东西，然后尝试使用相应的私钥进行验证，它将返回一个好的验证结果。
因此，这是不对称密钥加密系统可以做的两种不同的事情。
您可能听说过的不对称密钥加密系统的例子是RSA。
RSA由许多人设计，其中一人是罗恩·里维斯特(Ron Rivest)，他是这里的教授。
实际上有很多很有趣的不对称密钥加密应用，您可能需要花上几天时间来谈论这些应用，但其中一些例子是电子邮件加密。
我们谈到了发送消息的一些事情。
通过不对称密钥加密，您可以在网上发布公钥。
我认为一些教练在他们的网站上发布了PGP公钥。
例如，如果您访问我的网站或John的网站，您将找到一个公钥。
然后您可以发送给我们一个加密的电子邮件。
即使该消息通过Gmail或其他电子邮件服务传递到我的T的邮件服务器，如果有攻击者窥探消息，他们也无法理解其内容，因为它们都被加密了。
这非常酷，因为你可以不需要亲自见面交换密钥，而是可以在网上找到我们的公钥，然后发送加密邮件给我们。
这个过程在对称密钥系统中可能需要更多的交换。
此外，非对称密钥加密还可以用于私人通信。

举手如果你使用过类似信号或电报或者WhatsApp的应用程序，这些私人通信应用程序也使用非对称加密技术建立私人通信渠道。
基本上，每个人都与之相关联的都是一对密钥，因此你的设备已运行密钥生成功能并生成了一个公钥和一个私钥，自动将你的公钥发布到互联网上。
例如，如果你使用信号，你的公钥就在信号服务器上，当有人想要联系你时，他们的手机可以查找你的公钥，检索它，一旦检索到你的公钥，他们就可以为你加密信息。
这是他们算法的一种近似方式，但从高层次来看，这就是正在发生的事情。
非对称密钥密码的另一个有趣应用是我们之前谈到的，就是确保你从互联网上下载了正确的软件。
非对称密钥密码可用于签署软件发布，这是一些人们为了确保从互联网上下载的软件是来自正确的人所做的事情。
开发人员会尝试签署他们的软件，以便你可以确保从互联网上下载的任何东西都是来自正确的人所发出的。
我们在git的讲座中谈到了你可以使用git做的所有有趣的事情。
我们没有涉及的是git中签名相关的功能。
所以git有提交，你可以将一些东西与提交关联起来，这被称为标签。
从高层次上看，你基本上可以将一个git提交与一个签名相关联，将你的公钥绑定到此提交中，然后任何拥有你的公钥的人都可以使用提交和你的公钥，以确保提交上有一个合法的签名。
让我去我的一个随机存储库看一下。
我可以查看与存储库相关联的一些标签。
如果我查看与该标签相关联的原始数据，它具有一些元数据，然后是一段ascii编码的信息块，我可以使用“git tag -v4 verify”命令，以确保哦，这是一个好的签名来自这个人碰巧是我，所以我签署了软件发布，这样任何从互联网下载软件的人都可以确保他们实际上得到了真实的副本。
是的，问题。
所以问题是验证函数具体是在做什么或者它检查什么？如果你想数学上了解具体是什么，可以在本讲座之后找我交流。

从 API 的角度来看，这里的签名和消息只是一组字节数据。
这些数据的设计基本上是这样的：对于某个特定的公钥，比如我的公钥，如果你没有我的私钥，就不可能找到第二个参数使函数返回 true。
你可以将它类比为签署一份文件。
就像你不知道如何伪造我的签名一样，我可以在任何纸张上签名，然后任何知道我的签名样式的人，可以查看我的文件，验证签名正确。
但没有私钥的人无法为任何特定消息产生一个使此函数返回 true 的签名。
有任何相关的问题吗？我是否需要以其他方式解释，或者这讲得通？那么对于软件签名或对称密钥加密中讨论的其他几种应用程序，有什么问题吗？好的，最后我想谈谈密钥分发。
这是非对称密钥加密的一个有趣的副作用。
它可以实现许多有趣的功能，比如我可以在互联网上发布我的公钥，你可以找到它并给我发加密邮件。
但你怎么知道找到的公钥实际上是我的公钥？这似乎存在一个引导问题，对吗？所以，你可能会采取几种不同的方法来解决这个问题。
一种是有点糟糕的解决方案，但它可以解决许多密码学问题。
这种方法是在带外交换信息，也就是你想给我发加密邮件，我们在下课后就直接谈，我会给你一张纸条上面写着我的公钥，由于你亲自与我交谈，你知道这确实是我的公钥，而不仅仅是有人黑进我的网站，放上一些随机数。
这样可以解决问题，但不太优雅。
还有几种不同的方法，不同的应用程序使用不同的方法。
所以，使用 Signal 的人们，你们有没有遇到过"安全号码"这个短语？对于 Signal，他们有一种交换公钥的方法，就是通过 Signal 服务器。
运行 Signal 服务的人只需在其服务器上维护一个从电话号码到公钥的映射。
当我说"我要给这个号码的人发消息"时，我的手机会从互联网上检索他们的公钥，然后为该公钥加密消息。
现在，有人看到这个设置有什么问题吗？是的，正是如此。
 Signal 服务器是一个故障点，因为如果 Signal 服务器给我错误的公钥，比如假设 Signal 只是生成了一对新的密钥并给我他们的公钥，现在他们可以读取我所有的消息，他们甚至可以坐在我和我的朋友之间，透明地解密我发送给他们的消息，然后重新加密并发送到最终目的地。
基本上，我需要某种方法来验证我获得的公钥，因此 Signal 有一个解决方案，也只是将问题推给了带外密钥交换。
你可以和某个人见面，他们有一个稍微精简的流程，在屏幕上显示 QR 码，你拿一部手机拍摄另一部手机屏幕的照片，反之亦然，现在你已经在人面前交换了公钥，从那时起。
如果你没有我的私钥，任何消息都无法找到使该函数返回true的第二个参数。

这有点像签署一份文件。
就像你不知道如何伪造我的签名。
我可以在任何一张纸上签名，然后任何知道我的签名长相的人都可以查看我的文件，你可以说：“是的，这个签名是真的”。
但是除了拥有私钥的人，没有人能够为任何特定的消息提供第二个参数，使得这个函数返回真。
如果还有相关的问题需要解释，或者有其他的解释方式，或者这样解释是否有意义？那么，对于任何有关签署软件或非对称密钥加密等少数应用程序的问题，您有没有任何问题？好吧，最后我想谈论的是密钥分发。
这是非对称密钥密码学的一种有趣的副作用。
它使许多有趣的功能成为可能，例如，我可以在互联网上发布我的公钥。
你可以去找到它并给我发送加密邮件。
但是，你怎么知道找到的公钥实际上是我的公钥呢？似乎这里有一个引导问题，对吧？因此，你可能会采取几种不同的方法来解决这个问题。
其中一种是有点糟糕的解决方案，但这个东西解决了许多加密问题，那就是通过离线信息交换。
这意味着，如果你想给我发送加密邮件，我们只需要在课后和我谈谈。
我会在一张纸上给你我的公钥，因为你是亲自和我交谈的，所以你知道这实际上是我的公钥，而不仅仅是有人入侵了我的网站并贴上了一些随机数字。
这解决了问题，但不是最优雅的方法。
有几种其他方法是不同的应用程序使用的。
所以，你们中使用Signal的人，你们是否遇到过“安全号码”这个短语，比如“验证你的安全号码与某某人”？那么，对于Signal来说，他们有一种交换公钥的方式是通过Signal服务器。
运行Signal服务的人只是在他们的服务器上维护了一个从电话号码到公钥的映射。
当我说：“哦，我想用这个号码给这个人发消息”，我的手机就会去互联网上检索他们的公钥，然后为那个公钥加密消息。
现在，有没有人看到设置的问题？是的，完全正确。
信号服务器是失败的瓶颈，因为如果信号服务器提供给我的公钥不正确，例如，假设信号服务器生成了新的密钥对并给我他们的公钥，现在他们可以读取我所有的消息。
他们甚至可以坐在中间透明地解密我发送的消息，然后重新加密并发送到最终目的地。
基本上，我需要一种认证我得到的公钥的方式。
因此，信号有一个解决方案，也是将问题推给线下密钥交换的方法。
你可以与某个人见面，他们有一个稍微简化的流程，可以在屏幕上显示QR码。
你拿一部手机拍下另一部手机屏幕的图片，反之亦然，现在你已经在人面前交换了公钥。
从那时起，你已经启动了加密的端对端通信。
它还有一个问题或方法，即固定公钥。
一旦你知道一个特定的电话号码有一个特定的公钥，你的手机就会记住它，如果发生更改，它就会向你发出警告。

然后还有几个解决这个问题的方法。
PGP是一个曾经流行过的解决方案，它有一个信任网络的概念。
就像，我信任我朋友信任的人。
所以如果约翰和我的教授进行了一次超出带宽的交流，那么我可以向我的教授发送电子邮件，因为我知道约翰信任我的教授，我信任约翰。
所以你可以通过这种方式建立信任链。
这是一种有趣的方法。
还有另一种模型，叫做最近出现的一种工具叫做key base，这是一个非常好的...哎呀，有一个叫做keybase.io的网站，他们有一个非常有趣的解决方案，叫做社会证明。
比如说，你可能在Facebook和Twitter上有你的朋友，攻击者很难同时入侵你朋友的Facebook账号、Twitter账号以及Hacker News账号等等。
因此，有一种有趣的方式，将公钥绑定到一组社交身份上，这样一旦你信任与你朋友相应的社交身份数量，就可以检索到公钥。
如果你想要更详细地了解这些内容，我们在讲义中提供了链接。
这就是我们的安全和密码学讲座，明天的讲座将涉及到一些你的教练们认为有趣的话题。
希望明天在讲座上见到你们。
如果有任何问题，我会在课后呆上几分钟。
好的，约翰，如果你要离开，随意离开，但我想没有人在我们之后使用这个教室。
我要谈论另一个有趣的话题。
约翰提出了非对称密钥加密速度慢，对称密钥加密速度快的事实。
因此，在实践中，你不会仅仅使用对称密钥加密。
通常情况下，它用于引导你正在使用的更复杂的协议。
你可能想使用对称密钥加密来签名加密邮件，对吧？我们已经讲过了这个例子。
实际上的工作原理并不像我们对非对称密钥加密的简单解释所猜测的那样。
你不能只是使用上面的加密函数就结束了。
在实践中，你使用混合加密来使用对称密钥和非对称密钥加密的组合。
你所要做的是使用混合加密技术，结合对称密钥和非对称密钥加密。
这里，我会画一个大的块状图。
你需要先取出你要发送的信息M，然后使用我所拥有的公钥进行加密。
但是，与其将这两个信息直接通过上述加密函数加密，实际上，你需要使用对称密钥生成函数来产生一个对称密钥。

好的，我会在开头加上“对称”这个词，以便我们可以将其与公钥密钥生成函数区分开来。
然后我将这两个东西通过对称加密传递给我的加密盒子。
这将产生密文，现在将其发送到接收者那里。
抱歉，这个加密后的内容对接收者来说并没有什么用处，因为它是使用本地计算机上运行的函数产生的密钥K进行对称加密的。
因此，我需要某种方式将此传递给实际上用于解密邮件的人。
因此，我将此内容拿出来，而且可能这个邮件很大，所以我使用对称加密将其加密。
但是这个密钥很小，可能只有256位，所以我可以使用公钥进行对称加密，这样就可以生成一个加密密钥。
使用相应的私钥解密该密钥，就可以重构它。
这是在发送者端进行的。
现在，接收者获得这个密钥，将其倒序进行以下步骤：首先使用非对称解密使用对应于所发布的公钥的私钥重构用于对称加密盒子的密钥，然后使用该密钥进行对称密钥解密，以获取原始消息。
因此，这是对称和非对称密钥加密如何在实践中结合的有趣示例。
问题：那么问题是，你会使用相同的对称密钥生成器吗？是的。
因此，您需要事先协商在此处使用哪个盒子。
例如，您可能会说，我将在这里使用AES 256 GC，但这是一个众所周知的函数，它是公开的。
攻击者可以知道此函数的所有参数。
这是攻击者不知道的唯一秘密。
其他问题吗？是的，那是一个非常好的问题。
什么样的数据值得加密？我认为这取决于您的威胁模型。
你关心什么样的攻击者？你想保护什么？因此，您可能认为您根本不在意，并且您与任何人的通信都可以公开。
我可能愿意将我与每个人的所有对话公开发布到互联网上供所有人查看。
另一方面，也许你正在从事一些类似安全敏感的工作，为美国政府签订合同，开发一些敏感军事项目。
如果你在旅行中通过公共互联网发送这些信息，你可能希望非常确定没有窃听者或其他人能够看到你发送的内容，并且你发送的信息确实到达了正确的位置，并且接收方能够验证该信息确实来自你。
因此，根据你的情况，你可能会担心各种不同类型的对手，从试图破解网站的随意的脚本小子到国家级攻击者，你需要不同类型的技术来防御不同类别的攻击者。
还有其他问题吗？好的，希望明天能看到一些对于 John、Jose 和我感兴趣的随机的事物的集合。
