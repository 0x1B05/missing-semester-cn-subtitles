欢迎回来。
今天我们将涵盖调试和分析。
在我开始之前，我们将再次提醒您填写调查问卷。
我们想从您那里得到的主要问题之一是：在最后一天，我们会回答来自您们的问题，包括我们没有涉及到的问题或者您希望我们深入讨论的问题。
我们获得的问题越多，我们就可以让这一部分更加有趣，请您填写调查问卷。
今天的讲座将涵盖很多主题。
所有主题都围绕着一个概念展开：当您的程序存在错误时，您应该怎么做。
在编程时，您大部分时间都在考虑如何实现某些功能，但是修复程序中的所有问题需要花费很长时间。
即使您的程序按照您的预期运行，它可能也会非常缓慢，或者占用很多资源。
今天我们将看到许多不同的解决这些问题的方法。
首先，第一部分是关于调试的。
调试可以有许多不同的方法，有各种各样的方式...几乎所有计算机科学学生都将使用的最简单的方法就是：您有一些代码，它的行为不符合您的预期，所以您通过添加打印语句来探索代码。
这被称为“printf调试”，它运行得非常好。
老实说，我经常使用它，因为设置简单，反馈快。
printf调试的一个问题是您可能会获得大量输出，而您可能并不希望获得这么多输出。
人们已经考虑了稍微复杂一些的printf调试方法之一，即通常称为“日志记录”。
与printf调试相比，使用日志记录的优点在于，当您创建日志记录时，您并不一定是因为要修复特定的问题，而是因为您构建了一个更复杂的软件系统，并且想在某些事件发生时记录下来。
使用日志记录库的一个核心优点是您可以定义严重性级别，并且可以根据这些级别进行过滤。
让我们看一个如何实现这样一个示例。
是的，一切都符合预期。
这是一个非常愚蠢的例子：我们将随机抽取一些数字，并根据数字的值（可以解释为“错误程度”）记录数字的值，然后我们可以看看发生了什么。
我需要禁用这些格式化程序...如果我们按原样执行代码，我们只会得到输出并且不断获得更多的输出。

但是你必须盯着它看，并理解正在发生的事情。
我们不知道printf之间的相对时间，也不知道这是仅仅是一条信息消息还是有错误发生的消息。
如果我们进去，然后撤销，不是那个...就是那个，我们可以设置格式化程序。
现在输出看起来更像是这样：例如，如果你正在使用多个不同的模块进行编程，你可以使用不同的级别来标识它们。
这里，我们有调试级别、关键信息、不同级别。
这可能很方便，因为我们可能只关心错误消息。
就像那些...我们一直在编写代码，到目前为止一切顺利，突然出现了一些错误。
我们可以记录下来以确定它发生在哪里。
但是也许有很多信息消息，但我们可以通过将级别更改为错误级别来处理它们。
现在，如果我们再次运行它，我们只会在输出中得到那些错误，我们只需浏览它们以理解正在发生的事情。
当你处理日志时，另一个非常有用的工具是......随着你的观察，它变得更容易了，因为现在我们有了可以快速识别的关键和错误级别。
但由于人类是相当视觉化的生物，你可以使用终端中的颜色来识别这些内容。
所以现在，改变格式化程序，我稍微改变了输出的格式。
当我这样做时，现在每当我收到一个警告消息时，它是用黄色编码的；每当我收到像错误一样的消息时，它是模糊的红色；当它是关键的时候，我有一个加粗的红色，表示有错误发生了。
在这里，输出非常短，但是当你开始有成千上万行的日志时，这并不是不切实际的，而且在许多应用程序中每天都会发生，快速浏览并确定错误或红色区域的位置可以非常有用。
一个快速的旁注是，你可能会好奇终端是如何显示这些颜色的。
归根结底，终端只输出字符。

这个程序，还有像LS这样的其他程序，它们都有很多花哨的颜色，那么它们是如何告诉终端使用这些不同的颜色的呢？其实这些工具所做的事情并不是非常复杂，大致上是这样的。
这里有……我可以清除其余的输出，这样我们就可以专注于这个问题。
这里有一些特殊字符，一些转义字符，然后是一些文本，最后是一些其他特殊字符。
如果我们执行这行代码，我们就会得到一个红色的"This is red"。
你可能已经注意到了，我们这里有一个"255;0;0"，这只是告诉终端我们想要的颜色的RGB值。
你几乎可以在你任何的代码中做到这一点，这样你就可以给输出编码颜色了。
你的终端相当花哨，并支持输出许多不同的颜色。
这还不是全部，只有十六分之一。
我认为了解这个可能非常有用。
另一个问题是，也许你不喜欢或者觉得日志不适合你。
但问题是，许多其他系统可能会使用日志。
随着你构建越来越大的系统，你可能会依赖于其他依赖项。
常见的依赖项可能是Web服务器或数据库，这是非常常见的。
它们会在自己的日志中记录它们的错误或异常。
当然，你会收到一些客户端错误，但有时候这些错误信息并不足以让你弄清楚发生了什么。
在大多数UNIX系统中，日志通常放在一个名为"/var/log"的文件夹下，如果我们列出它，我们就可以看到这里有很多日志。
所以我们有像关机监视器日志或一些周报告，例如与Wi-Fi相关的事情。
如果我们输出系统日志，其中包含了很多关于系统的信息，我们就可以得到关于正在发生的事情的信息。
同样，有一些工具可以让你更好地查看这个输出。
但是在这里，我可以查看系统日志，并说：哦，有一些服务以异常代码退出了，基于这些信息，我可以去尝试弄清楚发生了什么，发生了什么错误。
当你使用日志时需要知道的一件事是，更传统的是，每个软件都有自己的日志，
比起过去，现在越来越流行将所有日志放入统一的系统日志中。
几乎任何应用程序都可以记录进系统日志，但它们不是以普通文本格式存储，而是以某种特殊格式进行压缩。
我们在数据整理讲座中就讲到过一个例子，那就是我们使用的 "journalctl"，它可以访问日志并输出所有输出。
在Mac上，现在使用的命令是 "log show"，它会显示大量信息。
我只会显示最近的十秒钟，因为日志非常冗长，仅仅显示最近10秒钟仍然会输出相当大量的行。
如果我们回顾一下正在发生的事情，我们会发现有很多苹果产品正在运行，因为这是一台MacBook。
也许我们能在这里找到一些关于系统问题的错误。
再说一遍，它们相当冗长，所以你可能需要练习你的数据整理技巧，例如10秒钟相当于大约500行日志，所以你可以大概知道每秒钟有多少行。
它们不仅可以用于解析其他程序的输出，也可以用于您自己的日志记录。
因此，使用 "logger" 命令，在Linux和Mac中，您可以说，好的，我要将 "Hello Logs" 记录在此系统日志中。
我们执行该命令，然后可以通过查看最近一分钟的日志来检查，因为它会非常近，然后通过grep搜索 "Hello" 来找到我们的条目。
我们发现最近创建的条目，显示了 "Hello Logs"。
随着您越来越熟悉这些工具，您会发现自己越来越经常使用日志，因为即使您有一些错误，而且程序已经运行了一段时间，也许信息已经在日志中，可以告诉您足够的信息来找出问题所在。
然而，printf调试并不是万能的。
现在我要介绍调试器。
但首先，有关日志的任何问题吗？那么您可以从日志中了解到什么样的信息？像这个 "Hello Logs" 就表明在那个时间你执行了一些关于Hello的操作吗？是的，例如，我可以编写一个Bash脚本来检测... 每次检查我连接到哪个Wi-Fi网络。
每次它检测到网络已更改，它就会在日志中创建一个条目，并说：哦，现在看起来我们已经更换了Wi-Fi网络。

然后你可以回过头来解析日志，比如：“好的，我的电脑是何时从一个Wi-Fi网络切换到另一个网络的？”这只是一个简单的例子，但这里有许多许多类型的信息可以被记录。
更普遍的情况是，你可能想要检查你的电脑是否因为某些未知原因进入了睡眠状态，比如它处于休眠模式。
日志中可能有一些信息说明是谁要求它进入睡眠状态，或者为什么会发生这种情况。
还有其他问题吗？好的。
所以当printf调试不够用时，最好的替代方法是使用……（退出）使用调试器。
调试器是一种工具，它将包装你的代码并让你运行代码，但它会对其进行控制。
因此，它将允许你逐步执行代码并设置断点。
如果你曾经使用过类似IDE这样的工具，你可能已经以某种方式看到过调试器，因为IDE具有这种花哨的功能：在这里设置断点，执行……但是归根结底，这些工具使用的只是命令行调试器，并且它们只是以一种非常花哨的格式呈现它们。
在这里，我们有一个完全损坏的冒泡排序算法。
不用担心细节，但我们只是想要对这里的数组进行排序。
我们可以尝试通过执行Python bubble.py来做到这一点。
当我们这样做时……哦，出现了一些索引错误，列表索引超出范围。
我们可以开始添加打印输出，但如果字符串很长，我们可能会得到很多信息。
那么，我们如何回到崩溃时刻呢？我们可以回到那个时刻并检查程序的当前状态。
所以，为了做到这一点，我将使用Python调试器来运行程序。
在这里，我技术上使用的是ipython调试器，因为它具有漂亮的语法着色，所以对于我们两个来说更容易理解输出中正在发生的事情。
但它们基本上是相同的。
我们执行这个，现在我们得到一个提示，告诉我们我们在程序的第一行。

我们可以...... "L"代表"List"，所以和许多这样的工具一样，有一种操作语言，它们通常是助记符，就像VIM或TMUX一样。
所以在这里，“L”是为了“列出”代码，我们可以看到整个代码。
 "S"代表"Step"，它可以让我们逐行执行代码。
问题是，我们只有在某段时间后才会触发错误。
所以我们可以重新启动程序，而不是尝试一步步走到错误处，我们可以只要求程序继续运行，即“C”命令，然后我们就到了问题所在。
我们到达了这一行，一切都崩溃了，我们得到了这个“list index out of range”错误。
现在我们可以说，嗯？好的，首先，让我们打印数组的值。
这是当前数组的值，所以我们有六个项。
好的。
这里“J”的值是多少？所以我们查看“J”的值。
“J”在这里是5，这将是最后一个元素，但“J”加1将是6，所以这触发了越界错误。
所以我们要做的是，这个“N”，不是“N”，而是“N减1”。
我们已经确定错误出现在这里。
所以我们可以退出，也就是“Q”。
再次，因为它是一个事后调试器。
我们回到代码并说好的，我们需要添加这个“N减1”。
这将防止列表索引超出范围，如果我们再次运行此代码而不使用调试器，好的，现在没有错误了。
但是这不是我们排序后的列表。
这是排序的，但不是我们的列表。
我们缺少列表中的某些条目，所以我们在这里遇到了一些行为问题。
再次，我们可以开始使用printf调试，但现在有一种预感，可能我们在冒泡排序程序中交换条目的方式是错误的。
我们可以使用调试器来解决这个问题。
我们可以逐步进行交换操作，并检查交换是如何执行的。
简单概述一下，我们有两个for循环，在最嵌套的循环中，我们检查数组是否大于另一个数组。
问题是，如果我们只试图执行到这一行，它只会在我们进行交换时触发。

所以我们可以在第六行设置一个断点。
我们可以在这一行创建一个断点，程序执行到尝试交换变量时，程序就会停止。
所以我们在那里创建一个断点，然后继续执行程序。
程序停止，并说“嘿，我已经执行并到达这一行了”。
现在我们可以使用“locals()”函数，它返回一个包含所有值的字典，以便快速查看整个上下文。
字符串和数组都没问题，而且数组有6个元素，这只是一个开端。
我继续执行下一行，哦，我找到了问题：我只交换了一个变量，而不是同时交换，这就是我们逐渐丢失变量的原因。
这只是一个非常简单的例子，但调试器非常强大。
大多数编程语言都提供一些调试器，当你进行更低级别的调试时，你可能会遇到像GDB这样的工具。
你可能想使用类似于GDB这样的工具。
 GDB非常适用于C/C++和所有这些类似C的语言。
但是GDB实际上可以让您使用几乎任何可执行的二进制文件。
例如，在这里，我们有一个sleep程序，它只是一个将休眠20秒的程序。
它被加载，然后我们可以运行它，并通过发送中断信号来中断它。
GDB正在为我们显示程序中发生的非常低级别的信息。
因此，我们正在获取堆栈跟踪，我们可以看到我们在这个nanosleep函数中，我们可以看到机器上所有硬件寄存器的值。
因此，您可以使用这些工具获取许多低级别的详细信息。
我想这就是我想介绍调试器的所有内容了。
是否有相关的问题？调试时另一个有趣的工具是，有时您想调试的方式就像您的程序是一个黑盒子。
因此，您可能知道程序的内部，但同时，您的计算机也知道程序何时尝试执行某些操作。
因此，在UNIX系统中，有这样一个概念，即用户级代码和内核级代码。
当您尝试执行一些操作，例如读取文件或读取网络连接时，您将不得不执行称为系统调用的操作。

你可以获取一个程序并查看其操作,询问此软件执行了哪些操作？例如，如果你有一个只应执行数学运算的Python函数，并将其运行通过此程序，却发现它实际上在读取文件，这是为什么？它不应该读取文件。
那么，我们可以使用"strace"这个工具。
例如，我们可以这样做。
我们将运行"LS - L"命令，忽略LS的输出，但不忽略STRACE的输出。
如果我们执行它，我们将得到大量输出。
这是所有不同系统调用，这个LS命令已执行的调用。
你会看到很多OPEN调用，你会看到FSTAT。
例如，因为它必须列出在此文件夹中的所有文件的属性，我们可以检查LSTAT调用。
因此，LSTAT调用将检查文件的属性，我们可以看到，实际上所有在此目录中的文件和文件夹都是通过LS系统调用进行访问的。
有趣的是，有时你实际上不需要运行代码就可以找出代码中的问题。
到目前为止，我们已经看到了足够多的通过运行代码来识别问题的方式，但如果你像这个屏幕上显示的代码一样看着一段代码，你也可以找到一个问题。
例如，这里我们有一些非常愚蠢的代码。
它定义了一个函数，打印几个变量，乘以一些变量，然后等待一段时间，然后我们尝试打印BAZ。
你可以试着看这个代码，然后说，“BAZ从未在任何地方定义过。
这是一个新的变量。
你可能想说BAR但你打错了。
问题是，如果我们尝试运行此程序，它将需要60秒，因为我们必须等待time.sleep函数完成。

这里，time.sleep() 只是为了示例而已，但通常你可能会加载一个数据集，因为需要将所有数据复制到内存中而需要很长时间。
事实上，有些程序会将源代码作为输入，对其进行处理，并指出代码的哪些部分可能是错误的。
在Python或一般情况下，这些被称为静态分析工具。
在Python中，例如pyflakes。
如果我们将这段代码输入pyflakes中，pyflakes会给我们指出两个问题。
第一个问题是......第二个问题是我们已经指出的：这里有一个未定义的变量名叫做BAZ。
你可能需要对此进行处理。
另一个问题是：你正在重定义那一行中的FOO变量名。
所以，这里我们定义了一个FOO函数，然后我们通过使用一个循环变量来掩盖该函数。
现在我们定义的那个FOO函数已经不可访问了，如果我们之后尝试调用它，就会出现错误。
还有其他类型的静态分析工具。
MYPY是另一个不同的工具。
MYPY会报告相同的两个错误，但它也会抱怨类型检查。
它会说，这里你正在将一个整数乘以一个浮点数，如果你关心代码的类型检查，你不应该混淆它们。
这可能有点不方便，需要运行这个工具，查看出错的行，然后回到你的VIM或编辑器中，找出这个错误的位置。
已经有解决方案了。
一种方法是将大多数编辑器与这些工具集成在一起，这里...你可以看到bash上有一些红色的高亮，它会读取这里的最后一行。
未定义的变量 'baz'。
所以，当我编辑这段Python代码时，我的编辑器会给我反馈，告诉我这里有什么问题。
或者，这里有另外一个问题，说你正在重新定义未使用的foo。
甚至，有些投诉是关于代码的风格。
例如，我期望有两个空行。

在Python中，函数定义之间应该有两行空行。
有一个关于很多不同编程语言的静态分析工具的课程笔记资源。
甚至还有针对英语的静态分析工具。
我有这门课的笔记，在这个英语静态分析工具“writegood”中运行，它会抱怨一些风格上的问题。
例如，“very”是一个模糊的词汇，我不应该使用它，“quickly”也会削弱含义。
你可以用它来检查拼写错误或进行很多不同类型的风格分析。
目前有什么问题吗？哦，我忘了提到......根据你正在执行的任务，将有不同类型的调试器可用。
例如，如果你在进行Web开发，Firefox和Chrome都有非常好的用于调试网站的工具集。
所以，我们在这里进行元素检查，我们可以得到......你知道吗？如何让这个更大......我们获取了这门课网页的整个源代码。
哦，是的，这个好了吗？现在我们可以实际上更改有关课程的属性。
我们可以编辑标题。
说，这不是一个关于调试和分析性能的课程。
现在网站的代码已经改变了。
这就是为什么你永远不应该相信任何网站的截图的原因之一，因为它们可能被完全修改。
你还可以修改这个样式。
例如，这里我使用了深色模式首选项，但我们可以改变它。
因为在最后一天，浏览器是为我们渲染这个网站的。
我们可以检查cookie，但有很多不同的操作。
JavaScript还有一个内置的调试器，因此你可以逐步调试JavaScript代码。
因此，总结一下，取决于你正在做什么，你可能需要搜索程序员为自己构建的工具。

现在我要转换话题，不再谈论调试，也就是找到代码中的问题，而是开始谈论如何使用性能分析。
性能分析可以帮助你优化代码，可能是因为你想优化CPU、内存、网络等方面的性能。
有许多不同的原因需要进行优化。
就像调试一样，很多人有的第一种方法是使用printf进行性能分析，例如我们可以记录当前时间，然后执行一些操作，再记录时间并从原始时间中减去它。
这样你就可以缩小范围，分析不同部分代码之间的时间差。
这很好。
但有时结果可能会有点意外。
例如，这里我们sleep了0.5秒，输出结果显示是0.5加上一些额外的时间，这很有趣。
如果我们继续运行它，我们会发现一些小的误差。
事实上，我们正在测量的是通常被称为“实际时间”的时间。
实际时间就像你拿着一只钟表，在程序开始时启动，程序结束时停止。
但问题是，在你的计算机中，不仅仅是你的程序在运行。
还有许多其他程序同时在运行，可能是那些正在占用CPU的程序。
因此，为了理解这一点，你会发现很多程序使用的术语是实际时间、用户时间和系统时间。
实际时间就是我解释的整个时间长度，从开始到结束。
然后有用户时间，这是你的程序在CPU上执行用户级别周期所花费的时间。
正如我提到的，在UNIX中，你可以运行用户级别代码或内核级别代码。
系统时间则是相反的，它是你的程序在CPU上执行内核模式指令所花费的时间。

让我们通过一个示例来展示。
这里我要使用一个名为"time"的命令，它将为以下命令获取这三个指标，然后我只是从一个托管在西班牙的网站中获取一个URL。
因此，这将需要一些额外的时间来去那里并返回。
如果我们看到，这里，在程序的开头和结尾之间有两个打印语句。
我们可能会认为这个程序需要大约600毫秒才能执行，但实际上大部分时间都花在等待网络响应上，而我们实际上只花了16毫秒的用户级别和9秒的总时间，实际上执行了CURL代码的时间只有25毫秒，其他都是在等待。
有关计时的任何问题吗？好的，所以计时可能会变得棘手，这也是一种黑匣子解决方案。
或者如果您开始添加打印语句，那么到处都是打印语句会变得很难。
所以程序员已经找到了更好的工具。
这些通常称为"分析器"。
我要快速提醒一下的是，分析器通常是指CPU分析器，因为它们是最常见的，可以确定CPU上花费时间的位置。
分析器通常有两种类型：跟踪分析器和采样分析器。
知道它们之间的区别很好，因为输出可能会不同。
跟踪分析器会对您的代码进行插桩。
所以它们会随着您的代码执行，并在每次代码进入函数调用时进行记录。
就像这个时刻我们正在进入这个函数调用，然后继续前进，一旦完成，它们可以报告你在这个函数中执行了多少时间，在另一个函数中执行了多少时间，以此类推，这就是我们现在将要看到的例子。
另一种类型的工具是跟踪采样分析器。
跟踪分析器的问题在于它们会增加很多开销。
就像您可能正在运行您的代码，并且在您旁边进行这些统计分析，这将影响您程序的性能，所以您可能会得到稍微偏差的统计数。

采样分析器会执行您的程序，并在每100毫秒、10毫秒或其他定义的时间段内停止程序。
它会停止程序，查看堆栈跟踪并确定当前在层次结构中的哪个函数正在执行。
理念是只要您足够长时间执行此操作，就可以获得足够的统计数据，了解大部分时间都花在了哪里。
接下来让我们看一个跟踪分析的例子。
这里有一段代码，它只是 Python 中 grep 的一个简单重新实现。
我们想要检查程序的瓶颈在哪里。
我们只是打开了一堆文件，试图匹配这个模式，然后在找到匹配项时打印出来。
可能是正则表达式，也可能是打印操作，我们不确定。
为了在 Python 中执行这个操作，我们使用 "cProfile"。
我调用这个模块，说我想按总时间排序，我们会很快看到这个。
我调用我们刚才在编辑器中看到的程序。
我要执行这个程序一千次，然后将 grep 的参数应用于这里的所有 Python 文件。
这将产生一些输出，然后我们将查看它。
首先是所有 grep 的输出，但最后，我们得到了分析器本身的输出。
如果我们向上滚动，我们可以看到，通过排序，我们可以看到总调用次数。
因为我们执行了这个程序一千次，所以我们执行了8000次调用，这是我们在这个函数中花费的总时间(累计时间)。
在这里，这个内置方法 IO open 表示我们花费了大量时间等待从磁盘读取或...在这里，我们可以检查，大量时间也花在了尝试匹配正则表达式上，这是可以预期的。

使用此追踪分析器的一个警告是，正如您可以看到的那样，我们看到了我们的函数，但也看到了很多与内置函数对应的函数。
因此，像来自库的第三方函数这样的函数。
随着您构建越来越复杂的代码，这将变得更加困难。
这里是另一个Python代码片段，不要阅读它，它只是获取课程网站，然后打印出所有的超链接。
因此有这两个操作：前往该网站，获取并解析它，然后打印链接。
我们可能想要了解这两个操作之间的比较。
如果我们尝试执行cProfiler，我们将执行相同的操作，这不会打印任何内容。
我正在使用到目前为止我们没有见过的一个工具，但我认为它很好。
它是"TAC"，是"CAT"的反向，并且会反转输出，因此我不必上下查看。
我们这样做，嘿，我们得到了一些有趣的输出。
我们在这个内置方法socket_getaddr_info、_imp_create_dynamic和method_connect中花费了大量的时间以及posix_stat…，我的代码中没有直接调用这些函数，因此我不知道发出Web请求和解析该Web请求的输出之间的拆分是什么。
因此，我们可以使用不同类型的分析器，即行分析器。
行分析器只会以更易读的方式呈现相同的结果，即对于此代码行，这是花费的时间。
因此，我们必须向Python函数添加一个装饰器来完成这项工作。
当我们这样做时，我们现在获得了略微裁剪的输出，但主要思路是我们可以查看时间百分比，并且我们可以看到进行此请求、获取操作所花费的时间占总时间的88%，而解析响应所花费的时间仅占10.9%。
这可能非常有信息量，许多不同的编程语言都将支持这种类型的行分析。

有时你可能不关心 CPU 的性能，也许你关心内存或其他资源。
同样地，也有内存分析器：在 Python 中有 "memory_profiler"，在 C 中有 "Valgrind"。
这里是一个相当简单的例子，我们只是创建了一个包含一百万个元素的列表。
这将占用大约几兆字节的空间，并且我们做同样的事情，创建另一个包含两千万个元素的列表。
为了检查内存分配情况，我们可以使用一个内存分析器来执行它，并告诉我们总内存使用量和增量。
我们可以看到一些开销，因为这是一种解释性语言，当我们创建一个包含一百万条条目的列表时，我们将需要这么多兆字节的信息。
然后我们又得到了另外 150 兆字节。
接下来，我们释放了这个条目，总量就减少了。
我们没有因为错误而得到负增量，可能是在分析器中出现了 bug。
但是，如果你知道你的程序占用了大量内存，而你不知道为什么，可能是因为你在复制对象，而不是应该在原地进行操作，那么使用内存分析器就可以非常有用。
实际上，有一个练习将带领你完成这个操作，比较就地排序的版本和不是就地排序的版本，后者会不断制作新的副本。
如果你使用内存分析器，你可以得到两者之间的很好的比较。
有没有关于分析的问题？内存分析器是在运行程序以获得结果吗？是的……你可能能够通过查看代码来弄清楚。
但是随着程序越来越复杂，这就不是那么容易了（至少对于这个代码而言）。
这个工具会运行程序，并在每一行开始时查看堆，然后说“我现在分配了哪些对象？我有七兆字节的对象”，然后再到下一行，再次查看，“噢，现在我有 50 兆字节，所以我现在增加了 43 个”。
你可以在代码中要求这些操作的每一行自己完成这个操作，但这不是你应该做的，因为别人已经为你编写了这些工具。
正如 strace 的情况一样，你可以在分析中做类似的事情。
也许你不关心具体的代码行，但是你想检查外部事件。

你可能想检查你的计算机程序使用了多少CPU周期，或者它创建了多少页面错误。
也许你的缓存位置很差，这些问题会以某种方式表现出来。
为此，有一个“perf”命令。
perf命令会运行你的程序，并跟踪所有这些统计数据，并将它们反馈给你。
如果你在低层级工作，这将非常有帮助。
我们执行此命令，我将简要解释它在做什么。
stress程序只是在CPU中运行，它只是一个程序，用于独占一个CPU，并测试您是否可以独占CPU。
现在，如果我们Ctrl-C，我们可以返回并获取有关页面错误数量或我们的代码使用的CPU周期的一些信息。
对于某些程序，你可以查看正在使用的函数。
因此，我们可以记录此程序正在执行的操作，我们不知道这是因为这是其他人编写的程序。
我们可以通过查看堆栈跟踪来报告它正在执行的操作，然后说，哦，它花费了大量时间在这个__random_r标准库函数上。
这主要是因为独占CPU的方法是通过创建越来越多的伪随机数。
还有一些未映射的其他函数，因为它们属于程序，但如果你知道你的程序，你可以使用更多的标志显示有关perf的信息。
有关如何使用这个工具的非常好的在线教程。
还有一个关于分析器的问题，到目前为止，我们已经看到这些分析器在聚合所有这些信息并为你提供大量这些数字方面非常出色，这样你就可以优化你的代码或者你可以理解正在发生的事情，
人类不擅长处理大量数字，而且由于人类更善于视觉处理，因此使用可视化工具更容易理解。
程序员已经想到了解决方法。
一些流行的可视化工具包括 FlameGraph。
FlameGraph 是一种采样分析器，通过运行代码并采样来收集数据。
在 y 轴上，我们有堆栈的深度，因此我们知道 bash 函数调用了另一个函数，然后调用了另一个函数，以此类推。
在 x 轴上，它不是时间戳，而是执行时间。
因为这是采样分析器：我们只能得到程序运行的一些瞬间的样本。
但我们知道例如这个主程序需要最长的时间，因为 x 轴与此成比例。
它们是交互式的，并且对于确定程序中的热点非常有用。
另一种显示信息的方法是使用调用图，也有关于如何使用这种工具的练习。
调用图将显示信息，并创建一个函数调用了哪个其他函数的图。
然后，您可以获得有关信息，例如我们知道 "main" 调用了这个 "Person" 函数十次并且它花费了这么多时间。
随着程序越来越大，查看其中一个调用图可以帮助确定您的代码的哪个部分调用了非常昂贵的 IO 操作，例如。
最后，有时您甚至可能不知道程序中哪个资源受限。
例如，如何知道我的程序使用了多少 CPU 或内存。
因此，有许多非常聪明的工具可以做到这一点，其中之一是 HTOP。
HTOP 是一个交互式的命令行工具，它显示此机器具有的所有 CPU，即 12 个。
它显示内存量，并显示我使用了接近 32GB 机器内存中的 1GB。

然后我得到了所有不同的进程。
例如我们有zsh、mysql和其他在这台机器上运行的进程，我可以通过它们消耗的CPU数量或它们运行的优先级进行排序。
我们可以通过运行stress命令来检查。
在这里，我们再次运行stress命令以占用四个CPU，并检查我们是否可以在HTOP中看到它们。
我们确实发现了这四个CPU任务，现在我发现除了之前我们看到的，现在我还有这个“stress -c”命令在运行并占用了我们大量的CPU。
尽管您可以使用分析器来获取类似于此的信息，但是HTOP以实时交互的方式显示此类信息可能更快速和更易于解析。
在笔记中，有一个非常长的列表，列出了用于评估系统不同部分的各种工具。
那可能是用于分析网络性能的工具，或者查看IO操作的数量，以便您知道是否饱和了从磁盘读取，您还可以查看空间使用情况。
我想在这里，NCDU…有一个名为“du”的工具，它代表“磁盘使用”，我们有“-h”标志用于“人类可读的输出”。
我们可以进行视频，然后获得有关此文件夹中所有文件大小的输出。
是的，就是这样。
还有互动版本，例如HTOP是一个互动版本。
因此，NCDU是一个互动版本，让我可以浏览文件夹，我可以快速看到哦，这是视频讲座之一的文件夹，我们可以看到有这四个文件，每个文件大小都接近9 GB，我可以通过此界面快速删除它们。
另一个很棒的工具是“LSOF”，它代表“打开文件列表”。
您可能遇到的另一种模式是，您知道某个进程正在使用文件，但您不知道确切是哪个进程在使用该文件。
或者，类似地，某个进程正在侦听端口，但是，您又如何找出它是哪个进程呢？
那么让我们来举个例子。
我们在444端口上运行一个Python HTTP服务器。
也许我们不知道它正在运行，但是我们可以使用……我们可以使用LSOF。
是的，我们可以使用LSOF，而LSOF将打印大量信息。
您需要SUDO权限，因为它将要求谁拥有所有这些项。
由于我们只关心在此444端口上监听的进程，因此我们可以使用grep查询。
然后我们可以看到，有一个Python进程，具有此标识符，正在使用该端口，然后我们可以将其终止，从而终止该进程。
同样，有许多不同的工具可供使用。
甚至有用于进行所谓基准测试的工具。
因此，在Shell工具和脚本讲座中，我说过对于某些任务，“fd”比“find”快得多。
但是，如何检查呢？我可以使用“hyperfine”来测试它，这里有两个命令：一个使用“fd”仅搜索JPEG文件，另一个使用“find”执行相同的操作。
如果我执行它们，它会对这些脚本进行基准测试，并向我提供有关“fd”相对于“find”快多少的一些输出。
因此，我认为这种总览已经讲完了。
我知道有很多不同的主题和不同的视角来处理这些事情，但是我想再次强调的是，您不需要成为所有这些主题的专家，而是要意识到所有这些东西的存在。
因此，如果您遇到这些问题，您不需要重新发明轮子，而是可以重用其他程序员所做的所有工作。
鉴于此，我很乐意回答与本节或讲座中任何内容有关的问题。
有没有什么办法来大概估算程序需要多长时间？如果它运行时间较长，您是否应该担心？或者根据您的进程，您应该再等十分钟再开始查找为什么它运行时间这么长？
好的，了解一个程序需要运行多长时间的任务是非常难以确定的，这将取决于程序的类型。
这取决于您是在进行HTTP请求还是在读取数据......你可以做的一件事是，如果你知道你需要从内存或磁盘中读取两个千兆字节的数据，并将其加载到内存中，你可以进行快速的计算。
因为事情是这样安排的，所以那应该不会超过X秒。
或者，如果您从网络读取某些文件，并且知道网络链接是什么，并且它们花费的时间比您预期的要长五倍，则可以尝试这样做。
否则，如果您不是很确定。
例如，如果您在代码中尝试进行某些数学操作，并且不确定需要多长时间，您可以使用类似于日志记录的方式，并尝试打印中间阶段，以了解需要执行多少次操作以及三次迭代花费了十秒钟，那么在我的情况下，这将需要更长时间才能完成。
所以，我认为有很多方法可以解决这个问题，这又将取决于任务，但是，鉴于我们看到的所有工具，我们可能有几种很好的方法来开始解决这个问题。
还有其他问题吗？您还可以运行HTOP并查看是否有任何正在运行的东西。
如果您的CPU使用率为0％，那么可能出了问题。
好的。
今天的课程有很多练习，所以请随意选择您感兴趣的练习。
我们今天还将举行办公时间，只是提醒一下，办公时间。
您可以来问任何关于任何课程的问题。
我们不会期望您在几分钟内完成练习。
他们需要很长时间才能完成，但是我们将在那里回答关于以前课程的任何问题，甚至与练习无关的问题。
例如，如果您想了解如何使用TMUX以快速在窗格之间切换，任何想到的问题。
