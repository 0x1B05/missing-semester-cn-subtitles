今天我们将讨论与 shell 相关的两个主要主题。
首先，我们将进行一些 shell 脚本编写，主要涉及到 bash，这是大多数人在 Mac 或像大多数 Linux 系统中启动的默认 shell。
它也与其他 shell（如 zsh）兼容，非常实用。
然后，我们将介绍一些其他非常方便的 shell 工具，以便您避免执行一些重复的任务，例如查找某些代码或某些难以找到的文件。
已经有一些内置命令非常有用，可以帮助您完成这些任务。
昨天，我们已经介绍了 shell 的一些特性，以及如何开始执行命令并将其重定向。
今天，我们将更详细地介绍 shell 的变量语法、控制流和函数等内容。
例如，一旦您进入 shell，您可能想要定义一个变量，这是学习编程语言的第一步。
在这里，您可以执行类似 "foo=bar" 的操作。
现在，我们可以通过 "$foo" 来访问 foo 的值。
这是非常完美的。
需要注意的一个问题是，在处理 bash 时，空格非常关键。
主要是因为空格是保留字符，用于分隔参数。
因此，例如，"foo=bar" 将不起作用，shell 会告诉您为什么不起作用。
这是因为 shell 会将 "foo" 和 "=bar" 视为两个参数，而不是将 "foo=bar" 视为一个整体。
通常情况下，当您遇到一些问题时，例如一些带有空格的文件时，需要小心处理。
您需要小心引用字符串。
因此，我们将讨论在 bash 中如何使用字符串。
有两种方法可以定义字符串：您可以使用双引号定义字符串，也可以使用单引号定义字符串。
然而，对于文字字符串，它们是等效的，但对于其他情况则不然。
例如，如果我们执行 "value is $foo"，则会将 "$foo" 展开为字符串，并将其替换为 shell 中 foo 变量的值。
而如果我们使用单引号，则只是获取 "$foo"，而单引号不会进行替换。
再次强调，很容易编写一个脚本，假设这类似于您更熟悉的 Python，而没有意识到这一点。
这是您将赋值变量的方式。
然后，bash 还具有控制流技术，例如 for 循环、while 循环，还有一个主要的事情是您可以定义函数。
我们可以访问此处定义的 MCD 函数。
目前为止，我们只是演示了如何通过将多个命令使用管道传输来执行这些命令。
昨天简要介绍了这种方法。
但是在很多情况下，你会想先执行一件事，然后再做另一件事。
这就像我们在这里看到的按顺序执行的例子一样。

例如，在这里，我们调用了MCD函数。
我们首先调用makedir命令来创建这个目录。
在这里，$1是一种特殊变量。
这是Bash的工作方式。
在其他脚本语言中，可能会有类似于argv的数组，其中第一项将包含该参数。
在Bash中，它表示为$1。
通常，在Bash中，许多内容都以$加上一些内容为前缀，表示它们是保留关键字。
稍后我们会看到更多例子。
一旦我们创建了文件夹，我们就进入该文件夹，这是一种相当常见的模式。
我们可以在shell中直接输入这个命令，它会起作用并定义该函数。
但是，有时将这些内容写入文件会更好。
我们可以使用source命令来执行该脚本并在我们的shell中加载它。
现在看起来好像什么都没有发生，但是现在MCD函数已经在我们的shell中定义了。
因此，我们现在可以执行MCD test命令，然后我们从tools目录移动到test目录。
我们既创建了文件夹，又进入了它。
还有什么？我们可以使用$1来访问第一个参数。
还有很多保留命令，例如$0表示脚本的名称，$2到$9将是Bash脚本接收的第二到第九个参数。
其中一些保留关键字可以直接在shell中使用，例如$?可以获取上一个命令的错误代码，我将简要解释一下。
但例如$ _可以获取上一个命令的最后一个参数。
因此，我们也可以这样做，例如使用“mkdir test”，而不需要重复输入test，我们可以使用$_作为上一个命令的一部分来访问上一个参数，这样它将被替换为test，然后我们进入test。
还有很多这样的命令，你应该熟悉它们。
我经常使用的另一个命令叫做"bang bang"（"!!"），当你尝试创建某些东西但没有足够的权限时，你会遇到它。
然后，你可以执行“sudo !!”命令，然后它将替换其中的命令，现在你可以尝试执行该命令。
现在它会提示你输入密码，因为你拥有sudo权限。
之前，我提到了错误命令。
昨天我们提到，进程可以通过不同的方式与其他进程或命令进行通信。
除了标准输入和标准输出之外，还有一个标准错误流，它用于在程序编写时输出错误信息，以避免污染标准输出。
还有一个错误代码，这是许多编程语言中通用的东西，可以报告程序的整体运行情况。
因此，如果我们执行像"echo hello"这样的命令，并且检查其错误代码，它将为零。
这是因为一切都很顺利，没有出现任何问题。
零的退出代码与C语言中的退出代码相同，例如0表示一切顺利，没有错误。

但是，有时事情并不按照我们预期的方式进行。
例如，如果我们在MCD脚本中使用"grep foobar"命令，然后检查其错误代码，它将为1。
这是因为我们试图在MCD脚本中搜索"foobar"字符串，但是该字符串不存在。
因此，grep不会输出任何内容，但是通过返回一个1的错误代码告诉我们发生了错误。
还有一些有趣的命令，比如"true"，它的错误代码始终为零，而"false"的错误代码始终为1。
通过使用这些逻辑运算符，我们可以执行某些条件语句。
例如，一种方式是使用"OR"运算符连接两个命令，如果第一个命令失败，则Bash将执行第二个命令。
如果第一个命令的错误代码不为零，Bash将尝试执行第二个命令。
同样，使用"AND"运算符连接两个命令时，只有在第一个命令没有错误的情况下才会执行第二个命令。
如果第一个命令失败，则Bash将不会执行第二个命令。
此外，无论执行什么命令，都可以使用分号将它们连接在同一行中，并将它们打印出来。
另外，我们还没有学习如何将命令的输出存储到变量中。
我们可以使用命令替换实现这一点。
例如，使用"PWP"命令获取当前工作目录并将其存储到变量"foo"中，然后可以通过检查变量"foo"来查看当前工作目录。
通常情况下，可以将命令替换放入任何字符串中。
如果使用双引号而不是单引号，则该命令将被扩展为字符串并输出结果。
另一个有趣的事情是，现在该命令正在被扩展为一个字符串，而不仅仅是输出字符串。
另一个巧妙而不那么为人所知的工具叫做进程替换，它有点类似。
它会在命令中使用特殊符号（例如“<”），并与另一个括号一起使用，执行命令并将输出存储到类似临时文件的地方，并将文件句柄提供给命令。
所以在这里，我们使用进程替换获取目录列表（通过ls命令），将其存储到临时文件中，然后对父文件夹进行相同的操作，并将两个文件合并。
这种方法非常方便，因为一些命令不接受标准输入，而是期望从文件中读取参数。
这样我们就得到了两个文件的内容合并在一起的结果。
到目前为止，我们已经学到了很多信息。
现在让我们看一个简单的示例脚本，其中包含一些这样的操作。
例如，在这里，我们有一个字符串和一个$date命令。
在UNIX中有很多这样的命令，您会逐渐熟悉其中的很多。
$date命令用于打印当前日期，您可以指定不同的格式。
接下来，我们会用到以下变量：$0，它代表当前脚本的名称；$#，它表示该命令传入的参数个数；$$，它是该命令的进程 ID。
可能会有很多这样的美元符号，不太直观，因为它们没有一种容易记忆的方式，例如$#。
但是，我们会逐渐熟悉它们。
在这里，我们使用了$@，它会将所有的参数展开。

这样，我们就不必假设有三个参数，并编写 $1，$2，$3。
如果我们不知道有多少个参数，我们可以将它们全部放在 $@ 中，然后将其传递给 for 循环。
for 循环会按顺序获取每个参数，并依次将它们传递。
因此，我们可以为每个参数提供代码。
接下来，在下一行，我们运行 grep 命令，它会在某个文件中查找子字符串，例如在文件中查找字符串 "foobar"。
我们在该命令中使用了变量，它们已被展开。
昨天，我们讨论了如何将程序的输出重定向到文件中，以保存它或将它连接到其他文件。
但是有时我们想要相反的效果。
例如，在这里，我们关注...
我们需要注意错误代码。
对于这个脚本，我们需要关心 grep 命令是否成功运行。
因此，我们实际上可以完全忽略输出... 就像 grep 命令的标准输出和标准错误一样。
我们要做的是将输出重定向到 /dev/null，这是 UNIX 系统中的一种特殊设备，您可以像写入文件一样写入数据，但它会被丢弃。
这里有一个 ">" 符号，我们昨天已经讨论过它用于重定向输出。
这里有一个 "2>"，正如一些人可能已经猜到的那样，这是用于重定向标准错误的，因为这两个流是分开的，您需要告诉 bash 如何处理它们。
因此，在这里，我们检查文件是否包含 "foobar"。
如果文件包含 "foobar"，它的退出状态码将为零。
如果没有 "foobar"，它的退出状态码将为非零。
这正是我们要检查的内容。
在这个 if 语句的一部分中，我们说 “给我退出状态码”。
再次使用 $？ 来代表退出状态码。
然后我们使用比较运算符 "-ne"，表示 “不等于”。
在一些其他编程语言中，有时会使用 "=="、"!=" 等符号。
在bash中有一组保留的比较操作符，这主要是因为当您在shell中进行测试时，可能需要测试很多东西。
例如，在这里，我们只是检查两个整数值是否相同。
或者例如在这里，使用"-f"操作符可以让我们知道文件是否存在，这是您经常会遇到的情况。
让我们回到这个例子。
当文件没有名为"foobar"的时候会发生什么？如果存在非零错误代码，则会打印“此文件没有任何foobar，我们将添加一个”。
接着，我们使用运算符“>>”在文件的末尾追加这个“# foobar”的注释。
由于文件已经被送入脚本，我们之前不知道它，因此我们必须替换文件名的变量。
我们可以实际运行这个脚本。

我们已经在这个脚本中具有正确的权限，我们可以举出一些例子。
在此文件夹中，我们有一些文件。
"mcd"是我们在开头看到的MCD函数，还有一些其他的"script"函数。
我们甚至可以将自己的脚本输入到自己中，以检查它是否包含"foobar"。
然后我们运行它，首先可以看到已成功扩展的不同变量。
我们有日期，已经被替换为当前时间。
接着我们使用三个参数运行这个程序，使用随机生成的PID。
然后它告诉我们MCD没有任何"foobar"，所以我们正在添加一个新的。
这个脚本文件没有"foobar"。
让我们以 MCD 为例来说明。
它有我们所需的注释。
在执行脚本时，还有一些需要注意的事情。
这里有三个完全不同的参数，但通常你可以提供更简洁的参数。
例如，如果我们想引用所有以“.sh”结尾的脚本，我们可以使用大多数 shell 支持的“globbing”文件名扩展方式，像这样执行“ls *.sh”。
这将显示任何以“sh”结尾的具有任何字符的内容，这不足为奇，我们会得到“example.sh”和“mcd.sh”。
我们还有“project1”和“project2”，如果有一个叫“project42”，我们也可以执行“project42”，例如，如果我们只想引用名字只有一个字符，但后面没有两个字符的项目，我们可以使用问号。
因此，“？”将扩展为只有一个字符。
然后，我们首先得到“project1”，然后是“project2”。
通常情况下，globbing 可以非常强大，并且可以结合使用。
一个常见的模式是使用所谓的花括号。
假设我们有一个图像文件，我们想将它从 PNG 转换为 JPG，或者我们可以将其复制，或者... 这是一种非常常见的模式，有两个或更多类似的参数，你想将它们作为参数传递给某个命令。
你可以这样做，或者更简洁地说，你可以只是做“image.{png,jpg}”。
这将扩展为上面的行，并且你可以让 zsh 为你完成这个任务。
这确实非常强大。
例如，你可以做一些像...我们可以在一组名为 foo 的文件上执行“touch”，所有这些都会被扩展。
你甚至可以在几个级别上做到这一点，你将得到笛卡尔积的结果...如果我们在这里有一个组“{1,2}”，然后这里有“{1,2,3}”，这将对这两个组的笛卡尔积进行扩展，并将扩展为所有这些东西，我们可以快速地“touch”。
你还可以将星号 glob 与花括号 glob 结合使用。
你甚至可以使用类似于区间的东西，例如，我们可以创建“foo”和“bar”目录，然后我们可以这样做。
这将会扩展到 "fooa", "foob"... 所有这些组合，一直到 "j"，然后对于 "bar" 同样如此。
我还没有真正测试过它，但是我们得到了所有我们能“触及”的组合。
现在，如果我们发现这两个目录中的某些文件不同，我们可以再次运行之前的命令来替换它们。

例如，如果我们想查看这两个文件夹之间有哪些文件不同，我们可以使用“diff”命令比较它们的输出。
虽然我们可以直接看出差异在于 X 和 Y 这两个文件，但是使用“diff”命令更加普遍适用。
此外，我们仅仅看到了 Bash 脚本，但并不意味着 Bash 是最适合所有任务的脚本语言。
事实上，在某些任务中，Bash 甚至可能会很棘手。
实际上，您可以编写脚本与许多不同的 shell 交互，而不仅仅是 Bash。
让我们看一下 Python 脚本的例子。
首先，我们有一个魔法注释，不再赘述。
然后，我们有一个“import sys”语句，它类似于 Bash 中的 $0，$1 等，用于获取参数向量并将其按相反的顺序打印出来。
魔法注释（shebang）是告诉 shell 如何运行这个程序的一行注释。
如果您总是要运行像“python script.py”这样的命令，并附带“a b c”之类的参数，那么您总是可以这样做。
但是，如果您想要在 shell 中运行该脚本，则需要让 shell 知道您希望使用 Python 作为解释器来运行该文件。
这可以在第一行中指定。
此处的第一行使用了“env”命令，该命令在几乎所有系统上都是可用的（有一些例外）。
通过使用“env python”参数，它将查找并使用“python”解释器，然后根据您的环境变量来解释该文件。
这样，该脚本将更加可移植，并且可以在多台计算机上运行。
另一个需要注意的问题是 Bash 不是现代化的脚本语言。
有时候进行调试会很棘手。
默认情况下，一些故障可能不太直观，例如我们之前遇到的“foo”命令不存在的错误。
因此，在课堂笔记中，我们提供了一个非常方便的工具，叫做"shellcheck"。
它可以为您提供警告、语法错误以及其他可能存在的引用错误或文件中错放空格等问题的提示。
例如，对于非常简单的"mcd.sh"文件，我们会得到一些错误提示，比如缺少shebang。
如果在不同的系统上运行，可能无法正确解释该文件。
此外，这个CD命令可能不会正确扩展，所以您可能需要使用类似于"cd"或者"exit"这样的命令。
回到之前解释的内容，这样做的效果就是，如果CD没有正确结束，您不能CD进入该文件夹，因为要么您没有权限，要么它不存在。
这将给出一个非零的错误命令，所以您将执行退出，这将停止脚本，而不是继续执行好像您实际上并不在该文件夹中的命令。
实际上，我还没有测试过，但我认为我们可以检查"example.sh"。
在这里，我们可能需要以不同的方式检查退出代码，因为这种方法可能不是最好的方法。
我想要最后提醒的是，在编写bash脚本或函数时，有两种情况。
一种是在隔离的环境中编写脚本，就像一个您要运行的东西；另一种是将其加载到您的shell中。
我们将在命令行环境讲座中讨论一些内容，其中包括bashrc和sshrc。

总的来说，如果您在bash脚本中更改了您所在的位置，例如您CD进入一个bash脚本并且只执行该bash脚本，它不会CD进入您现在所在的shell。
但是，如果您直接将代码加载到您的shell中，例如您加载源代码函数并执行该函数，那么您将获得这些副作用。
同样的道理也适用于在shell中定义变量。
现在我将讨论一些我认为在处理shell时非常有用的工具。
这也是昨天简单介绍过的内容。
你如何知道应该使用哪些选项或确切的命令？
比如，如果我想知道LS加上"减号L"会以列表格式列出文件，或者如果我执行"move -i"，它会提示我输入内容，那么您可以使用"man"命令。
"man"命令提供很多信息。
例如，在这里它会解释"-i"选项有哪些可选项。
这个技巧非常有用，不仅适用于操作系统中打包好的简单命令，而且还适用于从互联网上安装的工具。
比如，如果你安装了“man”包，那么我们稍后要介绍的名为“ripgrep”的工具，其命令称为 RG，就不会随着操作系统提供。
但是它会安装自己的 man 页面，我们可以从这里访问它。
对于某些命令，man 页面非常有用，但有时候难以理解，因为它更像一份文档，介绍了工具所能做的所有事情。
有时候它包含示例，但有时候不包含，有时候工具可以做很多事情。
因此，我常常使用一些很好的工具，比如“convert”或“ffmpeg”，它们分别处理图像和视频，但它们的 man 页面很大。
因此，有一个很好的工具叫做“tldr”，你可以安装它，然后得到一些很好的示例，说明如何使用该命令。
你可以随时在谷歌上搜索，但我发现我总是要先进入浏览器，查找一些示例，然后再回来。
而“tldr”是由社区贡献的，非常有用。
此外，“ffmpeg”页面提供了很多有用的示例，这些示例的格式更好（如果你没有大号字体记录的话）。
而像“tar”这样的简单命令，则有很多选项需要组合。
比如，在这里，你可以组合 2、3 个不同的标志。
这可能不是很明显，但当你想要组合不同的标志时，这就是了解更多有关这些工具的方法。
在查找文件方面，让我们尝试学习如何查找文件。
你可以使用“ls”，比如“ls project1”，并不断使用 LS 直到底。
但是，也许如果我们已经知道我们要查找所有名为“src”的文件夹，那么可能有更好的命令来完成这个任务。
这就是“find”。
Find 几乎是每个 UNIX 系统都带有的工具。
我们要在当前文件夹中调用 find，记住“.”表示当前文件夹，我们要让它的名称是“src”，类型为目录。
通过输入这个命令，它将递归地浏览当前目录，并查找所有符合此模式的文件或文件夹。
Find 有很多有用的标志。

举个例子，我们想要测试路径，找出一个名为“test”的文件夹中所有的Python脚本，以及所有扩展名为“.py”的文件。
我们并不关心有多少个文件夹，只关心这些文件的存在。
同时，我们也要确保这些文件都是F类型的，即文件类型。
我们可以使用不同的标志，例如“-mtime”用于修改时间，来检查已经修改过的文件，以便只找出过去一天内修改过的文件。
这样做几乎会找到所有的文件。
通过这种方法，我们可以打印出已经创建的和已经存在的文件。
find命令不仅可以查找文件，还可以在查找到这些文件时执行其他任务。
例如，我们可以使用find命令查找所有扩展名为TMP的文件，并告诉它在每个文件上运行“rm”命令。
这将删除所有这些文件。
Shell的另一个好处是它提供了很多工具。
人们会不断发现新的方法，也会有替代的方法来编写这些工具。
了解这些工具非常有用。
例如，如果您只想匹配以“tmp”结尾的文件名，可能需要使用很长的命令。
但是，有一些更短的命令，例如“fd”，默认使用正则表达式并忽略git文件，因此您不必搜索它们。
此外，这些命令还支持彩色编码和更好的Unicode支持。
但是请记住，如果您知道这些工具的存在，您可以节省大量时间，不必做一些繁琐重复的任务。
类似于“find”命令的还有“locate”命令，它可以通过构建一个索引来提高查找速度。
在大多数Unix系统中，locate命令将搜索文件系统中包含指定子字符串的路径。
我实际上不确定这是否有效……好吧，它有效了。
让我试试类似于“missing-semester”这样的东西。
实际上，大多数Unix系统已经使用“locate”命令完成了这个功能，它会使用已经构建好的索引来查找包含您想要的子字符串的路径，这样可以快速完成搜索。
为了保持索引更新，我们使用正在通过cron运行的“updatedb”命令更新它。
再次查找文件非常有用。
有时候您实际上关心的不是文件本身，而是文件的内容。
您可以使用我们迄今为止介绍的grep命令来搜索文件内容。
例如，您可以在MCD中运行grep foobar来搜索文件内容。
如果您想再次递归地搜索当前结构并查找更多文件，怎么办？我们不想手动完成这项工作。
实际上，“grep”有一个“-R”标志，它将遍历整个目录。
例如，如果我们想查找所有包含“foobar”字符串的文件，我们可以使用“grep -R foobar .”命令，这会搜索当前目录和所有子目录中的所有文件。
它告诉我们在这三个位置的example.sh和在这另外两个位置的foobar中都有foobar行。
这可能非常方便。

主要用例是，您知道您已经在某种编程语言中编写了一些代码，并且知道它在您的文件系统的某个地方，但您实际上不知道在哪里。
但您可以快速搜索。
例如，我可以快速搜索我在scratch文件夹中使用请求库的所有Python文件。
如果我运行这个命令，“rg requests -t py scratch/”它会搜索所有这些文件，并精确地给出在哪一行找到了它。
这里，我没有使用grep，而是使用了“ripgrep”，它与grep的想法有点相似，但是又尝试带来更多的漂亮之处，比如彩色编码或文件处理等。
它也支持unicode。
它也非常快，因此您不必担心速度较慢的折衷。
还有许多有用的标志。
我们还可以做其他事情，例如在这里搜索。
更高级的用法，我们可以使用“-u”表示不忽略隐藏文件。
有时候你会希望忽略隐藏文件，但是如果你要搜索默认情况下隐藏的配置文件，就不应该忽略它们。
然后，我们不是打印匹配项，而是要求执行一些可能很难使用 grep 从我的头脑中想出的操作。
我想要你打印所有不匹配给出的模式的文件，这可能是一个奇怪的请求，但我们继续下去...
这里的模式是一个小正则表达式，它表示在行的开头有一个“#”和一个“!”，这是一个 shebang。
我们在这里搜索所有没有 shebang 的文件，然后在这里给它一个“-t sh”只查找“sh”文件，因为你的 Python 或文本文件可能没有 shebang 也没问题。
这告诉我们，“哦，MCD 显然缺少一个 shebang”，我们甚至可以... 
它有一些不错的标志，例如如果我们包括“stats”标志，它将得到所有这些结果，但它还将告诉我们有关它所搜索的所有内容的信息，例如找到的匹配次数、行数、搜索的文件、打印的字节数等等。
与“fd”类似，有时使用一个特定的工具或另一个工具并不是很有用。
事实上，像 ripgrep 一样，还有其他几个工具。
像“ack”这样的工具是最初编写的 grep 替代工具，然后是另一个工具"ag"。
它们都可以相互替换，所以也许你所在的系统有一个而没有另一个，只要知道你可以使用这些工具就会非常有用。
最后，我想谈谈如何查找你已经找到的命令，而不是找文件或代码。
第一种显然的方法是使用向上箭头，慢慢浏览你的历史记录，寻找这些匹配项。
这实际上并不是很高效，你可能已经猜到了。
因此，Bash 有更轻松的方法来做这件事。
有一个"history"命令，会打印出你的历史记录。
这里我在 zsh 中，它只打印出一部分历史记录，但如果我说，我想要你从一切开始打印，它将从这个历史记录的开始打印一切。
由于这是很多结果，也许我们关心的是我们使用"convert"命令从某种文件类型转换为另一种文件类型的那些结果。
然后，我们获得了所有与该子字符串匹配的结果。

几乎所有的 shell 默认都会将“Ctrl+R”这个键绑定为反向搜索。
这里我们有一个反向搜索，我们可以输入“convert”，它会找到我们刚输入的命令。
如果我们一直按下“Ctrl+R”键，它会浏览这些匹配项，让我们可以在原地重新执行命令。
另一个相关的操作是使用一个非常棒的工具叫做“fzf”，它就像一个模糊查找器，可以让你进行交互式的 grep 操作。
例如，我们可以使用 cat 命令打印 example.sh 文件中的内容，并将其传递给 fzf 工具。
fzf 可以获取所有的行，然后让我们可以交互式地查找我们关心的字符串。
fzf 的好处是，如果你启用了默认绑定，它就会绑定到你的“Ctrl+R”键，让你能够快速地查找历史记录中转换 favicon 的时间。
fzf 还具有模糊匹配的功能，而默认情况下 grep 或者其他工具必须使用正则表达式或者其他表达式来进行匹配。
在这里，我只输入了"convert"和"favicon"这两个关键字，fzf 就会尝试做出最佳的扫描，在它拥有的行中进行匹配。
最后，介绍一个你可能已经见过的工具，我用它来避免重新输入这些非常长的命令，它叫做"history substring search"。
当我在 shell 中输入命令时，它可以让我动态地在历史记录中搜索具有相同前缀的相同命令，然后，如果你……，它会在匹配列表中停止工作，并且可以使用右箭头选择要执行的命令，然后重新执行它。
我们已经看到了一些工具……我觉得还有几分钟的时间，所以我要介绍一些快速目录列表和目录导航的工具。
你可以使用"-R"选项递归地列出某个目录结构，但这可能不是最佳选择，因为不太容易理解。
有一个叫做"tree"的工具，它可以更友好地打印出所有的目录结构，并根据颜色代码进行着色。
例如，"foo" 是蓝色的，因为它是一个目录，而这个是红色的，因为它有执行权限。
但是我们还可以做得更好。
有一些很好的工具，比如最近出现的一个叫做"broot"的工具，它可以完成同样的任务。
在这里，例如不像列出每一个单独的文件，例如在"bar"中，我们有这些"a"到"j"的文件，它会提示"噢，还有更多，没有列在这里"。
实际上，我可以开始输入，它会再次匹配到那些存在的文件，我可以快速选择它们并浏览它们。
因此，了解这些事情很重要，这样你就不会浪费大量时间去寻找这些文件。
另外，我认为我也安装了一些更类似于你所期望的操作系统拥有的工具，比如Nautilus或者其中一个Mac Finder。
它们有一个交互式的输入，你可以使用导航箭头快速浏览。
这可能有点过度，但你会惊讶地发现，通过浏览某个目录结构，你可以很快地理解它。
几乎所有这些工具都会让你编辑、复制文件……如果你只是寻找它们的选项的话。
最后有一个复杂的补充内容。
我们有"cd"，它很好用，可以让你到达很多地方。
但是如果你可以快速到达一些你最近或经常去的地方，那就非常方便了。
你可以用很多种方式做到这一点。
也许你会想到做书签、在shell中创建别名、创建符号链接。
但是此时，程序员已经构建了所有这些工具，所以程序员已经找到了一个非常好的方法来实现这一点。

其中一种方法是使用所谓的"auto jump"。
我认为这里没有加载……好的，别担心。
我将在命令行环境中介绍它。
我想这是因为我禁用了"Ctrl+R"，这也影响了脚本的其他部分。
如果你有任何相关的问题，我很乐意回答，如果有任何不清楚的地方。
否则，我们已经编写了一堆练习，涉及这些主题。
我们鼓励你尝试它们，并在办公时间前来。
我们可以帮助你弄清如何做这些事情，或者介绍一些不明确的bash技巧.